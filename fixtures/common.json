[{"model": "auth.user", "pk": 1, "fields": {"password": "pbkdf2_sha256$320000$80IY3bG5cS1x2pBTsi0QQv$4Ym0KyTxZe+r0vxT5FXHXoUwV/xqox0hTHSoyc/RZcY=", "last_login": "2022-07-29T22:40:08.946Z", "is_superuser": true, "username": "root", "first_name": "", "last_name": "", "email": "", "is_staff": true, "is_active": true, "date_joined": "2022-06-08T13:20:47.666Z", "groups": [], "user_permissions": []}}, {"model": "auth.user", "pk": 2, "fields": {"password": "pbkdf2_sha256$320000$msH2LBPxEFTcW60ZCiQtyM$jqxsYvZTsM8iXmFsCzczHOg8RLEx9yew0XS18xiHFv4=", "last_login": "2022-07-27T19:25:48.641Z", "is_superuser": true, "username": "admin", "first_name": "", "last_name": "", "email": "", "is_staff": true, "is_active": true, "date_joined": "2022-07-05T14:31:33.199Z", "groups": [], "user_permissions": []}}, {"model": "sites.site", "pk": 1, "fields": {"domain": "codefather.dev", "name": "codefather.dev"}}, {"model": "sites.site", "pk": 2, "fields": {"domain": "www.codefather.dev", "name": "www.codefather.dev"}}, {"model": "core.tag", "pk": 1, "fields": {"uuid": "643c26e7-1906-4e0c-88d8-fc5e97d6a872", "created_at": "2022-06-08T13:27:34.208Z", "updated_at": "2022-07-29T22:41:46.721Z", "name": "Hashing", "slug": "hashing"}}, {"model": "core.tag", "pk": 2, "fields": {"uuid": "4a71c1b9-9586-4866-9334-024a85babd02", "created_at": "2022-06-08T13:27:41.323Z", "updated_at": "2022-07-29T22:41:43.675Z", "name": "Optimisation", "slug": "optimisation"}}, {"model": "core.tag", "pk": 3, "fields": {"uuid": "4878843c-4bfe-4af5-81d7-9556494d3fc7", "created_at": "2022-06-08T13:28:06.030Z", "updated_at": "2022-07-29T22:41:39.745Z", "name": "Consistent hashing", "slug": "consistent-hashing"}}, {"model": "core.tag", "pk": 5, "fields": {"uuid": "a7877206-b755-4a6f-8701-c74be994b615", "created_at": "2022-06-08T14:34:23.408Z", "updated_at": "2022-07-29T22:41:36.536Z", "name": "Highload", "slug": "highload"}}, {"model": "core.tag", "pk": 6, "fields": {"uuid": "3a4aa4f5-a3f6-46ee-8a9c-25b4f10bffb5", "created_at": "2022-06-08T14:34:40.444Z", "updated_at": "2022-07-29T22:41:33.489Z", "name": "Limiting", "slug": "limiting"}}, {"model": "core.tag", "pk": 9, "fields": {"uuid": "b950807d-535f-4c41-886f-f4bf60b82623", "created_at": "2022-07-29T18:18:27.086Z", "updated_at": "2022-07-29T22:41:30.108Z", "name": "Concurrency", "slug": "concurrency"}}, {"model": "core.tag", "pk": 10, "fields": {"uuid": "75f5232a-6c14-4374-b756-1ce43001575b", "created_at": "2022-07-29T18:18:33.622Z", "updated_at": "2022-07-29T22:41:27.093Z", "name": "Parallel", "slug": "parallel"}}, {"model": "core.tag", "pk": 11, "fields": {"uuid": "239b1ede-0d33-43a2-b637-cfe7f6a0cf0e", "created_at": "2022-07-29T18:19:04.256Z", "updated_at": "2022-07-29T22:41:23.537Z", "name": "Internals", "slug": "internals"}}, {"model": "core.tag", "pk": 12, "fields": {"uuid": "7dd07465-0ef9-44e2-9aa9-fd683c1c00bf", "created_at": "2022-07-29T18:19:12.404Z", "updated_at": "2022-07-29T22:41:18.977Z", "name": "Low-level", "slug": "low-level"}}, {"model": "core.category", "pk": 4, "fields": {"uuid": "ce837b0c-9a19-40a1-8475-bded2c0a7fdc", "created_at": "2022-07-29T18:18:18.932Z", "updated_at": "2022-07-29T22:40:22.794Z", "name": "Article", "slug": "article"}}, {"model": "core.category", "pk": 5, "fields": {"uuid": "d241036f-180e-419a-ac02-7e8d366229e9", "created_at": "2022-07-29T22:40:29.734Z", "updated_at": "2022-07-29T22:40:29.734Z", "name": "How To", "slug": "how-to"}}, {"model": "core.postmetatag", "pk": 1, "fields": {"meta_tag_type": "name", "meta_tag_key": "general", "meta_tag_content": "codefather.dev", "meta_model": 6}}, {"model": "core.postmetatag", "pk": 2, "fields": {"meta_tag_type": "property", "meta_tag_key": "og:title", "meta_tag_content": "codefather.dev", "meta_model": 6}}, {"model": "core.postmetatag", "pk": 3, "fields": {"meta_tag_type": "name", "meta_tag_key": "author", "meta_tag_content": "Vladyslav Bergman", "meta_model": 6}}, {"model": "core.postmetatag", "pk": 4, "fields": {"meta_tag_type": "name", "meta_tag_key": "og:locale", "meta_tag_content": "en_US", "meta_model": 6}}, {"model": "core.postmetatag", "pk": 5, "fields": {"meta_tag_type": "property", "meta_tag_key": "og:description", "meta_tag_content": "codefather.dev", "meta_model": 6}}, {"model": "core.postmetatag", "pk": 6, "fields": {"meta_tag_type": "property", "meta_tag_key": "og:url", "meta_tag_content": "https://codefather.dev", "meta_model": 6}}, {"model": "core.postmetatag", "pk": 7, "fields": {"meta_tag_type": "property", "meta_tag_key": "og:site_name", "meta_tag_content": "codefather.dev", "meta_model": 6}}, {"model": "core.post", "pk": 6, "fields": {"uuid": "34749421-09a3-4569-b6d1-84f14647dfc8", "created_at": "2022-07-24T11:44:25.501Z", "updated_at": "2022-07-29T22:32:25.989Z", "meta_title": null, "meta_description": null, "language": "ru", "title": "Parallelism and concurrency", "slug": "parallelism-and-concurrency", "markdown": "# Parallelism and Concurrency\n\nThe first computers were designed to do one thing at a time. A lot of their work was in the field of computational mathematics. As time went on, computers are needed to process inputs from a variety of sources. Some input as far away as distant galaxies. The consequence of this is that computer applications spend a lot of time idly waiting for responses. \n\nWhether they be from a bus, an input, memory, computation, an API, or a remote resource. Another progression in computing was the move in Operating Systems away from a single-user terminal, to a multitasking Operating System. Applications needed to run in the background to listen and respond on the network and process inputs such as the mouse cursor. Multitasking was required way before modern multiple-core CPUs, so Operating Systems long could to share the system resources between multiple processes.\n\nAt the core of any Operating System is a registry of running processes. Each process will have an owner, and it can request resources, like memory or CPU. In the last chapter, you explored memory allocation. For a CPU, the process will request CPU time in the form of operations to be executed. The Operating System controls which process is using the CPU. It does this by allocating “CPU Time” and scheduling processes by a priority:\n\n![58](localhost:9000/media/post/python_internals/58.png)\n\nA single process may need to do multiple things at once. For example, if you use a word processor, it needs to check your spelling while you’re typing. Modern applications accomplish this by running multiple threads, concurrently, and handling their own resources. \n\nConcurrency is an excellent solution to dealing with multitasking, but CPUs have their limits. Some high-performance computers deploy either multiple CPUs or multiple cores to spread tasks. Operating Systems provide a way of scheduling processes across multiple CPUs:\n\n![59](localhost:9000/media/post/python_internals/59.png)\n\nIn summary,\n\n- To have **parallelism**, you need multiple computational units. Computational units can be CPUs or Cores.\n- To have **concurrency**, you need a way of scheduling tasks so that idle ones don’t lock the resources. \n\nMany parts of CPython’s design abstract the complexity of Operating Systems to provide a simple API for developers. CPython’s approach to parallelism and concurrency is no exception.\n\n\n\n## Models of Parallelism and Concurrency \n\nCPython offers many approaches to Parallelism and Concurrency. Your choice depends on several factors. There are also overlapping use cases across models as CPython has evolved.\n\nYou may find that for a particular problem, there are two or more concurrency implementations to choose from. Each with their own pros and cons.\n\nThe four bundled models with CPython are:\n\n| Approach        | Module            | Concurrent | Parallel |\n| --------------- | ----------------- | ---------- | -------- |\n| Threading       | `threading`       | Yes        | No       |\n| Multiprocessing | `multiprocessing` | Yes        | Yes      |\n| Async           | `asyncio`         | Yes        | No       |\n| Subinterpreters | `subinterpreters` | Yes        | Yes      |\n\n\n\n## The Structure of a Process\n\nOne of the tasks for an Operating System, like Windows, macOS, or Linux, is to control the running processes. These processes could be UI applications like a browser or IDE. They could also be background processes, like network services or OS services.\n\nTo control these processes, the OS provides an API to start a new process. When a process is created, it is registered by the Operating System so that it knows which processes are running. Processes are given a unique ID (PID). Depending on the Operating System, they have other properties.\n\nPOSIX processes have a minimum set of properties, registered in the Operating System:\n\n- Controlling Terminal\n- Current Working Directory\n- Effective Group ID, Effective User ID\n- File Descriptors, File Mode Creation Mask\n- Process Group ID, Process ID\n- Real Group ID, Real User ID\n- Root Directory\n\nYou can see these attributes for running processes in macOS or Linux by running the `ps` command.\n\n> **Note**\n>\n> The [IEEE POSIX Standard (1003.1-2017)](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap01.html) defines the interface and standard behaviors for processes and threads\n\nWindows has a similar list of properties but sets its own standard. The Windows file permissions, directory structures, and process registry are very different from POSIX. Windows processes, represented by [Win32_Process](https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32-process), can be queried in WMI, the Windows Management Interface runtime, or by using the Task Manager.\n\nOnce a process is started on an Operating System, it is given:\n\n- A **Stack** of memory for calling subroutines\n- A **Heap** (see Dynamic Memory Allocation in C)\n- Access to **Files**, **Locks**, and **Sockets** on the Operating System\n\nThe CPU on your computer also keeps additional data when the process is executing, such as :\n\n- **Registers** holding the current instruction being executed or any other data needed by the process for that instruction\n- An **Instruction Pointer**, or **Program Counter** indicating which instruction in the program sequence is being executed\n\nThe CPython process comprises of the compiled CPython interpreter, and the compiled modules. These modules are loaded at runtime and converted into instructions by the CPython Evaluation Loop:\n\n![60](localhost:9000/media/post/python_internals/60.png)\n\nThe program register and program counter point to a **single** instruction in the process. This means that only one instruction can be executing at any one time.\n\nFor CPython, this means that only one Python bytecode instruction can be executing at any one time.\n\nThere are two main approaches to allowing parallel execution of instructions in a process:\n\n- Fork another process \n- Spawn a thread\n\nNow that you have reviewed what makes up a process. Next, you can explore forking and spawning child processes.\n\n\n\n## Multi-Process Parallelism\n\nPOSIX systems provide an API for any process to **fork** a child process. Forking processes is a low-level API call to the Operating System that can be made by any running process. When this call is made, the OS will clone all the attributes of the currently running process and create a new process. This clone operation includes the heap, register, and counter position of the parent process. The child process can read any variables from the parent process at the time of forking.\n\n\n\n#### Forking a Process in POSIX \n\nAs an example, take the Fahrenheit to Celcius example application used at the beginning of Dynamic Memory Allocation in C. Adapt it to spawn a child process for each Fahrenheit value instead of calculating them in sequence. This is accomplished by using the `fork()` function. Each child process will continue operating from that point:\n\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nstatic const double five_ninths = 5.0/9.0;\n\ndouble celsius(double fahrenheit) {\n    return (fahrenheit - 32) * five_ninths;\n}\n\nint main(int argc, char** argv) {\n    if (argc != 2)\n    \treturn -1;\n    int number = atoi(argv[1]);\n    for (int i = 1 ; i <= number ; i++ ) {\n    \tdouble f_value = 100 + (i*10);\n    \tpid_t child = fork();\n    \tif (child == 0) { // Is child process\n    \t\tdouble c_value = celsius(f_value);\n    \t\tprintf(\"%f F is %f C (pid %d)n\", f_value, c_value, getpid());\n    \t\texit(0);\n    \t}\n    }\n    printf(\"Spawned %d processes from %dn\", number, getpid());\n    return 0;\n}\n```\n\nRunning this on the command-line would give an output similar to:\n\n```\n./thread_celcius 4\n110.000000 F is 43.333333 C (pid 57179)\n120.000000 F is 48.888889 C (pid 57180)\nSpawned 4 processes from 57178\n130.000000 F is 54.444444 C (pid 57181)\n140.000000 F is 60.000000 C (pid 57182)\n```\n\nThe parent process (57178), spawned 4 processes. For each child process, it continued at the line `child = fork()`, where the resulting value of `child` is 0. It then completes the calculation, prints the value, and exits the process. Finally, the parent process outputs how many processes it spawned, and it’s own PID. The time taken for the 3rd and 4th child processes to complete was longer than it took for the parent process to complete. This is why the parent process prints the final output before the 3rd and 4th print their own.\n\nA parent process can exit, with its own exit code before a child process. Child Processes will be added to a Process Group by the Operating System, making it easier to control all related processes:\n\n![61](localhost:9000/media/post/python_internals/61.png)\n\nThe biggest downside with this approach to parallelism is that the child process is a complete copy of the parent process. In the case of CPython, this means you would have 2 CPython interpreters running, and both would have to load the modules and all the libraries. It creates significant overhead. Using multiple processes makes sense when the overhead of forking a process is outweighed by the size of the task being completed.\n\nAnother major downside of forked processes is that they have a separate, isolated, heap from the parent process. This means that the child process cannot write to the memory space of the parent process. When creating the child process, the parent’s heap becomes available to the child process. To send information back to the parent, some form of Inter-Process-Communication (IPC) must be used.\n\n> **Note**\n>\n> The os module offers a wrapper around the `fork()` function.\n\n\n\n#### Multi-Processing in Windows\n\nSo far, you’ve been reading the POSIX model. Windows doesn’t provide an equivalent to `fork()`, and Python *should* (as best as possible) have the same API across Linux, macOS, and Windows. \n\nTo overcome this, the [`CreateProcessW() API`](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw) is used to spawn another `python.exe` process with a `-c` command-line argument. \n\nThis step is known as “spawning,” a process and is also available on POSIX. You’ll see references to it throughout this chapter.\n\n\n\n#### The `multiprocessing` Package\n\nCPython provides an API on top of the Operating System process forking API. This API makes it simple to create multi-process parallelism in Python. This API is available from the `multiprocessing` package. This package provides expansive capabilities for pooling processes, queues, forking, creating shared memory heaps, connecting processes together, and more.\n\n\n\n#### Related Source Files\n\nSource files related to multiprocessing are:\n\n| File                         | Purpose                                                      |\n| ---------------------------- | ------------------------------------------------------------ |\n| `Lib/multiprocessing`        | Python Source for the `multiprocessing` package              |\n| `Modules/_posixsubprocess.c` | C extension module wrapping the POSIX `fork()` syscall       |\n| `Modules/_winapi.c`          | C extension module wrapping the Windows Kernel APIs          |\n| `Modules/_multiprocessing`   | C extension module used by the `multiprocessing` package     |\n| `PC/msvcrtmodule.c`          | A Python interface to the Microsoft Visual C Runtime Library |\n\n\n\n#### Spawning and Forking Processes \n\nThe multiprocessing package offers three methods to start a new parallel process.\n\n- Forking an Interpreter (on POSIX only)\n- Spawning a new Interpreter process (on POSIX and Windows)\n- Running a Fork Server, where a new process is created which then forks any number of processes (on POSIX only)\n\n> **Note**\n>\n> For Windows and macOS, the default start method is Spawning. For Linux, the default is Forking. You can override the default method using the `multiprocessing.set_start_method()` function.\n\nThe Python API for starting a new process takes a callable, `target`, and a tuple of arguments, `args`. Take this simple example of spawning a new process to convert Fahrenheit to Celcius:\n\n\n```python\nimport multiprocessing as mp\nimport os\n\ndef to_celcius(f):\n    c = (f - 32) * (5/9)\n    pid = os.getpid()\n    print(f\"{f}F is {c}C (pid {pid})\")\n    \nif __name__ == '__main__':\n    mp.set_start_method('spawn')\n    p = mp.Process(target=to_celcius, args=(110,))\n    p.start()\n```\n\nWhile you can start a single process, the `multiprocessing` API assumes you want to start multiple. There are convenience methods for spawning multiple processes and feeding them sets of data. One of those methods is the `Pool` class. \n\nThe previous example can be expanded to calculate a range of values in separate Python interpreters: \n\n\n```python\nimport multiprocessing as mp\nimport os\n\ndef to_celcius(f):\n    c = (f - 32) * (5/9)\n    pid = os.getpid()\n    print(f\"{f}F is {c}C (pid {pid})\")\n    \nif __name__ == '__main__':\n    mp.set_start_method('spawn')\n    with mp.Pool(4) as pool:\n    \tpool.map(to_celcius, range(110, 150, 10))\n```\n\nNote that the output shows the same PID. Because the CPython interpreter process has a signification overhead, the `Pool` will consider each process in the pool a “worker.” If a worker has completed, it will be reused. If you replace the line:\n\n```python\n    with mp.Pool(4) as pool:\n```\n\nwith:\n\n```python\n    with mp.Pool(4, maxtasksperchild=1) as pool:\n```\n\nThie previous multiprocessing examle will print something similar to:\n\n```\npython pool_process_celcius.py\n110F is 43.333333333333336C (pid 5654)\n120F is 48.88888888888889C (pid 5653)\n130F is 54.44444444444445C (pid 5652)\n140F is 60.0C (pid 5655)\n```\n\nThe output shows the process IDs of the newly spawned processes and the calculated values.\n\n\n\n#### Creation of Child Processes\n\nBoth of these scripts will create a new Python interpreter process and pass data to it using `pickle`.\n\n> **Note**\n>\n> The `pickle` module is a serialization package used for serializing Python objects. Davide Mastromatteo has written a great write up of the [pickle module at realpython.com](https://realpython.com/python-pickle-module/).\n\nFor POSIX systems, the creation of the subprocess by the `multiprocessing` module is equivalent to this command:\n\n```\npython -c 'from multiprocessing.spawn import spawn_main; spawn_main(tracker_fd=<i>, pipe_handle=<j>)' --multiprocessing-fork\n```\n\nWhere  `i` the filehandle descriptor, and  `j` the pipe handle descriptor.\n\nFor Windows systems, the parent PID is used instead of a tracker file descriptor:\n\n```\npython.exe -c 'from multiprocessing.spawn import spawn_main; spawn_main(parent_pid=<k>, pipe_handle=<j>)' --multiprocessing-fork\n```\n\nWhere  `k` the parent PID and  `j` the pipe handle descriptor. \n\n\n\n#### Piping Data to the Child Process \n\nWhen the new child process has been instantiated on the OS, it will wait for initialization data from the parent process. The parent process writes 2 objects to a pipe file stream. The pipe file stream is a special IO stream used to send data between processes on the command line. \n\nThe first object written by the parent process is the **preparation data** object. This object is a dictionary containing some information about the parent, such as the executing directory, the start method, any special command-line arguments, and the `sys.path`. You can see an example of what is generated by running `multiprocessing.spawn.get_preparation_data(name)`:\n\n```python\n>>> import multiprocessing.spawn\n>>> import pprint\n>>> pprint.pprint(multiprocessing.spawn.get_preparation_data(\"example\"))\n{\n    'authkey': b'x90xaa_x22[x18rixbcag]x93xfexf5xe5@[wJx99p#x00'\n    \t\t   b'xcexd4)1j.xc3c',\n\t'dir': '/Users/anthonyshaw',\n\t'log_to_stderr': False,\n\t'name': 'example',\n\t'orig_dir': '/Users/anthonyshaw',\n\t'start_method': 'spawn',\n\t'sys_argv': [''],\n\t'sys_path': ['/Users/anthonyshaw']\n}\n```\n\nThe second object written is the `BaseProcess` child class instance. Depending on how multiprocessing was called and which Operating System is being used, one of the child classes of `BaseProcess` will be the instance serialized. \n\nBoth the preparation data and process object are serialized using the `pickle` module and written to the parent process’ pipe stream:\n\n![62](localhost:9000/media/post/python_internals/62.png)\n\n> **Note**\n>\n> The POSIX implementation of the child process spawning and serialization process is located in `Lib > multiprocessing > popen_spawn_posix.py`. The Windows implementation is located in `Lib > multiprocessing > popen_spawn_win32.py`.\n\n\n\n#### Executing the Child Process\n\nThe entry point of the child process, `multiprocessing.spawn.spawn_main()` takes the argument `pipe_handle` and either `parent_pid` for Windows or `tracked_fd` for POSIX:\n\n```python\ndef spawn_main(pipe_handle, parent_pid=None, tracker_fd=None):\n    '''\n    Run code specified by data received over pipe\n    '''\n    assert is_forking(sys.argv), \"Not forking\"\n```\n\nFor Windows, the function will call the [OpenProcess API](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess) of the parent PID. This process object is used to create a filehandle, `fd`, of the parent process pipe:\n\n```python\n    if sys.platform == 'win32':\n        import msvcrt\n        import _winapi\n        \n        if parent_pid is not None:\n            source_process = _winapi.OpenProcess(\n                _winapi.SYNCHRONIZE | _winapi.PROCESS_DUP_HANDLE,\n                False, parent_pid)\n        else:\n            source_process = None\n        new_handle = reduction.duplicate(pipe_handle,\n                                         source_process=source_process)\n        fd = msvcrt.open_osfhandle(new_handle, os.O_RDONLY)\n        parent_sentinel = source_process\n```\n\nFor POSIX, the `pipe_handle` becomes the file descriptor, `fd`, and is duplicated to become the `parent_sentinel` value:\n\n```python\n    else:\n        from . import resource_tracker\n        resource_tracker._resource_tracker._fd = tracker_fd\n        fd = pipe_handle\n        parent_sentinel = os.dup(pipe_handle)\n```\n\nNext, the `_main()` function is called with the parent pipe file handle, `fd`, and the parent process sentinel, `parent_sentinel`. Whatever the return value of `_main()` is becomes the exit code for the process and the interpreter is terminated:\n\n```python\n    exitcode = _main(fd, parent_sentinel)\n    sys.exit(exitcode)\n```\n\nThe `_main()` function is called with the file descriptor of the parent processes pipe and the parent sentinel for checking if the parent process has exited whilst executing the child. \n\nThe main function deserialises the binary data on the `fd` byte stream. Remember, this is the `pipe` file handle. The deserialization happens using using same `pickle` library that the parent process used:\n\n![63](localhost:9000/media/post/python_internals/63.png)\n\nThe first value is a `dict` containing the preparation data. The second value is an instance of `SpawnProcess` which is then used at the instance to call `_bootstrap()` upon:\n\n```python\ndef _main(fd, parent_sentinel):\n    with os.fdopen(fd, 'rb', closefd=True) as from_parent:\n    \tprocess.current_process()._inheriting = True\n    \ttry:\n            preparation_data = reduction.pickle.load(from_parent)\n            prepare(preparation_data)\n            self = reduction.pickle.load(from_parent)\n        finally:\n            del process.current_process()._inheriting\n\treturn self._bootstrap(parent_sentinel)\n```\n\nThe `_bootstrap()` function handles the instantiation of a `BaseProcess` instance from the deserialized data, and then the target function is called with the arguments and keyword arguments. This final task is completed by `BaseProcess.run()`:\n\n```python\ndef run(self):\n    '''\n    Method to be run in sub-process; can be overridden in sub-class\n    '''\n    if self._target:\n        self._target(*self._args, **self._kwargs)\n```\n\nThe exit code of `self._bootstrap()` is set as the exit code, and the child process is terminated. This process allows the parent process to serialize the module and the executable function. It also allows the child process to deserialize that instance, execute the function with arguments, and return. It does not allow for the exchanging of data once the child process has started. This task is done using the extension of the `Queue` and `Pipe` objects. If processes are being created in a pool, the first process will be ready and in a waiting state. The parent process repeats the process and sends the data to the next worker:\n\n![64](localhost:9000/media/post/python_internals/64.png)\n\nThe next worker receives the data and initializes its state and runs the target function:\n\n![65](localhost:9000/media/post/python_internals/65.png)\n\nTo share any data beyond initialization, queues and pipes must be used.\n\n\n\n#### Exchanging Data with Queues and Pipes\n\nIn the previous section you saw how child processes are spawned, and then the pipe is used as a serialization stream to tell the child process what function to call with arguments. There is two types of communication between processes, depending on the nature of the task.\n\n\n\n#### Semaphores\n\nMany of the mechanisms in multiprocessing use **semaphores** as a way of signaling that resources are locked, being waited on, or not used. Operating Systems use binary semaphores as a simple variable type for locking resources, like files, sockets, and other resources. \n\nIf one process is writing to a file or a network socket, you don’t want another process to suddenly start writing to the same file. The data would become corrupt instantly. Instead, Operating Systems put a “lock” on resources using a semaphore. Processes can also signal that they are waiting for that lock to be released so that when it is, they get a message to say it is ready and they can start using it. \n\nSemaphores (in the real world) are a signaling method using flags, so the states for a resource of waiting, locked and not-used would look like:\n\n![66](localhost:9000/media/post/python_internals/66.png)\n\nThe semaphore API is different between Operating Systems, so there is an abstraction class, `multiprocessing.syncronize.Semaphore`.\n\nSemaphores are used by CPython for multiprocessing because they are both `thread-safe` and `process-safe`. The Operating System handles any potential deadlocks of reading or writing to the same semaphore.\n\nThe implementation of these semaphore API functions is located in a C extension module `Modules/_multiprocessing/semaphore.c`. This extension module offers a single method for creating, locking, releasing semaphores, and other operations.\n\nThe call to the Operating System is through a series of Macros, which are compiled into different implementations depending on the Operating System platform. For Windows, the [`winbase.h` API functions for semaphores](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsemaphorea) are used:\n\n```c\n#define SEM_CREATE(name, val, max) CreateSemaphore(NULL, val, max, NULL)\n#define SEM_CLOSE(sem) (CloseHandle(sem) ? 0 : -1)\n#define SEM_GETVALUE(sem, pval) _GetSemaphoreValue(sem, pval)\n#define SEM_UNLINK(name) 0\n```\n\nFor POSIX, the macros use the  [`semaphore.h` API is used](http://man7.org/linux/man-pages/man3/sem_open.3.html):\n\n```c\n#define SEM_CREATE(name, val, max) sem_open(name, O_CREAT | O_EXCL, 0600, val)\n#define SEM_CLOSE(sem) sem_close(sem)\n#define SEM_GETVALUE(sem, pval) sem_getvalue(sem, pval)\n#define SEM_UNLINK(name) sem_unlink(name)\n```\n\n\n\n#### Queues\n\nQueues are a great way of sending small data to and from multiple processes. \n\nIf you adapt the multiprocessing example before to use a `multiprocessing Manager()` instance, and create two queues:\n\n- `inputs` to hold the input Fahrenheit values\n- `outputs` to hold the resulting Celcius values Change the pool size to 2 so that there are two workers:\n\n\n```python\nimport multiprocessing as mp\n\ndef to_celcius(input: mp.Queue, output: mp.Queue):\n    f = input.get()\n    # time-consuming task ...\n    c = (f - 32) * (5/9)\n    output.put(c)\n    \nif __name__ == '__main__':\n    mp.set_start_method('spawn')\n    pool_manager = mp.Manager()\n    with mp.Pool(2) as pool:\n        inputs = pool_manager.Queue()\n        outputs = pool_manager.Queue()\n        input_values = list(range(110, 150, 10))\n        for i in input_values:\n        \tinputs.put(i)\n        \tpool.apply(to_celcius, (inputs, outputs))\n                                    \n        for f in input_values:\n        \tprint(outputs.get(block=False))\n```\n\nThis would print the list of tuples returned to the `results` queue:\n\n```\npython pool_queue_celcius.py\n43.333333333333336\n48.88888888888889\n54.44444444444445\n60.0\n```\n\nThe parent process first puts the input values onto the input queue. The first worker then takes an item from the queue. Each time an item is taken from the queue using `.get()`, a semaphore lock is used on the queue object:\n\n![67](localhost:9000/media/post/python_internals/67.png)\n\nWhile this worker is busy, the second worker then takes another value from the queue:\n\n![68](localhost:9000/media/post/python_internals/68.png)\n\nThe first worker has completed its calculation and puts the resulting value onto the result queue:\n\n![69](localhost:9000/media/post/python_internals/69.png)\n\nTwo queues are in use to separate the input and output values. Eventually, all input values have been processed, and the output queue is full. The values are then printed by the parent process:\n\n![70](localhost:9000/media/post/python_internals/70.png)\n\nThis example shows how a pool of workers could receive a queue of small, discreet values and process them in parallel to send the resulting data back to the host process. In practice, converting Celcius to Fahrenheit is a small, trivial calculation unsuited for parallel execution. If the worker process were doing another CPU-intensive calculation, this would provide significant performance improvement on a multi-CPU or multi-core computer.\n\nFor streaming data instead of discreet queues, pipes can be used instead.\n\n\n\n#### Pipes\n\nWithin the `multiprocessing` package, there is a type `Pipe`. Instantiating a Pipe returns two connections, a parent and a child. Both can send and receive data:\n\n![71](localhost:9000/media/post/python_internals/71.png)\n\nIn the queue example, a lock is implicitly placed on the queue when data is sent and received. Pipes do not have that behavior, so you have to be careful that two processes do not try and write to the same pipe at the same time.\n\nIf you adapt the last example to work with a pipe, it will require changing the `pool.apply()` to `pool.apply_async()`. This changes the execution of the next process to a non-blocking operation: \n\n\n```python\nimport multiprocessing as mp\n\ndef to_celcius(child_pipe: mp.Pipe, parent_pipe: mp.Pipe):\n    f = parent_pipe.recv()\n    # time-consuming task ...\n    c = (f - 32) * (5/9)\n    child_pipe.send(c)\n    \nif __name__ == '__main__':\n    mp.set_start_method('spawn')\n    pool_manager = mp.Manager()\n    with mp.Pool(2) as pool:\n        parent_pipe, child_pipe = mp.Pipe()\n        results = []\n        for i in range(110, 150, 10):\n        \tparent_pipe.send(i)\n        \tpool.apply_async(to_celcius, args=(child_pipe, parent_pipe))\n        \tprint(child_pipe.recv())\n        parent_pipe.close()\n        child_pipe.close()\n```\n\nIn this example, there is a risk of two or more processes trying to read from the parent pipe at the same time on the line:\n\n```python\nf = parent_pipe.recv()\n```\n\nThere is also a risk of two or more processes trying to write to the child pipe at the same time.\n\n```python\nchild_pipe.send(c)\n```\n\nIf this situation occurs, data would be corrupted in either the receive or send operations:\n\n![72](localhost:9000/media/post/python_internals/72.png)\n\nTo avoid this, you can implement a semaphore lock on the Operating System. Then all child processes will check with the Lock before reading or writing to the same pipe. \n\nThere are two locks required, one on the receiving end of the parent pipe, and another on the sending end of the child pipe: \n\n\n```python\nimport multiprocessing as mp\n\ndef to_celcius(child_pipe: mp.Pipe, parent_pipe: mp.Pipe,\n               child_write_lock: mp.Lock, parent_read_lock: mp.Lock):\n    parent_read_lock.acquire()\n    try:\n    \tf = parent_pipe.recv()\n    finally:\n    \tparent_read_lock.release()\n    # time-consuming task ...\n    c = (f - 32) * (5/9)\n    \n    child_write_lock.acquire()\n    try:\n    \tchild_pipe.send(c)\n    finally:\n        child_write_lock.release()\n        \nif __name__ == '__main__':\n    mp.set_start_method('spawn')\n    pool_manager = mp.Manager()\n    with mp.Pool(2) as pool:\n        parent_pipe, child_pipe = mp.Pipe()\n        parent_read_lock = mp.Lock()\n        child_write_lock = mp.Lock()\n        results = []\n        for i in range(110, 150, 10):\n        \tparent_pipe.send(i)\n        \tpool.apply_async(to_celcius, args=(child_pipe, parent_pipe,\n                                               child_write_lock,\n                                               parent_read_lock))\n        \tprint(child_pipe.recv())\n        parent_pipe.close()\n        child_pipe.close()\n```\n\nNow the worker processes will wait to acquire a lock before receiving data, and wait again to acquire another lock to send data:\n\n![73](localhost:9000/media/post/python_internals/73.png)\n\nThis example would suit situations where the data going over the pipe is large because the chance of a collision is higher.\n\n\n\n#### Shared State Between Processes \n\nSo far, you have seen how data can be shared between the child and the parent process. There may be scenarios where you want to share data between child processes. In this situation, the multiprocessing package provides two solutions:\n\n- A performant Shared Memory API using shared memory maps and shared C types\n- A flexible Server Process API supporting complex types via the Manager class \n\n\n\n#### Example Application\n\nAs a demonstration application, throughout this chapter, you will be refactoring a TCP port scanner for different concurrency and parallelism techniques. \n\nOver a network, a host can be contacted on ports, which are a number from 1-65535. Common services have standard ports. For example, HTTP operates on port 80 and HTTPS on 443. TCP port scanners are used as a common network testing tool to check that packets can be sent over a network. \n\nThis code example uses the Queue interface, a thread-safe queue implementation similar to the one you use in the multiprocessing examples. The code also uses the socket package to try connecting to a remote port with a short timeout of 1 second.\n\nThe `check_port()` function will see if the `host` responds on the given port, and if it does respond, it adds the port number to the `results` queue. \n\nWhen the script is executed, the `check_port()` function is called in sequence for port numbers 80-100. \n\nAfter this has completed, the results queue is emptied out, and the results are printed on the command line.\n\nSo you can compare the difference, it will print the execution time at the end:\n\n\n```python\nfrom queue import Queue\nimport socket\nimport time\ntimeout = 1.0\n\ndef check_port(host: str, port: int, results: Queue):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.settimeout(timeout)\n    result = sock.connect_ex((host, port))\n    if result == 0:\n    \tresults.put(port)\n    sock.close()\n\nif __name__ == '__main__':\n    start = time.time()\n    host = \"localhost\" # replace with a host you own\n    results = Queue()\n    for port in range(80, 100):\n    \tcheck_port(host, port, results)\n    while not results.empty():\n    \tprint(\"Port {0} is open\".format(results.get()))\n    print(\"Completed scan in {0} seconds\".format(time.time() - start))\n```\n\nThe execution will print out the open ports and the time taken:\n\n```\npython portscanner.py\nPort 80 is open\nCompleted scan in 19.623435020446777 seconds\n```\n\nThis example can be refactored to use multiprocessing. The `Queue` interface is swapped for `multiprocessing.Queue` and the ports are scanned together using a pool executor:\n\n\n```python\nimport multiprocessing as mp\nimport time\nimport socket\n\ntimeout = 1\n\ndef check_port(host: str, port: int, results: mp.Queue):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.settimeout(timeout)\n    result = sock.connect_ex((host, port))\n    if result == 0:\n    \tresults.put(port)\n    sock.close()\n\nif __name__ == '__main__':\n    start = time.time()\n    processes = []\n    scan_range = range(80, 100)\n    host = \"localhost\" # replace with a host you own\n    mp.set_start_method('spawn')\n    pool_manager = mp.Manager()\n    with mp.Pool(len(scan_range)) as pool:\n        outputs = pool_manager.Queue()\n        for port in scan_range:\n        \tprocesses.append(pool.apply_async(check_port,\n                                              (host, port, outputs)))\n        for process in processes:\n        \tprocess.get()\n        while not outputs.empty():\n        \tprint(\"Port {0} is open\".format(outputs.get()))\n        print(\"Completed scan in {0} seconds\".format(time.time() - start))\n```\n\nAs you might expect, this application is much faster because it is testing each port in parallel:\n\n```\npython portscanner_mp_queue.py\nPort 80 is open\nCompleted scan in 1.556523084640503 seconds\n```\n\n\n\n#### Conclusion\n\nMultiprocessing offers a scalable, parallel execution API for Python. Data can be shared between processes, and CPU-intensive work can be broken into parallel tasks to take advantage of multiple core or CPU computers. \n\nMultiprocessing is not a suitable solution when the task to be completed is not CPU intensive, but instead IO-bound. For example, if you spawned 4 worker processes to read and write to the same files, one would do all the work, and the other 3 would wait for the lock to be released. \n\nMultiprocessing is also not suitable for short-lived tasks, because of the time and processing overhead of starting a new Python interpreter. \n\nIn both of those scenarios, you main find one of the next approaches is more suited.\n\n\n\n## Multithreading\n\nCPython provides a high-level and a low-level API for creating, spawning, and controlling threads from Python. To understand Python threads, you should first understand how Operating System threads work. There are two implementations of threading in CPython.\n\n- `pthreads` - POSIX threads for Linux and macOS\n- `nt threads` - NT threads for Windows\n\nIn the section on The Structure of a Process, you saw how a process has:\n\n- A **Stack** of subroutines\n- A **Heap** of memory\n- Access to **Files**, **Locks**, and **Sockets** on the Operating System\n\nThe biggest limitation to scaling a single process is that the Operating System will have a single **Program Counter** for that executable. \n\nTo get around this, modern Operating Systems allow processes to signal the Operating System to branch their execution into multiple threads. \n\nEach thread will have its own Program Counter, but use the same resources as the host process. Each thread also has it’s own call stack, so it can be executing a different function. \n\nBecause multiple threads can read and write to the same memory space, collisions could occur. The solution to this is **thread safety** and involves making sure that memory space is locked by a single thread before it is accessed.\n\nA single process with 3 threads would have a structure:\n\n![74](localhost:9000/media/post/python_internals/74.png)\n\n> **Note**\n>\n> For a great introductory tutorial on the Python threading API, check out [Jim Anderson’s “Intro to Python Threading.”](https://realpython.com/intro-to-python-threading/)\n\n\n\n#### The GIL\n\nIf you’re familiar with NT threads or POSIX threads from C, or you’ve used another high-level language, you may expect multithreading to be parallel. \n\nIn CPython, the threads are based on the C APIs, but the threads are Python threads. This means that every Python thread needs to execute Python bytecode through the evaluation loop. \n\nThe Python evaluation loop is not thread-safe. There are many parts of the interpreter state, such as the Garbage Collector, which are shared, and global. \n\nTo get around this, the CPython developers implemented a mega-lock, called the **Global Interpreter Lock (GIL)**. Before any opcode is executed in the frame-evaluation loop, the GIL is acquired by the thread, then once the opcode has been executed, it is released. \n\nAside from providing a global thread-safety to every operation in Python, this approach has a major drawback. Any operations which take a long time to execute will leave other threads waiting for the GIL to be released before they can execute.\n\nThis means that only 1 thread can be executing a Python bytecode operation at any one time.\n\nTo acquire the GIL, a call is made to [`take_gil()`](https://github.com/python/cpython/blob/v3.9.0b1/Python/ceval_gil.h#L215) and then again to [`drop_gil()`](https://github.com/python/cpython/blob/v3.9.0b1/Python/ceval_gil.h#L144) to release it. The GIL acquisition is made within the core frame evaluation loop, `_PyEval_EvalFrameDefault()`.\n\nTo stop a single frame execution from permanently holding the GIL, the evaluation loop state stores a flag, `gil_drop_request`. After every bytecode operation has completed in a frame, this flag is checked, and the GIL is temporarily released and then reacquired:\n\n```c\n...\n    if (_Py_atomic_load_relaxed(&ceval->gil_drop_request)) {\n        /* Give another thread a chance */\n        if (_PyThreadState_Swap(&runtime->gilstate, NULL) != tstate) {\n        \tPy_FatalError(\"ceval: tstate mix-up\");\n        }\n        drop_gil(ceval, tstate);\n        \n        /* Other threads may run now */\n        \n        take_gil(ceval, tstate);\n        /* Check if we should make a quick exit. */\n        \n        exit_thread_if_finalizing(tstate);\n        \n        if (_PyThreadState_Swap(&runtime->gilstate, tstate) != NULL) {\n        \tPy_FatalError(\"ceval: orphan tstate\");\n        }\n    }\n...\n```\n\nDespite the limitations that the GIL enforces on parallel execution, it means that multithreading in Python is very safe and ideal for running IO-bound tasks concurrently.\n\n\n\n#### Related Source Files\n\nSource files related to threading are:\n\n| File                       | Purpose                                              |\n| -------------------------- | ---------------------------------------------------- |\n| `Include/pythread.h`       | PyThread API and definition                          |\n| `Lib/threading.py`         | High Level threading API and Standard Library module |\n| `Modules/_threadmodule.c ` | Low Level thread API and Standard Library module     |\n| `Python/thread.c`          | C extension for the thread module                    |\n| `Python/thread_nt.h `      | Windows Threading API                                |\n| `Python/thread_pthread.h ` | POSIX Threading API                                  |\n| `Python/ceval_gil.h `      | GIL lock implementation                              |\n\n\n\n#### Starting Threads in Python\n\nTo demonstrate the performance gains of having multithreaded code (in spite of the GIL), you can implement a simple network port scanner in Python. \n\nNow clone the previous script but change the logic to spawn a thread for each port using `threading.Thread()`. This is similar to the `multiprocessing` API, where it takes a `callable`, `target`, and a `tuple`, `args`. Start the threads inside the loop, but don’t wait for them to complete. Instead, append the thread instance to a list, `threads`:\n\n```python\nfor port in range(800, 100):\n    t = Thread(target=check_port, args=(host, port, results))\n    t.start()\n    threads.append(t)\n```\n\nOnce all threads have been created, iterate through the thread list and call `.join()` to wait for them to complete:\n\n```python\nfor t in threads:\n    t.join()\n```\n\nNext, exhaust all the items in the results queue and print them to the screen:\n\n```python\nwhile not results.empty():\n    print(\"Port {0} is open\".format(results.get()))\n```\n\nThe whole script is:\n\n\n```python\nfrom threading import Thread\nfrom queue import Queue\nimport socket\nimport time\n\ntimeout = 1.0\n\ndef check_port(host: str, port: int, results: Queue):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.settimeout(timeout)\n    result = sock.connect_ex((host, port))\n    if result == 0:\n        results.put(port)\n    sock.close()\n    \ndef main():\n    start = time.time()\n    host = \"localhost\" # replace with a host you own\n    threads = []\n    results = Queue()\n    for port in range(80, 100):\n    \tt = Thread(target=check_port, args=(host, port, results))\n    \tt.start()\n    \tthreads.append(t)\n    for t in threads:\n    \tt.join()\n    while not results.empty():\n    \tprint(\"Port {0} is open\".format(results.get()))\n    print(\"Completed scan in {0} seconds\".format(time.time() - start))\n    \nif __name__ == '__main__':\n    main()\n```\n\nWhen you call this threaded script at the command-line, it will execute 10+ times faster than the single-threaded example:\n\n```\npython portscanner_threads.py\nPort 80 is open\nCompleted scan in 1.0101029872894287 seconds\n```\n\nThis also runs 50-60% faster than the multiprocessing example. Remember that multiprocessing has an overhead for starting the new processes, threading does have an overhead, but it is much smaller.\n\nYou may be wondering- if the GIL means that only a single operation can execute at once, why is this faster?\n\nThe statement that takes 1-1000ms is:\n\n```python\nresult = sock.connect_ex((host, port))\n```\n\nIn the C extension module, `Modules/socketmodule.c`, the function that implements the connection is: \n\n`Modules/socketmodule.c` line 3246\n\n```c\nstatic int\ninternal_connect(PySocketSockObject *s, struct sockaddr *addr, int addrlen, int raise)\n{\n    int res, err, wait_connect;\n    \n    Py_BEGIN_ALLOW_THREADS\n    res = connect(s->sock_fd, addr, addrlen);\n    Py_END_ALLOW_THREADS\n```\n\nSurrounding the system `connect()` call are the `Py_BEGIN_ALLOW_THREADS` and `Py_END_ALLOW_THREADS` macros.\n\nThese macros are defined in `Include/ceval.h` as:\n\n```c\n#define Py_BEGIN_ALLOW_THREADS {\n    PyThreadState *_save;\n    _save = PyEval_SaveThread();\n#define Py_BLOCK_THREADS PyEval_RestoreThread(_save);\n#define Py_UNBLOCK_THREADS _save = PyEval_SaveThread();\n#define Py_END_ALLOW_THREADS PyEval_RestoreThread(_save);\n}\n```\n\nSo, when `Py_BEGIN_ALLOW_THREADS` is called, it calls [`PyEval_SaveThread()`](https://github.com/python/cpython/blob/v3.9.0b1/Python/ceval.c#L480). This function changes the thread state to NULL and **drops** the GIL:\n\n`Python/ceval.c` line 480\n\n```c\nPyThreadState *PyEval_SaveThread(void)\n{\n    PyThreadState *tstate = PyThreadState_Swap(NULL);\n    if (tstate == NULL)\n    \tPy_FatalError(\"PyEval_SaveThread: NULL tstate\");\n    assert(gil_created());\n    drop_gil(tstate);\n    return tstate;\n}\n```\n\nBecause the GIL is dropped, it means any other executing thread can continue. This thread will sit and wait for the system call without blocking the evaluation loop. \n\nOnce the `connect()` function has succeeded or timed out, the `Py_END_ALLOW_THREADS` runs the [PyEval_RestoreThread()](https://github.com/python/cpython/blob/v3.9.0b1/Python/ceval.c#L503) function with the original thread state.\n\nThe thread state is recovered and the GIL is retaken. The call to `take_gil()` is a blocking call, waiting on a semaphore: \n\n`Python/ceval.c` line 503\n\n```c\nvoid\nPyEval_RestoreThread(PyThreadState *tstate)\n{\n    if (tstate == NULL)\n    \tPy_FatalError(\"PyEval_RestoreThread: NULL tstate\");\n    assert(gil_created());\n    \n    int err = errno;\n    take_gil(tstate);\n    /* _Py_Finalizing is protected by the GIL */\n    if (_Py_IsFinalizing() && !_Py_CURRENTLY_FINALIZING(tstate)) {\n        drop_gil(tstate);\n        PyThread_exit_thread();\n            Py_UNREACHABLE();\n    }\n    errno = err;\n    \n    PyThreadState_Swap(tstate);\n}\n```\n\nThis is not the only system call wrapped by the non-GIL-blocking pair `Py_BEGIN_ALLOW_THREADS` and `Py_END_ALLOW_THREADS`. There are over 300 uses of it in the Standard Library. Including:\n\n- Making HTTP requests\n- Interacting with local hardware\n- Encryption\n- Reading and writing files\n\n\n\n#### Thread State\n\nCPython provides its own implementation of thread management. Because threads need to execute Python bytecode in the evaluation loop, running a thread in CPython isn’t as simple as spawning an OS thread. Python threads are called PyThread, and you covered them briefly on the CPython Evaluation Loop chapter. \n\nPython threads execute code objects and are spawned by the interpreter. \n\nTo recap:\n\n- CPython has a single runtime, which has its own **runtime state**\n- CPython can have one or many interpreters\n- An interpreter has a state, called the **interpreter state**\n- An interpreter will take a **code object** and convert it into a series of **frame objects**\n- An interpreter has at least one **thread**, each thread has a **thread state**\n- Frame Objects are executed in a stack, called the **frame stack**\n- CPython references variables in a **value stack**\n- The **interpreter state** includes a linked-list of its threads\n\nA single-threaded, single-interpreter runtime would have the states:\n\n![75](localhost:9000/media/post/python_internals/75.png)\n\nThe thread state type, `PyThreadState` has over 30 properties, including:\n\n- A unique identifier\n- A linked-list to the other thread states\n- The interpreter state it was spawned by\n- The currently executing frame\n- The current recursion depth\n- Optional tracing functions\n- The exception currently being handled\n- Any async exception currently being handled\n- A stack of exceptions raised\n- A GIL counter\n- Async generator counters\n\nSimilar to the multiprocessing **preparation data**, threads have a boot state. However, threads share the same memory space, so there is no need to serialize data and send it over a file stream. \n\nThreads are instantiated with the `threading.Thread` type. This is a highlevel module that abstracts the `PyThread` type. `PyThread` instances are managed by the C extension module `_thread`. \n\nThe `_thread` module has the entry point for executing a new thread, [`thread_PyThread_start_new_thread()`](https://github.com/python/cpython/blob/v3.9.0b1/Modules/_threadmodule.c#L1063). `start_new_thread()` is a method on an instance of the type `Thread`. \n\nNew threads are instantiated in this sequence:\n\n- The `bootstate` is created, linking to the `target`, with arguments `args` and `kwargs`\n- The `bootstate` is linked to the interpreter state\n- A new `PyThreadState` is created, linking to the current interpreter\n- The GIL is enabled, if not already with a call to [`PyEval_InitThreads()`](https://github.com/python/cpython/blob/v3.9.0b1/Python/ceval.c#L338)\n- The new thread is started on the Operating System-specific implementation of `PyThread_start_new_thread`\n\n![76](localhost:9000/media/post/python_internals/76.png)\n\nThread `bootstate` has the properties:\n\n| Field    | Type                  | Purpose                                                   |\n| -------- | --------------------- | --------------------------------------------------------- |\n| `interp` | `PyInterpreterState*` | Link to the interpreter managing this thread              |\n| `func`   | `PyObject *`          | Link to the `callable` to execute upon running the thread |\n| `args`   | `PyObject *(tuple)`   | Arguments to call `func` with                             |\n| `key`    | `PyObject * (dict)`   | Keyword arguments to call `func` with                     |\n| `tstate` | `PyThreadState *`     | Thread state for the new thread                           |\n\nWith the thread bootstate, there are two implementations `PyThread` - POSIX threads for Linux and macOS, and NT threads for Windows. \n\nBoth of these implementations create the Operating System thread, set it’s attribute and then execute the callback [`t_bootstrap()`](https://github.com/python/cpython/blob/v3.9.0b1/Modules/_threadmodule.c#L1029) from within the new thread. This function is called with the single argument boot_raw, assigned to the bootstate constructed in [`thread_PyThread_start_new_thread()`](https://github.com/python/cpython/blob/v3.9.0b1/Modules/_threadmodule.c#L1063).\n\nThe [`t_bootstrap()`](https://github.com/python/cpython/blob/v3.9.0b1/Modules/_threadmodule.c#L1029) function is the interface between a low-level thread and the Python runtime. The bootstrap will initiatilize the thread, then execute the `target` callable using [`PyObject_Call()`](https://github.com/python/cpython/blob/v3.9.0b1/Objects/call.c#L289). Once the callable target has been executed, the thread will exit:\n\n![77](localhost:9000/media/post/python_internals/77.png)\n\n\n\n#### POSIX Threads\n\nPOSIX threads, named pthreads, have an implementation in `Python/thread_pthread.h`. This implementation abstracts the `pthread.h`  C API with some additional safeguards and optimizations.\n\nThreads can have a configured stack size. Python has it’s own stack frame construct, as you explored in the chapter on the Evaluation Loop. If there is an issue causing a recursive loop, and the frame execution hits the depth limit, Python will raise a `RecursionError` which can be handled from a `try..except` block in Python code. Because pthreads have their own stack size, the max depth of Python and the stack size of the pthread might conflict.\n\nIf the thread stack size is smaller than the max frame depth in Python, the entire Python process will crash before a `RecursionError` is raised. Also, the max depth in Python can be configured at runtime using [`sys.setrecursionlimit()`](https://docs.python.org/3/library/sys.html#sys.setrecursionlimit).\n\nTo avoid these crashes, the CPython pthread implementation sets the stack size to the `pythread_stacksize` value of the Interpreter State\n\nMost modern POSIX-compliant Operating Systems support system scheduling of pthreads. If `PTHREAD_SYSTEM_SCHED_SUPPORTED` is defined in `pyconfig.h`, the pthread is set to `PTHREAD_SCOPE_SYSTEM`, meaning that the priority of the thread on the Operating System scheduler is decided against the other threads on the system, not just the ones within the Python process. \n\nOnce the thread properties have been configured, the thread is created using the `pthread_create()` API. This runs the bootstrap function from inside the new thread.\n\nLastly, the thread handle, `pthread_t` is cast into an `unsigned long` and returned to become the thread ID.\n\n\n\n#### Windows Threads\n\nWindows threads implemented in `Python/thread_nt.h` follow a similar, but simpler pattern. The stack size of the new thread is configured to the interpreter `pythread_stacksize` value (if set). The thread is created using the [`_beginthreadex()` Windows API](https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/beginthread-beginthreadex?view=vs-2019) using the bootstrap function as the callback. \n\nLastly, the thread ID is returned.\n\n\n\n#### Conclusion\n\nThis was not an exhaustive tutorial on Python threads. Python’s thread implementation is extensive and offers many mechanisms for sharing data between threads, locking objects, and resources.\n\nThreads are a great, efficient way of improving the runtime of your Python applications when they are IO-bound. In this section, you have seen what the GIL is, why it exists and which parts of the standard library may be exempt from its constraints.\n\n\n\n## Asynchronous Programming \n\nPython offers many ways of accomplishing concurrent programming without using threads or multiprocessing. These features have been added, expanded, and often replaced with better alternatives.\n\nFor the target version of this book, 3.9.0b1, the following asynchronous systems are deprecated:\n\n- The `@coroutine` decorator\n\nThe following systems are still available:\n\n- Creating futures from `async` keywords\n- Coroutines using the `yield from` keywords\n\n\n\n## Generators\n\nPython Generators are functions that return a yield statement and can be called continually to generate further values.\n\nGenerators are often used as a more memory efficient way of looping through values in a large block of data, like a file, a database, or over a network. Generator objects are returned in place of a **value** when `yield` is used instead of `return`. The generator object is created from the `yield` statement and returned to the caller.\n\nThis simple generator function will yield the letters a-z:\n\n\n```python\ndef letters():\n    i = 97 # letter 'a' in ASCII\n    end = 97 + 26 # letter 'z' in ASCII\n    while i < end:\n        yield chr(i)\n        i += 1\n```\n\nIf you call `letters()`, it won’t return a value, but instead it returns a generator object:\n\n```python\n>>> from letter_generator import letters\n>>> letters()\n<generator object letters at 0x1004d39b0>\n```\n\nBuilt into the syntax of the `for` statement is the ability to iterate through a generator object until it stops yielding values:\n\n```python\n>>> for letter in letters():\n... \tprint(letter)\na\nb\nc\nd\n...\n```\n\nThis implementation uses the iterator protocol. Objects that have a `__next__() `method can be looped over by `for` and `while` loops, or using the `next()` builtin. \n\nAll container types (like lists, sets, tuples) in Python implement the iterator protocol. Generators are unique because the implementation of the `__next__()` method recalls the generator function from its last state. Generators are not executing in the background, they are paused. When you request another value, they resume execution. \n\nWithin the generator object structure is the frame object as it was at the last `yield` statement.\n\n\n\n#### Generator Structure\n\nGenerator objects are created by a template macro, `PyGenObject_HEAD`(prefix). \n\nThis macro is used by the following types and prefixes:\n\n- `PyGenObject` - `gi_` (Generator objects)\n- `PyCoroObject` - `cr_` (Coroutine objects)\n- `PyAsyncGenObject` - `ag_` (Async generator objects)\n\nYou will cover coroutine and async generator objects later in this chapter. \n\nThe `PyGenObject` type has the base properties:\n\n| Field             | Type                           | Purpose                                                      |\n| ----------------- | ------------------------------ | ------------------------------------------------------------ |\n| `[x]_frame`       | `PyFrameObject*`               | Current frame object for the generator                       |\n| `[x]_running`     | `char`                         | char Set to 0 or 1 if the generator is currently runing      |\n| `[x]_code`        | `PyObject *` `(PyCodeObject*)` | Compiled function that yielded the generator                 |\n| `[x]_weakreflist` | `PyObject *(list)`             | List of weak references to objects inside the generator function |\n| `[x]_name`        | `PyObject * (str)`             | Name of the generator                                        |\n| `[x]_qualname`    | `PyObject * (str)`             | Qualified name of the generator                              |\n| `[x]_exc_state`   | `_PyErr_StackItem`             | Exception data if the generator call raises an exception     |\n\nOn top of the base properties, the `PyCoroObject` type has:\n\n| Field       | Type                 | Purpose                                           |\n| ----------- | -------------------- | ------------------------------------------------- |\n| `cr_origin` | `PyObject * (tuple)` | Tuple containing the originating frame and caller |\n\nOn top of the base properties, the `PyAsyncGenObject` type has:\n\n| Field              | Type         | Purpose                                           |\n| ------------------ | ------------ | ------------------------------------------------- |\n| `ag_finalizer`     | `PyObject *` | Link to the finalizer method                      |\n| `ag_hooks_inited`  | `int`        | Flag to mark that the hooks have been initialized |\n| `ag_closed`        | `int`        | Flag to mark that the generator is closed         |\n| `ag_running_async` | `int`        | Flag to mark that the generator is running        |\n\n\n\n#### Related Source File\n\nSource files related to generators are:\n\n| File                  | Purpose                                    |\n| --------------------- | ------------------------------------------ |\n| `Include/genobject.h` | Generator API and `PyGenObject` definition |\n| `Objects/genobject.c` | Generator Object implementation            |\n\n\n\n#### Creating Generators\n\nWhen a function containing a `yield` statement is compiled, the resulting code object has an additional flag, `CO_GENERATOR`.\n\nIn the chapter on the Execution Loop: Constructing Frames, you explored how a compiled code object is converted into a frame object when it is executed. In the process, there is a special case for generators, coroutines, and async generators. The [`_PyEval_EvalCode()`](https://github.com/python/cpython/blob/v3.9.0b1/Python/ceval.c#L4101) function checks the code object for the `CO_GENERATOR`, `CO_COROUTINE`, and `CO_ASYNC_GENERATOR` flags. \n\nInstead of evaluation a code object inline, the frame is created and turned into a Generator, Coroutine or Async Generator Object. A coroutine is created using [`PyCoro_New()`](https://github.com/python/cpython/blob/v3.9.0b1/Objects/genobject.c#L1135), an async generator is created with [`PyAsyncGen_New()`](https://github.com/python/cpython/blob/v3.9.0b1/Objects/genobject.c#L1414), and a generator with [`PyGen_NewWithQualName()`](https://github.com/python/cpython/blob/v3.9.0b1/Objects/genobject.c#L810):\n\n```c\nPyObject *\n_PyEval_EvalCode(PyObject *_co, PyObject *globals, PyObject *locals, ...\n...\n    /* Handle generator/coroutine/asynchronous generator */\n    if (co->co_flags & (CO_GENERATOR | CO_COROUTINE | CO_ASYNC_GENERATOR)) {\n        PyObject *gen;\n        PyObject *coro_wrapper = tstate->coroutine_wrapper;\n        int is_coro = co->co_flags & CO_COROUTINE;\n        ...\n        /* Create a new generator that owns the ready to run frame\n        * and return that as the value. */\n        if (is_coro) {\n>>> \t\tgen = PyCoro_New(f, name, qualname);\n        } else if (co->co_flags & CO_ASYNC_GENERATOR) {\n>>> \t\tgen = PyAsyncGen_New(f, name, qualname);\n        } else {\n>>> \t\tgen = PyGen_NewWithQualName(f, name, qualname);\n        }\n        ...\n        return gen;\n    }\n...\n```\n\nThe generator factory, [`PyGen_NewWithQualName()`](https://github.com/python/cpython/blob/v3.9.0b1/Objects/genobject.c#L810), takes the frame and completes some steps to populate the generator object fields:\n\n- Sets the gi_code property to the compiled code object\n- Sets the generator to not running (`gi_running = 0`)\n- Sets the exception and weakref lists to `NULL`\n\nYou can also see that `gi_code` is the compiled code object for the generator function by importing the `dis` module and disassembling the bytecode inside:\n\n```python\n>>> from letter_generator import letters\n>>> gen = letters()\n>>> import dis\n>>> dis.disco(gen.gi_code)\n2 \t\t\t0 LOAD_CONST \t\t1 (97)\n\t\t\t2 STORE_FAST \t\t0 (i)\n...\n```\n\nIn the chapter on the Evaluation Loop, you explored the Frame Object Type. Frame objects contain locals and globals, the last executed instructions, and the code to be executed. \n\nThe builtin behavior and state of the frame object are how generators can *pause* and be *resumed* on demand.\n\n\n\n#### Executing Generators\n\nWhenever `__next__()` is called on a generator object, [`gen_iternext()`](https://github.com/python/cpython/blob/v3.9.0b1/Objects/genobject.c#L540) is called with the generator instance, which immediately calls [`gen_send_ex()`](https://github.com/python/cpython/blob/v3.9.0b1/Objects/genobject.c#L140) inside `Objects/genobject.c`.\n\n[`gen_send_ex()`](https://github.com/python/cpython/blob/v3.9.0b1/Objects/genobject.c#L140) is the function that converts a generator object into the next yielded result. You’ll see many similarities with the way frames are constructed from a code object as these functions have similar tasks.\n\nThe [`gen_send_ex()`](https://github.com/python/cpython/blob/v3.9.0b1/Objects/genobject.c#L140) function is shared with generators, coroutines, and async generators and has the following steps:\n\n- The current thread state is fetched\n- The frame object from the generator object is fetched\n- If the generator is running when `__next__()` was called, raise a `ValueError`\n- If the frame inside the generator is at the top of the stack:\n   - In the case of a coroutine, if the coroutine is not already marked as closing, a `RuntimeError` is raised\n   - If this is an async generator, raise a `StopAsyncIteration`\n   - For a standard generator, a `StopIteration` is raised.\n- If the last instruction in the frame (`f->f_lasti`) is still -1 because it has just been started, and this is a coroutine or async generator, then a non-None value can’t be passed as an argument, so an exception is raised\n- Else, this is the first time it’s being called, and arguments are allowed. The value of the argument is pushed to the frame’s value stack\n- The `f_back` field of the frame is the caller to which return values are sent, so this is set to the current frame in the thread. This means that the return value is sent to the caller, not the creator of the generator\n- The generator is marked as running\n- The last exception in the generator’s exception info is copied from the last exception in the thread state\n- The thread state exception info is set to the address of the generator’s exception info. This means that if the caller enters a breakpoint around the execution of a generator, the stack trace goes through the generator and the offending code is clear\n- The frame inside the generator is executed within the `Python/ceval.c` main execution loop, and the value returned\n- The thread state last exception is reset to the value before the frame was called\n- The generator is marked as not running\n- The following cases then match the return value and any exceptions thrown by the call to the generator. Remember that generators should raise a `StopIteration` when they are exhausted, either manually, or by not yielding a value. Coroutines and async generators should not:\n    - If no result was returned from the frame, raise a `StopIteration` for generators and `StopAsyncIteration` for async generators\n    - If a `StopIteration` was explicitly raised, but this is a coroutine or an async generator, raise a `RuntimeError` as this is not allowed\n    - If a `StopAsyncIteration` was explicitly raised and this is an async generator, raise a `RuntimeError`, as this is not allowed\n- Lastly, the result is returned back to the caller of `__next__()`\n\nBringing this all together, you can see how the generator expression is a powerful syntax where a single keyword, `yield` triggers a whole flow to create a unique object, copy a compiled code object as a property, set a frame, and store a list of variables in the local scope.\n\n\n\n## Coroutines\n\nGenerators have a big limitation. They can only yield values to their immediate caller. An additional syntax was added to Python to overcome this the `yield from` statement. Using this syntax, you can refactor generators into utility functions and then `yield from` them.\n\nFor example, the letter generator can be refactored into a utility function where the starting letter is an argument. Using `yield from`, you can choose which generator object to return: \n\n\n```python\ndef gen_letters(start, x):\n    i = start\n    end = start + x\n    while i < end:\n        yield chr(i)\n        i += 1\n\ndef letters(upper):\n    if upper:\n    \tyield from gen_letters(65, 26) # A-Z\n    else:\n    \tyield from gen_letters(97, 26) # a-z\n\nfor letter in letters(False):\n    # Lower case a-z\n    print(letter)\n\nfor letter in letters(True):\n    # Upper case A-Z\n    print(letter)\n```\n\nGenerators are also great for lazy sequences, where they can be called multiple times. Building on the behaviors of generators, such as being able to pause and resume execution, the concept of a coroutine was iterated in Python over multiple APIs. Generators are a limited form of coroutine because you can send data to them using the `.send()` method. \n\nIt is possible to send messages bi-directionally between the caller and the target. Coroutines also store the caller in the `cr_origin` attribute.\n\nCoroutines were initially available via a decorator, but this has since been deprecated in favor of “native” coroutines using the keywords `async` and `await`. \n\nTo mark that a function returns a coroutine, it must be preceded with the `async` keyword. The async keyword makes it explicit (unlike generators) that this function returns a coroutine and not a value. \n\nTo create a coroutine, define a function with the keyword `async def`. In this example, add a timer using the `asyncio.sleep()` function and return a wake-up string:\n\n```python\n>>> import asyncio\n>>> async def sleepy_alarm(time):\n... \tawait asyncio.sleep(time)\n... \treturn \"wake up!\"\n>>> alarm = sleepy_alarm(10)\n>>> alarm\n<coroutine object sleepy_alarm at 0x1041de340>\n```\n\nWhen you call the function, it returns a coroutine object. There are many ways to execute a coroutine. The easiest is using `asyncio.run(coro)`.\n\nRun `asyncio.run()` with your coroutine object, then after 10 seconds it will sound the alarm:\n\n```python\n>>> asyncio.run(alarm)\n'wake up'\n```\n\nSo far, there is a small benefit over a regular function. The benefit of coroutines is that you can run them concurrently. Because the coroutine object is a variable that you can pass to a function, these objects can be linked together and chained, or created in a sequence. \n\nFor example, if you wanted to have 10 alarms with different intervals and start them all at the same time, these coroutine objects can be converted into tasks.\n\nThe task API is used to schedule and execute multiple coroutines concurrently. Before tasks are scheduled, an event loop must be running. The job of the event loop is to schedule concurrent tasks and connect events such as completion, cancellation, and exceptions with callbacks. When you called `asyncio.run()`, the run function (in `Lib/asyncio/runners.py`) did these tasks for you:\n\n- Started a new event loop\n- Wrapped the coroutine object in a task\n- Set a callback on the completion of the task\n- Looped over the task until it completed\n- Returned the result\n\n\n\n#### Related Source Files\n\nSource files related to coroutines are:\n\n| File          | Purpose                                            |\n| ------------- | -------------------------------------------------- |\n| `Lib/asyncio` | Python standard library implementation for asyncio |\n\n\n\n#### Event Loops\n\nEvent loops are the glue that holds async code together. Written in pure Python, event loops are an object containing tasks. When started, a loop can either run once or run forever. Any of the tasks in the loop can have callbacks. The loop will run the callbacks if a task completes or fails.\n\n```python\nloop = asyncio.new_event_loop()\n```\n\nInside a loop is a sequence of tasks, represented by the type `asyncio.Task`, tasks are scheduled onto a loop, then once the loop is running, it loops over all the tasks until they complete. \n\nYou can convert the single timer into a task loop: \n\n\n```python\nimport asyncio\n\nasync def sleepy_alarm(person, time):\n    await asyncio.sleep(time)\n    print(f\"{person} -- wake up!\")\n    \nasync def wake_up_gang():\n    tasks = [\n        asyncio.create_task(sleepy_alarm(\"Bob\", 3), name=\"wake up Bob\"),\n        asyncio.create_task(sleepy_alarm(\"Sanjeet\", 4), name=\"wake up Sanjeet\"),\n        asyncio.create_task(sleepy_alarm(\"Doris\", 2), name=\"wake up Doris\"),\n        asyncio.create_task(sleepy_alarm(\"Kim\", 5), name=\"wake up Kim\")\n    ]\n    await asyncio.gather(*tasks)\n    \nasyncio.run(wake_up_gang())\n```\n\n#### This will print:\n\n```\nDoris -- wake up!\nBob -- wake up!\nSanjeet -- wake up!\nKim -- wake up!\n```\n\nIn the event loop, it will run over each of the coroutines to see if they are completed. Similar to how the `yield` keyword can return multiple values from the same frame, the `await` keyword can return multiple states. The event loop will execute the `sleepy_alarm()` coroutine objects again and again until the `await asyncio.sleep()` yields a completed result, and the `print()` function is able to execute.\n\nFor this to work, `asyncio.sleep()` must be used instead of the blocking (and not async-aware) `time.sleep()`.\n\n\n\n#### Example\n\nYou can convert the multithreaded port scanner example to asyncio with these steps:\n\n- Change the `check_port()` function to use a socket connection from `asyncio.open_connection()`, which creates a future instead of an immediate connection\n- Use the socket connection future in a timer event, with `asyncio.wait_for()`\n- Append the port to the results list if succeeded\n- Add a new function, `scan()` to create the `check_port()` coroutines for each port and add them to a list, `tasks`\n- Merge all the tasks into a new coroutine using `asyncio.gather()`\n- Run the scan using `asyncio.run()`\n\n\n```python\nimport time\nimport asyncio\n\ntimeout = 1.0\n\nasync def check_port(host: str, port: int, results: list):\n    try:\n    \tfuture = asyncio.open_connection(host=host, port=port)\n    \tr, w = await asyncio.wait_for(future, timeout=timeout)\n    \tresults.append(port)\n    \tw.close()\n    except asyncio.TimeoutError:\n    \tpass # port is closed, skip-and-continue\n\nasync def scan(start, end, host):\n    tasks = []\n    results = []\n    for port in range(start, end):\n    \ttasks.append(check_port(host, port, results))\n    await asyncio.gather(*tasks)\n    return results\n\nif __name__ == '__main__':\n    start = time.time()\n    host = \"localhost\" # pick a host you own\n    results = asyncio.run(scan(80, 100, host))\n    for result in results:\n    \tprint(\"Port {0} is open\".format(result))\n    print(\"Completed scan in {0} seconds\".format(time.time() - start))\n```\n\nFinally, this scan completes in just over 1 second:\n\n```\npython portscanner_async.py\nPort 80 is open\nCompleted scan in 1.0058400630950928 seconds\n```\n\n\n\n## Asynchronous Generators\n\nThe concepts you have learned so far, generators and coroutines can be combined into a type - **asynchronous generators**. If a function is declared with both the async keyword and it contains a yield statement, it is converted into an async generator object when called. Like generators, async generators must be executed by something that understands the protocol. In place of `__next__()`, async generators have a method `__anext__()`. A regular `for` loop would not understand an async generator, so instead, the `async for` statement is used.\n\nYou can refactor the `check_port()` function into an async generator that yields the next open port until it hits the last port, or it has found a specified number of open ports:\n\n```python\nasync def check_ports(host: str, start: int, end: int, max=10):\n    found = 0\n    for port in range(start, end):\n        try:\n            future = asyncio.open_connection(host=host, port=port)\n            r, w = await asyncio.wait_for(future, timeout=timeout)\n            yield port\n            found += 1\n            w.close()\n            if found >= max:\n            \treturn\n        except asyncio.TimeoutError:\n        \tpass # closed\n```\n\nTo execute this, use the `async for` statement:\n\n```python\nasync def scan(start, end, host):\n    results = []\n    async for port in check_ports(host, start, end, max=1):\n    \tresults.append(port)\n    return results\n```\n\n\n\n\n## Subinterpreters\n\nSo far, you have covered:\n\n- Parallel execution with multiprocessing\n- Concurrent execution with threads and async\n\nThe downside of multiprocessing is that the inter-process communication using pipes and queues is slower than shared memory. Also the overhead to start a new process is significant.\n\nThreading and async have small overhead but don’t offer truly parallel execution because of the thread-safety guarantees in the GIL. The fourth option is `subinterpreters`, which have a smaller overhead than `multiprocessing`, and allow a GIL per subinterpreter. After all, it is the Global **Interpreter** Lock. Within the CPython runtime, there is always 1 interpreter. The interpreter holds the interpreter state, and within an interpreter, you can have 1 or many Python threads. The interpreter is the container for the evaluation loop. the interpreter also manages its own memory, reference counter, and garbage collection. CPython has low-level C APIs for creating interpreters, like the [`Py_NewInterpreter()`](https://github.com/python/cpython/blob/v3.9.0b1/Python/pylifecycle.c#L1626).\n\n![78](localhost:9000/media/post/python_internals/78.png)\n\n> **Note**\n>\n> The subinterpreters module is still experimental in 3.9.0b1, so the API is subject to change and the implementation is still buggy.\n\nBecause Interpreter state contains the memory allocation arena, a collection of all pointers to Python objects (local and global), subinterpreters cannot access the global variables of other interpreters. Similar to multiprocessing, to share objects between interpreters you must serialize them, or use ctypes, and use a form of IPC (network, disk or shared memory).\n\n\n\n#### Related Source Files\n\nSource files related to subinterpreters are:\n\n| File                        | Purpose                                            |\n| --------------------------- | -------------------------------------------------- |\n| `Lib/_xxsubinterpreters.c ` | C implementation of the `subinterpreters` module   |\n| `Python/pylifecycle.c`      | C implementation of the interpreter management API |\n\n\n\n#### Example\n\nIn the final example application, the actual connection code has to be captured in a string. In 3.9.0b1, subinterpreters can only be executed with a string of code. \n\nTo start each of the subinterpreters, a list of threads is started, with a callback to a function, `run()`.\n\nThis function will:\n\n- Create a communication channel\n- Start a new subinterpreter\n- Send it the code to execute\n- Receive data over the communication channel\n- If the port connection succeeded, add it to the thread-safe queue\n\n\n```python\nimport time\nimport _xxsubinterpreters as subinterpreters\nfrom threading import Thread\nimport textwrap as tw\nfrom queue import Queue\n\ntimeout = 1 # in seconds..\n\ndef run(host: str, port: int, results: Queue):\n    # Create a communication channel\n    channel_id = subinterpreters.channel_create()\n    interpid = subinterpreters.create()\n    subinterpreters.run_string(\n        interpid,\n        tw.dedent(\n            \"\"\"\n            import socket; import _xxsubinterpreters as subinterpreters\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock.settimeout(timeout)\n            result = sock.connect_ex((host, port))\n            subinterpreters.channel_send(channel_id, result)\n            sock.close()\n            \"\"\"),\n        shared=dict(\n            channel_id=channel_id,\n            host=host,\n            port=port,\n            timeout=timeout\n        ))\n    output = subinterpreters.channel_recv(channel_id)\n    subinterpreters.channel_release(channel_id)\n    if output == 0:\n    \tresults.put(port)\n\nif __name__ == '__main__':\n    start = time.time()\n    host = \"127.0.0.1\" # pick a host you own\n    threads = []\n    results = Queue()\n    for port in range(80, 100):\n    \tt = Thread(target=run, args=(host, port, results))\n        t.start()\n\t\tthreads.append(t)\n    for t in threads:\n\t\tt.join()\n    while not results.empty():\n    \tprint(\"Port {0} is open\".format(results.get()))\n    print(\"Completed scan in {0} seconds\".format(time.time() - start))\n```\n\nBecause of the reduced overheads compared with multiprocessing, this example should execute 30-40% faster and with fewer memory resources:\n\n```\npython portscanner_subinterpreters.py\nPort 80 is open\nCompleted scan in 1.3474230766296387 seconds\n```\n\n\n\n#### Conclusion\n\nCongratulations on getting through the biggest chapter in the book! You’ve covered a lot of ground. Let us recap some of the concepts and their applications. \n\nFor truly **parallel execution**, you need multiple CPUs or cores. You also need to use either **multiprocessing** or **subinterpreters** packages so that the Python interpreter can be executed in parallel. Remember that startup time is significant, and each interpreter has a big memory overhead. If the tasks that you want to execute are shortlived, use a pool of workers and a queue of tasks. \n\nIf you have multiple IO-bound tasks and want them to run **concurrently**, you should use multithreading, or use coroutines with the **asyncio** package. \n\nAll four of these approaches require an understanding of how to safely and efficiently transfer data between processes or threads. The best way to reinforce what you’ve learned is to look at an application you’ve written and seen how it can be refactored to leverage these techniques.", "body": "<h1 id=parallelism-and-concurrency>Parallelism and Concurrency</h1>\n<p style=\"font-size: 16px;\">The first computers were designed to do one thing at a time. A lot of their work was in the field of computational mathematics. As time went on, computers are needed to process inputs from a variety of sources. Some input as far away as distant galaxies. The consequence of this is that computer applications spend a lot of time idly waiting for responses.</p>\n<p style=\"font-size: 16px;\">Whether they be from a bus, an input, memory, computation, an API, or a remote resource. Another progression in computing was the move in Operating Systems away from a single-user terminal, to a multitasking Operating System. Applications needed to run in the background to listen and respond on the network and process inputs such as the mouse cursor. Multitasking was required way before modern multiple-core CPUs, so Operating Systems long could to share the system resources between multiple processes.</p>\n<p style=\"font-size: 16px;\">At the core of any Operating System is a registry of running processes. Each process will have an owner, and it can request resources, like memory or CPU. In the last chapter, you explored memory allocation. For a CPU, the process will request CPU time in the form of operations to be executed. The Operating System controls which process is using the CPU. It does this by allocating “CPU Time” and scheduling processes by a priority:</p>\n<p style=\"font-size: 16px;\"><center><img src=\"/media/post/python_internals/58.png\" alt=\"58\" /></center></p>\n<p style=\"font-size: 16px;\">A single process may need to do multiple things at once. For example, if you use a word processor, it needs to check your spelling while you’re typing. Modern applications accomplish this by running multiple threads, concurrently, and handling their own resources.</p>\n<p style=\"font-size: 16px;\">Concurrency is an excellent solution to dealing with multitasking, but CPUs have their limits. Some high-performance computers deploy either multiple CPUs or multiple cores to spread tasks. Operating Systems provide a way of scheduling processes across multiple CPUs:</p>\n<p style=\"font-size: 16px;\"><center><img src=\"/media/post/python_internals/59.png\" alt=\"59\" /></center></p>\n<p style=\"font-size: 16px;\">In summary,</p>\n<ul>\n<li>To have <strong>parallelism</strong>, you need multiple computational units. Computational units can be CPUs or Cores.</li>\n<li>To have <strong>concurrency</strong>, you need a way of scheduling tasks so that idle ones don’t lock the resources.</li>\n</ul>\n<p style=\"font-size: 16px;\">Many parts of CPython’s design abstract the complexity of Operating Systems to provide a simple API for developers. CPython’s approach to parallelism and concurrency is no exception.</p>\n<h2 id=models-of-parallelism-and-concurrency>Models of Parallelism and Concurrency</h2>\n<p style=\"font-size: 16px;\">CPython offers many approaches to Parallelism and Concurrency. Your choice depends on several factors. There are also overlapping use cases across models as CPython has evolved.</p>\n<p style=\"font-size: 16px;\">You may find that for a particular problem, there are two or more concurrency implementations to choose from. Each with their own pros and cons.</p>\n<p style=\"font-size: 16px;\">The four bundled models with CPython are:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Approach</th>\n<th align=\"left\">Module</th>\n<th align=\"left\">Concurrent</th>\n<th align=\"left\">Parallel</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">Threading</td>\n<td align=\"left\"><code>threading</code></td>\n<td align=\"left\">Yes</td>\n<td align=\"left\">No</td>\n</tr>\n<tr>\n<td align=\"left\">Multiprocessing</td>\n<td align=\"left\"><code>multiprocessing</code></td>\n<td align=\"left\">Yes</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\">Async</td>\n<td align=\"left\"><code>asyncio</code></td>\n<td align=\"left\">Yes</td>\n<td align=\"left\">No</td>\n</tr>\n<tr>\n<td align=\"left\">Subinterpreters</td>\n<td align=\"left\"><code>subinterpreters</code></td>\n<td align=\"left\">Yes</td>\n<td align=\"left\">Yes</td>\n</tr>\n</tbody>\n</table>\n<h2 id=the-structure-of-a-process>The Structure of a Process</h2>\n<p style=\"font-size: 16px;\">One of the tasks for an Operating System, like Windows, macOS, or Linux, is to control the running processes. These processes could be UI applications like a browser or IDE. They could also be background processes, like network services or OS services.</p>\n<p style=\"font-size: 16px;\">To control these processes, the OS provides an API to start a new process. When a process is created, it is registered by the Operating System so that it knows which processes are running. Processes are given a unique ID (PID). Depending on the Operating System, they have other properties.</p>\n<p style=\"font-size: 16px;\">POSIX processes have a minimum set of properties, registered in the Operating System:</p>\n<ul>\n<li>Controlling Terminal</li>\n<li>Current Working Directory</li>\n<li>Effective Group ID, Effective User ID</li>\n<li>File Descriptors, File Mode Creation Mask</li>\n<li>Process Group ID, Process ID</li>\n<li>Real Group ID, Real User ID</li>\n<li>Root Directory</li>\n</ul>\n<p style=\"font-size: 16px;\">You can see these attributes for running processes in macOS or Linux by running the <code>ps</code> command.</p>\n<blockquote>\n<p style=\"font-size: 16px;\"><strong>Note</strong></p>\n<p style=\"font-size: 16px;\">The <a href=\"https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap01.html\">IEEE POSIX Standard (1003.1-2017)</a> defines the interface and standard behaviors for processes and threads</p>\n</blockquote>\n<p style=\"font-size: 16px;\">Windows has a similar list of properties but sets its own standard. The Windows file permissions, directory structures, and process registry are very different from POSIX. Windows processes, represented by <a href=\"https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32-process\">Win32_Process</a>, can be queried in WMI, the Windows Management Interface runtime, or by using the Task Manager.</p>\n<p style=\"font-size: 16px;\">Once a process is started on an Operating System, it is given:</p>\n<ul>\n<li>A <strong>Stack</strong> of memory for calling subroutines</li>\n<li>A <strong>Heap</strong> (see Dynamic Memory Allocation in C)</li>\n<li>Access to <strong>Files</strong>, <strong>Locks</strong>, and <strong>Sockets</strong> on the Operating System</li>\n</ul>\n<p style=\"font-size: 16px;\">The CPU on your computer also keeps additional data when the process is executing, such as :</p>\n<ul>\n<li><strong>Registers</strong> holding the current instruction being executed or any other data needed by the process for that instruction</li>\n<li>An <strong>Instruction Pointer</strong>, or <strong>Program Counter</strong> indicating which instruction in the program sequence is being executed</li>\n</ul>\n<p style=\"font-size: 16px;\">The CPython process comprises of the compiled CPython interpreter, and the compiled modules. These modules are loaded at runtime and converted into instructions by the CPython Evaluation Loop:</p>\n<p style=\"font-size: 16px;\"><center><img src=\"/media/post/python_internals/60.png\" alt=\"60\" /></center></p>\n<p style=\"font-size: 16px;\">The program register and program counter point to a <strong>single</strong> instruction in the process. This means that only one instruction can be executing at any one time.</p>\n<p style=\"font-size: 16px;\">For CPython, this means that only one Python bytecode instruction can be executing at any one time.</p>\n<p style=\"font-size: 16px;\">There are two main approaches to allowing parallel execution of instructions in a process:</p>\n<ul>\n<li>Fork another process</li>\n<li>Spawn a thread</li>\n</ul>\n<p style=\"font-size: 16px;\">Now that you have reviewed what makes up a process. Next, you can explore forking and spawning child processes.</p>\n<h2 id=multi-process-parallelism>Multi-Process Parallelism</h2>\n<p style=\"font-size: 16px;\">POSIX systems provide an API for any process to <strong>fork</strong> a child process. Forking processes is a low-level API call to the Operating System that can be made by any running process. When this call is made, the OS will clone all the attributes of the currently running process and create a new process. This clone operation includes the heap, register, and counter position of the parent process. The child process can read any variables from the parent process at the time of forking.</p>\n<h4 id=forking-a-process-in-posix>Forking a Process in POSIX</h4>\n<p style=\"font-size: 16px;\">As an example, take the Fahrenheit to Celcius example application used at the beginning of Dynamic Memory Allocation in C. Adapt it to spawn a child process for each Fahrenheit value instead of calculating them in sequence. This is accomplished by using the <code>fork()</code> function. Each child process will continue operating from that point:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #75715e\">#include</span><span style=\"color: #f8f8f2\"> </span><span style=\"color: #75715e\">&lt;stdio.h&gt;</span>\n<span style=\"color: #75715e\">#include</span><span style=\"color: #f8f8f2\"> </span><span style=\"color: #75715e\">&lt;stdlib.h&gt;</span>\n<span style=\"color: #75715e\">#include</span><span style=\"color: #f8f8f2\"> </span><span style=\"color: #75715e\">&lt;unistd.h&gt;</span>\n\n<span style=\"color: #66d9ef\">static</span><span style=\"color: #f8f8f2\"> </span><span style=\"color: #66d9ef\">const</span><span style=\"color: #f8f8f2\"> </span><span style=\"color: #66d9ef\">double</span><span style=\"color: #f8f8f2\"> five_ninths </span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\"> </span><span style=\"color: #ae81ff\">5.0</span><span style=\"color: #f92672\">/</span><span style=\"color: #ae81ff\">9.0</span><span style=\"color: #f8f8f2\">;</span>\n\n<span style=\"color: #66d9ef\">double</span><span style=\"color: #f8f8f2\"> </span><span style=\"color: #a6e22e\">celsius</span><span style=\"color: #f8f8f2\">(</span><span style=\"color: #66d9ef\">double</span><span style=\"color: #f8f8f2\"> fahrenheit) {</span>\n<span style=\"color: #f8f8f2\">    </span><span style=\"color: #66d9ef\">return</span><span style=\"color: #f8f8f2\"> (fahrenheit </span><span style=\"color: #f92672\">-</span><span style=\"color: #f8f8f2\"> </span><span style=\"color: #ae81ff\">32</span><span style=\"color: #f8f8f2\">) </span><span style=\"color: #f92672\">*</span><span style=\"color: #f8f8f2\"> five_ninths;</span>\n<span style=\"color: #f8f8f2\">}</span>\n\n<span style=\"color: #66d9ef\">int</span><span style=\"color: #f8f8f2\"> </span><span style=\"color: #a6e22e\">main</span><span style=\"color: #f8f8f2\">(</span><span style=\"color: #66d9ef\">int</span><span style=\"color: #f8f8f2\"> argc, </span><span style=\"color: #66d9ef\">char</span><span style=\"color: #f92672\">**</span><span style=\"color: #f8f8f2\"> argv) {</span>\n<span style=\"color: #f8f8f2\">    </span><span style=\"color: #66d9ef\">if</span><span style=\"color: #f8f8f2\"> (argc </span><span style=\"color: #f92672\">!=</span><span style=\"color: #f8f8f2\"> </span><span style=\"color: #ae81ff\">2</span><span style=\"color: #f8f8f2\">)</span>\n<span style=\"color: #f8f8f2\">    \t</span><span style=\"color: #66d9ef\">return</span><span style=\"color: #f8f8f2\"> </span><span style=\"color: #ae81ff\">-1</span><span style=\"color: #f8f8f2\">;</span>\n<span style=\"color: #f8f8f2\">    </span><span style=\"color: #66d9ef\">int</span><span style=\"color: #f8f8f2\"> number </span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\"> atoi(argv[</span><span style=\"color: #ae81ff\">1</span><span style=\"color: #f8f8f2\">]);</span>\n<span style=\"color: #f8f8f2\">    </span><span style=\"color: #66d9ef\">for</span><span style=\"color: #f8f8f2\"> (</span><span style=\"color: #66d9ef\">int</span><span style=\"color: #f8f8f2\"> i </span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\"> </span><span style=\"color: #ae81ff\">1</span><span style=\"color: #f8f8f2\"> ; i </span><span style=\"color: #f92672\">&lt;=</span><span style=\"color: #f8f8f2\"> number ; i</span><span style=\"color: #f92672\">++</span><span style=\"color: #f8f8f2\"> ) {</span>\n<span style=\"color: #f8f8f2\">    \t</span><span style=\"color: #66d9ef\">double</span><span style=\"color: #f8f8f2\"> f_value </span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\"> </span><span style=\"color: #ae81ff\">100</span><span style=\"color: #f8f8f2\"> </span><span style=\"color: #f92672\">+</span><span style=\"color: #f8f8f2\"> (i</span><span style=\"color: #f92672\">*</span><span style=\"color: #ae81ff\">10</span><span style=\"color: #f8f8f2\">);</span>\n<span style=\"color: #f8f8f2\">    \t</span><span style=\"color: #66d9ef\">pid_t</span><span style=\"color: #f8f8f2\"> child </span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\"> fork();</span>\n<span style=\"color: #f8f8f2\">    \t</span><span style=\"color: #66d9ef\">if</span><span style=\"color: #f8f8f2\"> (child </span><span style=\"color: #f92672\">==</span><span style=\"color: #f8f8f2\"> </span><span style=\"color: #ae81ff\">0</span><span style=\"color: #f8f8f2\">) { </span><span style=\"color: #75715e\">// Is child process</span>\n<span style=\"color: #f8f8f2\">    \t\t</span><span style=\"color: #66d9ef\">double</span><span style=\"color: #f8f8f2\"> c_value </span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\"> celsius(f_value);</span>\n<span style=\"color: #f8f8f2\">    \t\tprintf(</span><span style=\"color: #e6db74\">&quot;%f F is %f C (pid %d)n&quot;</span><span style=\"color: #f8f8f2\">, f_value, c_value, getpid());</span>\n<span style=\"color: #f8f8f2\">    \t\texit(</span><span style=\"color: #ae81ff\">0</span><span style=\"color: #f8f8f2\">);</span>\n<span style=\"color: #f8f8f2\">    \t}</span>\n<span style=\"color: #f8f8f2\">    }</span>\n<span style=\"color: #f8f8f2\">    printf(</span><span style=\"color: #e6db74\">&quot;Spawned %d processes from %dn&quot;</span><span style=\"color: #f8f8f2\">, number, getpid());</span>\n<span style=\"color: #f8f8f2\">    </span><span style=\"color: #66d9ef\">return</span><span style=\"color: #f8f8f2\"> </span><span style=\"color: #ae81ff\">0</span><span style=\"color: #f8f8f2\">;</span>\n<span style=\"color: #f8f8f2\">}</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">Running this on the command-line would give an output similar to:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span>./thread_celcius 4\n110.000000 F is 43.333333 C (pid 57179)\n120.000000 F is 48.888889 C (pid 57180)\nSpawned 4 processes from 57178\n130.000000 F is 54.444444 C (pid 57181)\n140.000000 F is 60.000000 C (pid 57182)\n</pre></div>\n\n<p style=\"font-size: 16px;\">The parent process (57178), spawned 4 processes. For each child process, it continued at the line <code>child = fork()</code>, where the resulting value of <code>child</code> is 0. It then completes the calculation, prints the value, and exits the process. Finally, the parent process outputs how many processes it spawned, and it’s own PID. The time taken for the 3rd and 4th child processes to complete was longer than it took for the parent process to complete. This is why the parent process prints the final output before the 3rd and 4th print their own.</p>\n<p style=\"font-size: 16px;\">A parent process can exit, with its own exit code before a child process. Child Processes will be added to a Process Group by the Operating System, making it easier to control all related processes:</p>\n<p style=\"font-size: 16px;\"><center><img src=\"/media/post/python_internals/61.png\" alt=\"61\" /></center></p>\n<p style=\"font-size: 16px;\">The biggest downside with this approach to parallelism is that the child process is a complete copy of the parent process. In the case of CPython, this means you would have 2 CPython interpreters running, and both would have to load the modules and all the libraries. It creates significant overhead. Using multiple processes makes sense when the overhead of forking a process is outweighed by the size of the task being completed.</p>\n<p style=\"font-size: 16px;\">Another major downside of forked processes is that they have a separate, isolated, heap from the parent process. This means that the child process cannot write to the memory space of the parent process. When creating the child process, the parent’s heap becomes available to the child process. To send information back to the parent, some form of Inter-Process-Communication (IPC) must be used.</p>\n<blockquote>\n<p style=\"font-size: 16px;\"><strong>Note</strong></p>\n<p style=\"font-size: 16px;\">The os module offers a wrapper around the <code>fork()</code> function.</p>\n</blockquote>\n<h4 id=multi-processing-in-windows>Multi-Processing in Windows</h4>\n<p style=\"font-size: 16px;\">So far, you’ve been reading the POSIX model. Windows doesn’t provide an equivalent to <code>fork()</code>, and Python <em>should</em> (as best as possible) have the same API across Linux, macOS, and Windows.</p>\n<p style=\"font-size: 16px;\">To overcome this, the <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw\"><code>CreateProcessW() API</code></a> is used to spawn another <code>python.exe</code> process with a <code>-c</code> command-line argument.</p>\n<p style=\"font-size: 16px;\">This step is known as “spawning,” a process and is also available on POSIX. You’ll see references to it throughout this chapter.</p>\n<h4 id=the-codemultiprocessingcode-package>The <code>multiprocessing</code> Package</h4>\n<p style=\"font-size: 16px;\">CPython provides an API on top of the Operating System process forking API. This API makes it simple to create multi-process parallelism in Python. This API is available from the <code>multiprocessing</code> package. This package provides expansive capabilities for pooling processes, queues, forking, creating shared memory heaps, connecting processes together, and more.</p>\n<h4 id=related-source-files>Related Source Files</h4>\n<p style=\"font-size: 16px;\">Source files related to multiprocessing are:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">File</th>\n<th align=\"left\">Purpose</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>Lib/multiprocessing</code></td>\n<td align=\"left\">Python Source for the <code>multiprocessing</code> package</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Modules/_posixsubprocess.c</code></td>\n<td align=\"left\">C extension module wrapping the POSIX <code>fork()</code> syscall</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Modules/_winapi.c</code></td>\n<td align=\"left\">C extension module wrapping the Windows Kernel APIs</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Modules/_multiprocessing</code></td>\n<td align=\"left\">C extension module used by the <code>multiprocessing</code> package</td>\n</tr>\n<tr>\n<td align=\"left\"><code>PC/msvcrtmodule.c</code></td>\n<td align=\"left\">A Python interface to the Microsoft Visual C Runtime Library</td>\n</tr>\n</tbody>\n</table>\n<h4 id=spawning-and-forking-processes>Spawning and Forking Processes</h4>\n<p style=\"font-size: 16px;\">The multiprocessing package offers three methods to start a new parallel process.</p>\n<ul>\n<li>Forking an Interpreter (on POSIX only)</li>\n<li>Spawning a new Interpreter process (on POSIX and Windows)</li>\n<li>Running a Fork Server, where a new process is created which then forks any number of processes (on POSIX only)</li>\n</ul>\n<blockquote>\n<p style=\"font-size: 16px;\"><strong>Note</strong></p>\n<p style=\"font-size: 16px;\">For Windows and macOS, the default start method is Spawning. For Linux, the default is Forking. You can override the default method using the <code>multiprocessing.set_start_method()</code> function.</p>\n</blockquote>\n<p style=\"font-size: 16px;\">The Python API for starting a new process takes a callable, <code>target</code>, and a tuple of arguments, <code>args</code>. Take this simple example of spawning a new process to convert Fahrenheit to Celcius:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">multiprocessing</span> <span style=\"color: #66d9ef\">as</span> <span style=\"color: #f8f8f2\">mp</span>\n<span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">os</span>\n\n<span style=\"color: #66d9ef\">def</span> <span style=\"color: #a6e22e\">to_celcius</span><span style=\"color: #f8f8f2\">(f):</span>\n    <span style=\"color: #f8f8f2\">c</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">(f</span> <span style=\"color: #f92672\">-</span> <span style=\"color: #ae81ff\">32</span><span style=\"color: #f8f8f2\">)</span> <span style=\"color: #f92672\">*</span> <span style=\"color: #f8f8f2\">(</span><span style=\"color: #ae81ff\">5</span><span style=\"color: #f92672\">/</span><span style=\"color: #ae81ff\">9</span><span style=\"color: #f8f8f2\">)</span>\n    <span style=\"color: #f8f8f2\">pid</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">os</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">getpid()</span>\n    <span style=\"color: #f8f8f2\">print(</span><span style=\"color: #e6db74\">f&quot;{</span><span style=\"color: #f8f8f2\">f</span><span style=\"color: #e6db74\">}F is {</span><span style=\"color: #f8f8f2\">c</span><span style=\"color: #e6db74\">}C (pid {</span><span style=\"color: #f8f8f2\">pid</span><span style=\"color: #e6db74\">})&quot;</span><span style=\"color: #f8f8f2\">)</span>\n    \n<span style=\"color: #66d9ef\">if</span> <span style=\"color: #f8f8f2\">__name__</span> <span style=\"color: #f92672\">==</span> <span style=\"color: #e6db74\">&#39;__main__&#39;</span><span style=\"color: #f8f8f2\">:</span>\n    <span style=\"color: #f8f8f2\">mp</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">set_start_method(</span><span style=\"color: #e6db74\">&#39;spawn&#39;</span><span style=\"color: #f8f8f2\">)</span>\n    <span style=\"color: #f8f8f2\">p</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">mp</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">Process(target</span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\">to_celcius,</span> <span style=\"color: #f8f8f2\">args</span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\">(</span><span style=\"color: #ae81ff\">110</span><span style=\"color: #f8f8f2\">,))</span>\n    <span style=\"color: #f8f8f2\">p</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">start()</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">While you can start a single process, the <code>multiprocessing</code> API assumes you want to start multiple. There are convenience methods for spawning multiple processes and feeding them sets of data. One of those methods is the <code>Pool</code> class.</p>\n<p style=\"font-size: 16px;\">The previous example can be expanded to calculate a range of values in separate Python interpreters:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">multiprocessing</span> <span style=\"color: #66d9ef\">as</span> <span style=\"color: #f8f8f2\">mp</span>\n<span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">os</span>\n\n<span style=\"color: #66d9ef\">def</span> <span style=\"color: #a6e22e\">to_celcius</span><span style=\"color: #f8f8f2\">(f):</span>\n    <span style=\"color: #f8f8f2\">c</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">(f</span> <span style=\"color: #f92672\">-</span> <span style=\"color: #ae81ff\">32</span><span style=\"color: #f8f8f2\">)</span> <span style=\"color: #f92672\">*</span> <span style=\"color: #f8f8f2\">(</span><span style=\"color: #ae81ff\">5</span><span style=\"color: #f92672\">/</span><span style=\"color: #ae81ff\">9</span><span style=\"color: #f8f8f2\">)</span>\n    <span style=\"color: #f8f8f2\">pid</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">os</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">getpid()</span>\n    <span style=\"color: #f8f8f2\">print(</span><span style=\"color: #e6db74\">f&quot;{</span><span style=\"color: #f8f8f2\">f</span><span style=\"color: #e6db74\">}F is {</span><span style=\"color: #f8f8f2\">c</span><span style=\"color: #e6db74\">}C (pid {</span><span style=\"color: #f8f8f2\">pid</span><span style=\"color: #e6db74\">})&quot;</span><span style=\"color: #f8f8f2\">)</span>\n    \n<span style=\"color: #66d9ef\">if</span> <span style=\"color: #f8f8f2\">__name__</span> <span style=\"color: #f92672\">==</span> <span style=\"color: #e6db74\">&#39;__main__&#39;</span><span style=\"color: #f8f8f2\">:</span>\n    <span style=\"color: #f8f8f2\">mp</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">set_start_method(</span><span style=\"color: #e6db74\">&#39;spawn&#39;</span><span style=\"color: #f8f8f2\">)</span>\n    <span style=\"color: #66d9ef\">with</span> <span style=\"color: #f8f8f2\">mp</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">Pool(</span><span style=\"color: #ae81ff\">4</span><span style=\"color: #f8f8f2\">)</span> <span style=\"color: #66d9ef\">as</span> <span style=\"color: #f8f8f2\">pool:</span>\n    \t<span style=\"color: #f8f8f2\">pool</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">map(to_celcius,</span> <span style=\"color: #f8f8f2\">range(</span><span style=\"color: #ae81ff\">110</span><span style=\"color: #f8f8f2\">,</span> <span style=\"color: #ae81ff\">150</span><span style=\"color: #f8f8f2\">,</span> <span style=\"color: #ae81ff\">10</span><span style=\"color: #f8f8f2\">))</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">Note that the output shows the same PID. Because the CPython interpreter process has a signification overhead, the <code>Pool</code> will consider each process in the pool a “worker.” If a worker has completed, it will be reused. If you replace the line:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span>    <span style=\"color: #66d9ef\">with</span> <span style=\"color: #f8f8f2\">mp</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">Pool(</span><span style=\"color: #ae81ff\">4</span><span style=\"color: #f8f8f2\">)</span> <span style=\"color: #66d9ef\">as</span> <span style=\"color: #f8f8f2\">pool:</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">with:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span>    <span style=\"color: #66d9ef\">with</span> <span style=\"color: #f8f8f2\">mp</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">Pool(</span><span style=\"color: #ae81ff\">4</span><span style=\"color: #f8f8f2\">,</span> <span style=\"color: #f8f8f2\">maxtasksperchild</span><span style=\"color: #f92672\">=</span><span style=\"color: #ae81ff\">1</span><span style=\"color: #f8f8f2\">)</span> <span style=\"color: #66d9ef\">as</span> <span style=\"color: #f8f8f2\">pool:</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">Thie previous multiprocessing examle will print something similar to:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span>python pool_process_celcius.py\n110F is 43.333333333333336C (pid 5654)\n120F is 48.88888888888889C (pid 5653)\n130F is 54.44444444444445C (pid 5652)\n140F is 60.0C (pid 5655)\n</pre></div>\n\n<p style=\"font-size: 16px;\">The output shows the process IDs of the newly spawned processes and the calculated values.</p>\n<h4 id=creation-of-child-processes>Creation of Child Processes</h4>\n<p style=\"font-size: 16px;\">Both of these scripts will create a new Python interpreter process and pass data to it using <code>pickle</code>.</p>\n<blockquote>\n<p style=\"font-size: 16px;\"><strong>Note</strong></p>\n<p style=\"font-size: 16px;\">The <code>pickle</code> module is a serialization package used for serializing Python objects. Davide Mastromatteo has written a great write up of the <a href=\"https://realpython.com/python-pickle-module/\">pickle module at realpython.com</a>.</p>\n</blockquote>\n<p style=\"font-size: 16px;\">For POSIX systems, the creation of the subprocess by the <code>multiprocessing</code> module is equivalent to this command:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #f8f8f2\">python</span> <span style=\"color: #f92672\">-</span><span style=\"color: #f8f8f2\">c</span> <span style=\"color: #e6db74\">&#39;from multiprocessing.spawn import spawn_main; spawn_main(tracker_fd=&lt;i&gt;, pipe_handle=&lt;j&gt;)&#39;</span> <span style=\"color: #f92672\">--</span><span style=\"color: #f8f8f2\">multiprocessing</span><span style=\"color: #f92672\">-</span><span style=\"color: #f8f8f2\">fork</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">Where  <code>i</code> the filehandle descriptor, and  <code>j</code> the pipe handle descriptor.</p>\n<p style=\"font-size: 16px;\">For Windows systems, the parent PID is used instead of a tracker file descriptor:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #f8f8f2\">python</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">exe</span> <span style=\"color: #f92672\">-</span><span style=\"color: #f8f8f2\">c</span> <span style=\"color: #e6db74\">&#39;from multiprocessing.spawn import spawn_main; spawn_main(parent_pid=&lt;k&gt;, pipe_handle=&lt;j&gt;)&#39;</span> <span style=\"color: #f92672\">--</span><span style=\"color: #f8f8f2\">multiprocessing</span><span style=\"color: #f92672\">-</span><span style=\"color: #f8f8f2\">fork</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">Where  <code>k</code> the parent PID and  <code>j</code> the pipe handle descriptor.</p>\n<h4 id=piping-data-to-the-child-process>Piping Data to the Child Process</h4>\n<p style=\"font-size: 16px;\">When the new child process has been instantiated on the OS, it will wait for initialization data from the parent process. The parent process writes 2 objects to a pipe file stream. The pipe file stream is a special IO stream used to send data between processes on the command line.</p>\n<p style=\"font-size: 16px;\">The first object written by the parent process is the <strong>preparation data</strong> object. This object is a dictionary containing some information about the parent, such as the executing directory, the start method, any special command-line arguments, and the <code>sys.path</code>. You can see an example of what is generated by running <code>multiprocessing.spawn.get_preparation_data(name)</code>:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #f92672\">&gt;&gt;&gt;</span> <span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">multiprocessing.spawn</span>\n<span style=\"color: #f92672\">&gt;&gt;&gt;</span> <span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">pprint</span>\n<span style=\"color: #f92672\">&gt;&gt;&gt;</span> <span style=\"color: #f8f8f2\">pprint</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">pprint(multiprocessing</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">spawn</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">get_preparation_data(</span><span style=\"color: #e6db74\">&quot;example&quot;</span><span style=\"color: #f8f8f2\">))</span>\n<span style=\"color: #f8f8f2\">{</span>\n    <span style=\"color: #e6db74\">&#39;authkey&#39;</span><span style=\"color: #f8f8f2\">:</span> <span style=\"color: #e6db74\">b&#39;x90xaa_x22[x18rixbcag]x93xfexf5xe5@[wJx99p#x00&#39;</span>\n    \t\t   <span style=\"color: #e6db74\">b&#39;xcexd4)1j.xc3c&#39;</span><span style=\"color: #f8f8f2\">,</span>\n\t<span style=\"color: #e6db74\">&#39;dir&#39;</span><span style=\"color: #f8f8f2\">:</span> <span style=\"color: #e6db74\">&#39;/Users/anthonyshaw&#39;</span><span style=\"color: #f8f8f2\">,</span>\n\t<span style=\"color: #e6db74\">&#39;log_to_stderr&#39;</span><span style=\"color: #f8f8f2\">:</span> <span style=\"color: #66d9ef\">False</span><span style=\"color: #f8f8f2\">,</span>\n\t<span style=\"color: #e6db74\">&#39;name&#39;</span><span style=\"color: #f8f8f2\">:</span> <span style=\"color: #e6db74\">&#39;example&#39;</span><span style=\"color: #f8f8f2\">,</span>\n\t<span style=\"color: #e6db74\">&#39;orig_dir&#39;</span><span style=\"color: #f8f8f2\">:</span> <span style=\"color: #e6db74\">&#39;/Users/anthonyshaw&#39;</span><span style=\"color: #f8f8f2\">,</span>\n\t<span style=\"color: #e6db74\">&#39;start_method&#39;</span><span style=\"color: #f8f8f2\">:</span> <span style=\"color: #e6db74\">&#39;spawn&#39;</span><span style=\"color: #f8f8f2\">,</span>\n\t<span style=\"color: #e6db74\">&#39;sys_argv&#39;</span><span style=\"color: #f8f8f2\">:</span> <span style=\"color: #f8f8f2\">[</span><span style=\"color: #e6db74\">&#39;&#39;</span><span style=\"color: #f8f8f2\">],</span>\n\t<span style=\"color: #e6db74\">&#39;sys_path&#39;</span><span style=\"color: #f8f8f2\">:</span> <span style=\"color: #f8f8f2\">[</span><span style=\"color: #e6db74\">&#39;/Users/anthonyshaw&#39;</span><span style=\"color: #f8f8f2\">]</span>\n<span style=\"color: #f8f8f2\">}</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">The second object written is the <code>BaseProcess</code> child class instance. Depending on how multiprocessing was called and which Operating System is being used, one of the child classes of <code>BaseProcess</code> will be the instance serialized.</p>\n<p style=\"font-size: 16px;\">Both the preparation data and process object are serialized using the <code>pickle</code> module and written to the parent process’ pipe stream:</p>\n<p style=\"font-size: 16px;\"><center><img src=\"/media/post/python_internals/62.png\" alt=\"62\" /></center></p>\n<blockquote>\n<p style=\"font-size: 16px;\"><strong>Note</strong></p>\n<p style=\"font-size: 16px;\">The POSIX implementation of the child process spawning and serialization process is located in <code>Lib &gt; multiprocessing &gt; popen_spawn_posix.py</code>. The Windows implementation is located in <code>Lib &gt; multiprocessing &gt; popen_spawn_win32.py</code>.</p>\n</blockquote>\n<h4 id=executing-the-child-process>Executing the Child Process</h4>\n<p style=\"font-size: 16px;\">The entry point of the child process, <code>multiprocessing.spawn.spawn_main()</code> takes the argument <code>pipe_handle</code> and either <code>parent_pid</code> for Windows or <code>tracked_fd</code> for POSIX:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #66d9ef\">def</span> <span style=\"color: #a6e22e\">spawn_main</span><span style=\"color: #f8f8f2\">(pipe_handle,</span> <span style=\"color: #f8f8f2\">parent_pid</span><span style=\"color: #f92672\">=</span><span style=\"color: #66d9ef\">None</span><span style=\"color: #f8f8f2\">,</span> <span style=\"color: #f8f8f2\">tracker_fd</span><span style=\"color: #f92672\">=</span><span style=\"color: #66d9ef\">None</span><span style=\"color: #f8f8f2\">):</span>\n    <span style=\"color: #e6db74\">&#39;&#39;&#39;</span>\n<span style=\"color: #e6db74\">    Run code specified by data received over pipe</span>\n<span style=\"color: #e6db74\">    &#39;&#39;&#39;</span>\n    <span style=\"color: #66d9ef\">assert</span> <span style=\"color: #f8f8f2\">is_forking(sys</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">argv),</span> <span style=\"color: #e6db74\">&quot;Not forking&quot;</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">For Windows, the function will call the <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess\">OpenProcess API</a> of the parent PID. This process object is used to create a filehandle, <code>fd</code>, of the parent process pipe:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span>    <span style=\"color: #66d9ef\">if</span> <span style=\"color: #f8f8f2\">sys</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">platform</span> <span style=\"color: #f92672\">==</span> <span style=\"color: #e6db74\">&#39;win32&#39;</span><span style=\"color: #f8f8f2\">:</span>\n        <span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">msvcrt</span>\n        <span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">_winapi</span>\n        \n        <span style=\"color: #66d9ef\">if</span> <span style=\"color: #f8f8f2\">parent_pid</span> <span style=\"color: #f92672\">is</span> <span style=\"color: #f92672\">not</span> <span style=\"color: #66d9ef\">None</span><span style=\"color: #f8f8f2\">:</span>\n            <span style=\"color: #f8f8f2\">source_process</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">_winapi</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">OpenProcess(</span>\n                <span style=\"color: #f8f8f2\">_winapi</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">SYNCHRONIZE</span> <span style=\"color: #f92672\">|</span> <span style=\"color: #f8f8f2\">_winapi</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">PROCESS_DUP_HANDLE,</span>\n                <span style=\"color: #66d9ef\">False</span><span style=\"color: #f8f8f2\">,</span> <span style=\"color: #f8f8f2\">parent_pid)</span>\n        <span style=\"color: #66d9ef\">else</span><span style=\"color: #f8f8f2\">:</span>\n            <span style=\"color: #f8f8f2\">source_process</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #66d9ef\">None</span>\n        <span style=\"color: #f8f8f2\">new_handle</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">reduction</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">duplicate(pipe_handle,</span>\n                                         <span style=\"color: #f8f8f2\">source_process</span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\">source_process)</span>\n        <span style=\"color: #f8f8f2\">fd</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">msvcrt</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">open_osfhandle(new_handle,</span> <span style=\"color: #f8f8f2\">os</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">O_RDONLY)</span>\n        <span style=\"color: #f8f8f2\">parent_sentinel</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">source_process</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">For POSIX, the <code>pipe_handle</code> becomes the file descriptor, <code>fd</code>, and is duplicated to become the <code>parent_sentinel</code> value:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span>    <span style=\"color: #66d9ef\">else</span><span style=\"color: #f8f8f2\">:</span>\n        <span style=\"color: #f92672\">from</span> <span style=\"color: #f8f8f2\">.</span> <span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">resource_tracker</span>\n        <span style=\"color: #f8f8f2\">resource_tracker</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">_resource_tracker</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">_fd</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">tracker_fd</span>\n        <span style=\"color: #f8f8f2\">fd</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">pipe_handle</span>\n        <span style=\"color: #f8f8f2\">parent_sentinel</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">os</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">dup(pipe_handle)</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">Next, the <code>_main()</code> function is called with the parent pipe file handle, <code>fd</code>, and the parent process sentinel, <code>parent_sentinel</code>. Whatever the return value of <code>_main()</code> is becomes the exit code for the process and the interpreter is terminated:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span>    <span style=\"color: #f8f8f2\">exitcode</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">_main(fd,</span> <span style=\"color: #f8f8f2\">parent_sentinel)</span>\n    <span style=\"color: #f8f8f2\">sys</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">exit(exitcode)</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">The <code>_main()</code> function is called with the file descriptor of the parent processes pipe and the parent sentinel for checking if the parent process has exited whilst executing the child.</p>\n<p style=\"font-size: 16px;\">The main function deserialises the binary data on the <code>fd</code> byte stream. Remember, this is the <code>pipe</code> file handle. The deserialization happens using using same <code>pickle</code> library that the parent process used:</p>\n<p style=\"font-size: 16px;\"><center><img src=\"/media/post/python_internals/63.png\" alt=\"63\" /></center></p>\n<p style=\"font-size: 16px;\">The first value is a <code>dict</code> containing the preparation data. The second value is an instance of <code>SpawnProcess</code> which is then used at the instance to call <code>_bootstrap()</code> upon:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #66d9ef\">def</span> <span style=\"color: #a6e22e\">_main</span><span style=\"color: #f8f8f2\">(fd,</span> <span style=\"color: #f8f8f2\">parent_sentinel):</span>\n    <span style=\"color: #66d9ef\">with</span> <span style=\"color: #f8f8f2\">os</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">fdopen(fd,</span> <span style=\"color: #e6db74\">&#39;rb&#39;</span><span style=\"color: #f8f8f2\">,</span> <span style=\"color: #f8f8f2\">closefd</span><span style=\"color: #f92672\">=</span><span style=\"color: #66d9ef\">True</span><span style=\"color: #f8f8f2\">)</span> <span style=\"color: #66d9ef\">as</span> <span style=\"color: #f8f8f2\">from_parent:</span>\n    \t<span style=\"color: #f8f8f2\">process</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">current_process()</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">_inheriting</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #66d9ef\">True</span>\n    \t<span style=\"color: #66d9ef\">try</span><span style=\"color: #f8f8f2\">:</span>\n            <span style=\"color: #f8f8f2\">preparation_data</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">reduction</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">pickle</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">load(from_parent)</span>\n            <span style=\"color: #f8f8f2\">prepare(preparation_data)</span>\n            <span style=\"color: #f8f8f2\">self</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">reduction</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">pickle</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">load(from_parent)</span>\n        <span style=\"color: #66d9ef\">finally</span><span style=\"color: #f8f8f2\">:</span>\n            <span style=\"color: #66d9ef\">del</span> <span style=\"color: #f8f8f2\">process</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">current_process()</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">_inheriting</span>\n\t<span style=\"color: #66d9ef\">return</span> <span style=\"color: #f8f8f2\">self</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">_bootstrap(parent_sentinel)</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">The <code>_bootstrap()</code> function handles the instantiation of a <code>BaseProcess</code> instance from the deserialized data, and then the target function is called with the arguments and keyword arguments. This final task is completed by <code>BaseProcess.run()</code>:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #66d9ef\">def</span> <span style=\"color: #a6e22e\">run</span><span style=\"color: #f8f8f2\">(self):</span>\n    <span style=\"color: #e6db74\">&#39;&#39;&#39;</span>\n<span style=\"color: #e6db74\">    Method to be run in sub-process; can be overridden in sub-class</span>\n<span style=\"color: #e6db74\">    &#39;&#39;&#39;</span>\n    <span style=\"color: #66d9ef\">if</span> <span style=\"color: #f8f8f2\">self</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">_target:</span>\n        <span style=\"color: #f8f8f2\">self</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">_target(</span><span style=\"color: #f92672\">*</span><span style=\"color: #f8f8f2\">self</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">_args,</span> <span style=\"color: #f92672\">**</span><span style=\"color: #f8f8f2\">self</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">_kwargs)</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">The exit code of <code>self._bootstrap()</code> is set as the exit code, and the child process is terminated. This process allows the parent process to serialize the module and the executable function. It also allows the child process to deserialize that instance, execute the function with arguments, and return. It does not allow for the exchanging of data once the child process has started. This task is done using the extension of the <code>Queue</code> and <code>Pipe</code> objects. If processes are being created in a pool, the first process will be ready and in a waiting state. The parent process repeats the process and sends the data to the next worker:</p>\n<p style=\"font-size: 16px;\"><center><img src=\"/media/post/python_internals/64.png\" alt=\"64\" /></center></p>\n<p style=\"font-size: 16px;\">The next worker receives the data and initializes its state and runs the target function:</p>\n<p style=\"font-size: 16px;\"><center><img src=\"/media/post/python_internals/65.png\" alt=\"65\" /></center></p>\n<p style=\"font-size: 16px;\">To share any data beyond initialization, queues and pipes must be used.</p>\n<h4 id=exchanging-data-with-queues-and-pipes>Exchanging Data with Queues and Pipes</h4>\n<p style=\"font-size: 16px;\">In the previous section you saw how child processes are spawned, and then the pipe is used as a serialization stream to tell the child process what function to call with arguments. There is two types of communication between processes, depending on the nature of the task.</p>\n<h4 id=semaphores>Semaphores</h4>\n<p style=\"font-size: 16px;\">Many of the mechanisms in multiprocessing use <strong>semaphores</strong> as a way of signaling that resources are locked, being waited on, or not used. Operating Systems use binary semaphores as a simple variable type for locking resources, like files, sockets, and other resources.</p>\n<p style=\"font-size: 16px;\">If one process is writing to a file or a network socket, you don’t want another process to suddenly start writing to the same file. The data would become corrupt instantly. Instead, Operating Systems put a “lock” on resources using a semaphore. Processes can also signal that they are waiting for that lock to be released so that when it is, they get a message to say it is ready and they can start using it.</p>\n<p style=\"font-size: 16px;\">Semaphores (in the real world) are a signaling method using flags, so the states for a resource of waiting, locked and not-used would look like:</p>\n<p style=\"font-size: 16px;\"><center><img src=\"/media/post/python_internals/66.png\" alt=\"66\" /></center></p>\n<p style=\"font-size: 16px;\">The semaphore API is different between Operating Systems, so there is an abstraction class, <code>multiprocessing.syncronize.Semaphore</code>.</p>\n<p style=\"font-size: 16px;\">Semaphores are used by CPython for multiprocessing because they are both <code>thread-safe</code> and <code>process-safe</code>. The Operating System handles any potential deadlocks of reading or writing to the same semaphore.</p>\n<p style=\"font-size: 16px;\">The implementation of these semaphore API functions is located in a C extension module <code>Modules/_multiprocessing/semaphore.c</code>. This extension module offers a single method for creating, locking, releasing semaphores, and other operations.</p>\n<p style=\"font-size: 16px;\">The call to the Operating System is through a series of Macros, which are compiled into different implementations depending on the Operating System platform. For Windows, the <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createsemaphorea\"><code>winbase.h</code> API functions for semaphores</a> are used:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #75715e\">#define SEM_CREATE(name, val, max) CreateSemaphore(NULL, val, max, NULL)</span>\n<span style=\"color: #75715e\">#define SEM_CLOSE(sem) (CloseHandle(sem) ? 0 : -1)</span>\n<span style=\"color: #75715e\">#define SEM_GETVALUE(sem, pval) _GetSemaphoreValue(sem, pval)</span>\n<span style=\"color: #75715e\">#define SEM_UNLINK(name) 0</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">For POSIX, the macros use the  <a href=\"http://man7.org/linux/man-pages/man3/sem_open.3.html\"><code>semaphore.h</code> API is used</a>:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #75715e\">#define SEM_CREATE(name, val, max) sem_open(name, O_CREAT | O_EXCL, 0600, val)</span>\n<span style=\"color: #75715e\">#define SEM_CLOSE(sem) sem_close(sem)</span>\n<span style=\"color: #75715e\">#define SEM_GETVALUE(sem, pval) sem_getvalue(sem, pval)</span>\n<span style=\"color: #75715e\">#define SEM_UNLINK(name) sem_unlink(name)</span>\n</pre></div>\n\n<h4 id=queues>Queues</h4>\n<p style=\"font-size: 16px;\">Queues are a great way of sending small data to and from multiple processes.</p>\n<p style=\"font-size: 16px;\">If you adapt the multiprocessing example before to use a <code>multiprocessing Manager()</code> instance, and create two queues:</p>\n<ul>\n<li><code>inputs</code> to hold the input Fahrenheit values</li>\n<li><code>outputs</code> to hold the resulting Celcius values Change the pool size to 2 so that there are two workers:</li>\n</ul>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">multiprocessing</span> <span style=\"color: #66d9ef\">as</span> <span style=\"color: #f8f8f2\">mp</span>\n\n<span style=\"color: #66d9ef\">def</span> <span style=\"color: #a6e22e\">to_celcius</span><span style=\"color: #f8f8f2\">(input:</span> <span style=\"color: #f8f8f2\">mp</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">Queue,</span> <span style=\"color: #f8f8f2\">output:</span> <span style=\"color: #f8f8f2\">mp</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">Queue):</span>\n    <span style=\"color: #f8f8f2\">f</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">input</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">get()</span>\n    <span style=\"color: #75715e\"># time-consuming task ...</span>\n    <span style=\"color: #f8f8f2\">c</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">(f</span> <span style=\"color: #f92672\">-</span> <span style=\"color: #ae81ff\">32</span><span style=\"color: #f8f8f2\">)</span> <span style=\"color: #f92672\">*</span> <span style=\"color: #f8f8f2\">(</span><span style=\"color: #ae81ff\">5</span><span style=\"color: #f92672\">/</span><span style=\"color: #ae81ff\">9</span><span style=\"color: #f8f8f2\">)</span>\n    <span style=\"color: #f8f8f2\">output</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">put(c)</span>\n    \n<span style=\"color: #66d9ef\">if</span> <span style=\"color: #f8f8f2\">__name__</span> <span style=\"color: #f92672\">==</span> <span style=\"color: #e6db74\">&#39;__main__&#39;</span><span style=\"color: #f8f8f2\">:</span>\n    <span style=\"color: #f8f8f2\">mp</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">set_start_method(</span><span style=\"color: #e6db74\">&#39;spawn&#39;</span><span style=\"color: #f8f8f2\">)</span>\n    <span style=\"color: #f8f8f2\">pool_manager</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">mp</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">Manager()</span>\n    <span style=\"color: #66d9ef\">with</span> <span style=\"color: #f8f8f2\">mp</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">Pool(</span><span style=\"color: #ae81ff\">2</span><span style=\"color: #f8f8f2\">)</span> <span style=\"color: #66d9ef\">as</span> <span style=\"color: #f8f8f2\">pool:</span>\n        <span style=\"color: #f8f8f2\">inputs</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">pool_manager</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">Queue()</span>\n        <span style=\"color: #f8f8f2\">outputs</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">pool_manager</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">Queue()</span>\n        <span style=\"color: #f8f8f2\">input_values</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">list(range(</span><span style=\"color: #ae81ff\">110</span><span style=\"color: #f8f8f2\">,</span> <span style=\"color: #ae81ff\">150</span><span style=\"color: #f8f8f2\">,</span> <span style=\"color: #ae81ff\">10</span><span style=\"color: #f8f8f2\">))</span>\n        <span style=\"color: #66d9ef\">for</span> <span style=\"color: #f8f8f2\">i</span> <span style=\"color: #f92672\">in</span> <span style=\"color: #f8f8f2\">input_values:</span>\n        \t<span style=\"color: #f8f8f2\">inputs</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">put(i)</span>\n        \t<span style=\"color: #f8f8f2\">pool</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">apply(to_celcius,</span> <span style=\"color: #f8f8f2\">(inputs,</span> <span style=\"color: #f8f8f2\">outputs))</span>\n                                    \n        <span style=\"color: #66d9ef\">for</span> <span style=\"color: #f8f8f2\">f</span> <span style=\"color: #f92672\">in</span> <span style=\"color: #f8f8f2\">input_values:</span>\n        \t<span style=\"color: #f8f8f2\">print(outputs</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">get(block</span><span style=\"color: #f92672\">=</span><span style=\"color: #66d9ef\">False</span><span style=\"color: #f8f8f2\">))</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">This would print the list of tuples returned to the <code>results</code> queue:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span>python pool_queue_celcius.py\n43.333333333333336\n48.88888888888889\n54.44444444444445\n60.0\n</pre></div>\n\n<p style=\"font-size: 16px;\">The parent process first puts the input values onto the input queue. The first worker then takes an item from the queue. Each time an item is taken from the queue using <code>.get()</code>, a semaphore lock is used on the queue object:</p>\n<p style=\"font-size: 16px;\"><center><img src=\"/media/post/python_internals/67.png\" alt=\"67\" /></center></p>\n<p style=\"font-size: 16px;\">While this worker is busy, the second worker then takes another value from the queue:</p>\n<p style=\"font-size: 16px;\"><center><img src=\"/media/post/python_internals/68.png\" alt=\"68\" /></center></p>\n<p style=\"font-size: 16px;\">The first worker has completed its calculation and puts the resulting value onto the result queue:</p>\n<p style=\"font-size: 16px;\"><center><img src=\"/media/post/python_internals/69.png\" alt=\"69\" /></center></p>\n<p style=\"font-size: 16px;\">Two queues are in use to separate the input and output values. Eventually, all input values have been processed, and the output queue is full. The values are then printed by the parent process:</p>\n<p style=\"font-size: 16px;\"><center><img src=\"/media/post/python_internals/70.png\" alt=\"70\" /></center></p>\n<p style=\"font-size: 16px;\">This example shows how a pool of workers could receive a queue of small, discreet values and process them in parallel to send the resulting data back to the host process. In practice, converting Celcius to Fahrenheit is a small, trivial calculation unsuited for parallel execution. If the worker process were doing another CPU-intensive calculation, this would provide significant performance improvement on a multi-CPU or multi-core computer.</p>\n<p style=\"font-size: 16px;\">For streaming data instead of discreet queues, pipes can be used instead.</p>\n<h4 id=pipes>Pipes</h4>\n<p style=\"font-size: 16px;\">Within the <code>multiprocessing</code> package, there is a type <code>Pipe</code>. Instantiating a Pipe returns two connections, a parent and a child. Both can send and receive data:</p>\n<p style=\"font-size: 16px;\"><center><img src=\"/media/post/python_internals/71.png\" alt=\"71\" /></center></p>\n<p style=\"font-size: 16px;\">In the queue example, a lock is implicitly placed on the queue when data is sent and received. Pipes do not have that behavior, so you have to be careful that two processes do not try and write to the same pipe at the same time.</p>\n<p style=\"font-size: 16px;\">If you adapt the last example to work with a pipe, it will require changing the <code>pool.apply()</code> to <code>pool.apply_async()</code>. This changes the execution of the next process to a non-blocking operation:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">multiprocessing</span> <span style=\"color: #66d9ef\">as</span> <span style=\"color: #f8f8f2\">mp</span>\n\n<span style=\"color: #66d9ef\">def</span> <span style=\"color: #a6e22e\">to_celcius</span><span style=\"color: #f8f8f2\">(child_pipe:</span> <span style=\"color: #f8f8f2\">mp</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">Pipe,</span> <span style=\"color: #f8f8f2\">parent_pipe:</span> <span style=\"color: #f8f8f2\">mp</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">Pipe):</span>\n    <span style=\"color: #f8f8f2\">f</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">parent_pipe</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">recv()</span>\n    <span style=\"color: #75715e\"># time-consuming task ...</span>\n    <span style=\"color: #f8f8f2\">c</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">(f</span> <span style=\"color: #f92672\">-</span> <span style=\"color: #ae81ff\">32</span><span style=\"color: #f8f8f2\">)</span> <span style=\"color: #f92672\">*</span> <span style=\"color: #f8f8f2\">(</span><span style=\"color: #ae81ff\">5</span><span style=\"color: #f92672\">/</span><span style=\"color: #ae81ff\">9</span><span style=\"color: #f8f8f2\">)</span>\n    <span style=\"color: #f8f8f2\">child_pipe</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">send(c)</span>\n    \n<span style=\"color: #66d9ef\">if</span> <span style=\"color: #f8f8f2\">__name__</span> <span style=\"color: #f92672\">==</span> <span style=\"color: #e6db74\">&#39;__main__&#39;</span><span style=\"color: #f8f8f2\">:</span>\n    <span style=\"color: #f8f8f2\">mp</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">set_start_method(</span><span style=\"color: #e6db74\">&#39;spawn&#39;</span><span style=\"color: #f8f8f2\">)</span>\n    <span style=\"color: #f8f8f2\">pool_manager</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">mp</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">Manager()</span>\n    <span style=\"color: #66d9ef\">with</span> <span style=\"color: #f8f8f2\">mp</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">Pool(</span><span style=\"color: #ae81ff\">2</span><span style=\"color: #f8f8f2\">)</span> <span style=\"color: #66d9ef\">as</span> <span style=\"color: #f8f8f2\">pool:</span>\n        <span style=\"color: #f8f8f2\">parent_pipe,</span> <span style=\"color: #f8f8f2\">child_pipe</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">mp</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">Pipe()</span>\n        <span style=\"color: #f8f8f2\">results</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">[]</span>\n        <span style=\"color: #66d9ef\">for</span> <span style=\"color: #f8f8f2\">i</span> <span style=\"color: #f92672\">in</span> <span style=\"color: #f8f8f2\">range(</span><span style=\"color: #ae81ff\">110</span><span style=\"color: #f8f8f2\">,</span> <span style=\"color: #ae81ff\">150</span><span style=\"color: #f8f8f2\">,</span> <span style=\"color: #ae81ff\">10</span><span style=\"color: #f8f8f2\">):</span>\n        \t<span style=\"color: #f8f8f2\">parent_pipe</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">send(i)</span>\n        \t<span style=\"color: #f8f8f2\">pool</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">apply_async(to_celcius,</span> <span style=\"color: #f8f8f2\">args</span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\">(child_pipe,</span> <span style=\"color: #f8f8f2\">parent_pipe))</span>\n        \t<span style=\"color: #f8f8f2\">print(child_pipe</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">recv())</span>\n        <span style=\"color: #f8f8f2\">parent_pipe</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">close()</span>\n        <span style=\"color: #f8f8f2\">child_pipe</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">close()</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">In this example, there is a risk of two or more processes trying to read from the parent pipe at the same time on the line:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #f8f8f2\">f</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">parent_pipe</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">recv()</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">There is also a risk of two or more processes trying to write to the child pipe at the same time.</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #f8f8f2\">child_pipe</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">send(c)</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">If this situation occurs, data would be corrupted in either the receive or send operations:</p>\n<p style=\"font-size: 16px;\"><center><img src=\"/media/post/python_internals/72.png\" alt=\"72\" /></center></p>\n<p style=\"font-size: 16px;\">To avoid this, you can implement a semaphore lock on the Operating System. Then all child processes will check with the Lock before reading or writing to the same pipe.</p>\n<p style=\"font-size: 16px;\">There are two locks required, one on the receiving end of the parent pipe, and another on the sending end of the child pipe:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">multiprocessing</span> <span style=\"color: #66d9ef\">as</span> <span style=\"color: #f8f8f2\">mp</span>\n\n<span style=\"color: #66d9ef\">def</span> <span style=\"color: #a6e22e\">to_celcius</span><span style=\"color: #f8f8f2\">(child_pipe:</span> <span style=\"color: #f8f8f2\">mp</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">Pipe,</span> <span style=\"color: #f8f8f2\">parent_pipe:</span> <span style=\"color: #f8f8f2\">mp</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">Pipe,</span>\n               <span style=\"color: #f8f8f2\">child_write_lock:</span> <span style=\"color: #f8f8f2\">mp</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">Lock,</span> <span style=\"color: #f8f8f2\">parent_read_lock:</span> <span style=\"color: #f8f8f2\">mp</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">Lock):</span>\n    <span style=\"color: #f8f8f2\">parent_read_lock</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">acquire()</span>\n    <span style=\"color: #66d9ef\">try</span><span style=\"color: #f8f8f2\">:</span>\n    \t<span style=\"color: #f8f8f2\">f</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">parent_pipe</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">recv()</span>\n    <span style=\"color: #66d9ef\">finally</span><span style=\"color: #f8f8f2\">:</span>\n    \t<span style=\"color: #f8f8f2\">parent_read_lock</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">release()</span>\n    <span style=\"color: #75715e\"># time-consuming task ...</span>\n    <span style=\"color: #f8f8f2\">c</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">(f</span> <span style=\"color: #f92672\">-</span> <span style=\"color: #ae81ff\">32</span><span style=\"color: #f8f8f2\">)</span> <span style=\"color: #f92672\">*</span> <span style=\"color: #f8f8f2\">(</span><span style=\"color: #ae81ff\">5</span><span style=\"color: #f92672\">/</span><span style=\"color: #ae81ff\">9</span><span style=\"color: #f8f8f2\">)</span>\n    \n    <span style=\"color: #f8f8f2\">child_write_lock</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">acquire()</span>\n    <span style=\"color: #66d9ef\">try</span><span style=\"color: #f8f8f2\">:</span>\n    \t<span style=\"color: #f8f8f2\">child_pipe</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">send(c)</span>\n    <span style=\"color: #66d9ef\">finally</span><span style=\"color: #f8f8f2\">:</span>\n        <span style=\"color: #f8f8f2\">child_write_lock</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">release()</span>\n        \n<span style=\"color: #66d9ef\">if</span> <span style=\"color: #f8f8f2\">__name__</span> <span style=\"color: #f92672\">==</span> <span style=\"color: #e6db74\">&#39;__main__&#39;</span><span style=\"color: #f8f8f2\">:</span>\n    <span style=\"color: #f8f8f2\">mp</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">set_start_method(</span><span style=\"color: #e6db74\">&#39;spawn&#39;</span><span style=\"color: #f8f8f2\">)</span>\n    <span style=\"color: #f8f8f2\">pool_manager</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">mp</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">Manager()</span>\n    <span style=\"color: #66d9ef\">with</span> <span style=\"color: #f8f8f2\">mp</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">Pool(</span><span style=\"color: #ae81ff\">2</span><span style=\"color: #f8f8f2\">)</span> <span style=\"color: #66d9ef\">as</span> <span style=\"color: #f8f8f2\">pool:</span>\n        <span style=\"color: #f8f8f2\">parent_pipe,</span> <span style=\"color: #f8f8f2\">child_pipe</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">mp</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">Pipe()</span>\n        <span style=\"color: #f8f8f2\">parent_read_lock</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">mp</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">Lock()</span>\n        <span style=\"color: #f8f8f2\">child_write_lock</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">mp</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">Lock()</span>\n        <span style=\"color: #f8f8f2\">results</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">[]</span>\n        <span style=\"color: #66d9ef\">for</span> <span style=\"color: #f8f8f2\">i</span> <span style=\"color: #f92672\">in</span> <span style=\"color: #f8f8f2\">range(</span><span style=\"color: #ae81ff\">110</span><span style=\"color: #f8f8f2\">,</span> <span style=\"color: #ae81ff\">150</span><span style=\"color: #f8f8f2\">,</span> <span style=\"color: #ae81ff\">10</span><span style=\"color: #f8f8f2\">):</span>\n        \t<span style=\"color: #f8f8f2\">parent_pipe</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">send(i)</span>\n        \t<span style=\"color: #f8f8f2\">pool</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">apply_async(to_celcius,</span> <span style=\"color: #f8f8f2\">args</span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\">(child_pipe,</span> <span style=\"color: #f8f8f2\">parent_pipe,</span>\n                                               <span style=\"color: #f8f8f2\">child_write_lock,</span>\n                                               <span style=\"color: #f8f8f2\">parent_read_lock))</span>\n        \t<span style=\"color: #f8f8f2\">print(child_pipe</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">recv())</span>\n        <span style=\"color: #f8f8f2\">parent_pipe</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">close()</span>\n        <span style=\"color: #f8f8f2\">child_pipe</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">close()</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">Now the worker processes will wait to acquire a lock before receiving data, and wait again to acquire another lock to send data:</p>\n<p style=\"font-size: 16px;\"><center><img src=\"/media/post/python_internals/73.png\" alt=\"73\" /></center></p>\n<p style=\"font-size: 16px;\">This example would suit situations where the data going over the pipe is large because the chance of a collision is higher.</p>\n<h4 id=shared-state-between-processes>Shared State Between Processes</h4>\n<p style=\"font-size: 16px;\">So far, you have seen how data can be shared between the child and the parent process. There may be scenarios where you want to share data between child processes. In this situation, the multiprocessing package provides two solutions:</p>\n<ul>\n<li>A performant Shared Memory API using shared memory maps and shared C types</li>\n<li>A flexible Server Process API supporting complex types via the Manager class</li>\n</ul>\n<h4 id=example-application>Example Application</h4>\n<p style=\"font-size: 16px;\">As a demonstration application, throughout this chapter, you will be refactoring a TCP port scanner for different concurrency and parallelism techniques.</p>\n<p style=\"font-size: 16px;\">Over a network, a host can be contacted on ports, which are a number from 1-65535. Common services have standard ports. For example, HTTP operates on port 80 and HTTPS on 443. TCP port scanners are used as a common network testing tool to check that packets can be sent over a network.</p>\n<p style=\"font-size: 16px;\">This code example uses the Queue interface, a thread-safe queue implementation similar to the one you use in the multiprocessing examples. The code also uses the socket package to try connecting to a remote port with a short timeout of 1 second.</p>\n<p style=\"font-size: 16px;\">The <code>check_port()</code> function will see if the <code>host</code> responds on the given port, and if it does respond, it adds the port number to the <code>results</code> queue.</p>\n<p style=\"font-size: 16px;\">When the script is executed, the <code>check_port()</code> function is called in sequence for port numbers 80-100.</p>\n<p style=\"font-size: 16px;\">After this has completed, the results queue is emptied out, and the results are printed on the command line.</p>\n<p style=\"font-size: 16px;\">So you can compare the difference, it will print the execution time at the end:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #f92672\">from</span> <span style=\"color: #f8f8f2\">queue</span> <span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">Queue</span>\n<span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">socket</span>\n<span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">time</span>\n<span style=\"color: #f8f8f2\">timeout</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #ae81ff\">1.0</span>\n\n<span style=\"color: #66d9ef\">def</span> <span style=\"color: #a6e22e\">check_port</span><span style=\"color: #f8f8f2\">(host:</span> <span style=\"color: #f8f8f2\">str,</span> <span style=\"color: #f8f8f2\">port:</span> <span style=\"color: #f8f8f2\">int,</span> <span style=\"color: #f8f8f2\">results:</span> <span style=\"color: #f8f8f2\">Queue):</span>\n    <span style=\"color: #f8f8f2\">sock</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">socket</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">socket(socket</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">AF_INET,</span> <span style=\"color: #f8f8f2\">socket</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">SOCK_STREAM)</span>\n    <span style=\"color: #f8f8f2\">sock</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">settimeout(timeout)</span>\n    <span style=\"color: #f8f8f2\">result</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">sock</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">connect_ex((host,</span> <span style=\"color: #f8f8f2\">port))</span>\n    <span style=\"color: #66d9ef\">if</span> <span style=\"color: #f8f8f2\">result</span> <span style=\"color: #f92672\">==</span> <span style=\"color: #ae81ff\">0</span><span style=\"color: #f8f8f2\">:</span>\n    \t<span style=\"color: #f8f8f2\">results</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">put(port)</span>\n    <span style=\"color: #f8f8f2\">sock</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">close()</span>\n\n<span style=\"color: #66d9ef\">if</span> <span style=\"color: #f8f8f2\">__name__</span> <span style=\"color: #f92672\">==</span> <span style=\"color: #e6db74\">&#39;__main__&#39;</span><span style=\"color: #f8f8f2\">:</span>\n    <span style=\"color: #f8f8f2\">start</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">time</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">time()</span>\n    <span style=\"color: #f8f8f2\">host</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #e6db74\">&quot;localhost&quot;</span> <span style=\"color: #75715e\"># replace with a host you own</span>\n    <span style=\"color: #f8f8f2\">results</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">Queue()</span>\n    <span style=\"color: #66d9ef\">for</span> <span style=\"color: #f8f8f2\">port</span> <span style=\"color: #f92672\">in</span> <span style=\"color: #f8f8f2\">range(</span><span style=\"color: #ae81ff\">80</span><span style=\"color: #f8f8f2\">,</span> <span style=\"color: #ae81ff\">100</span><span style=\"color: #f8f8f2\">):</span>\n    \t<span style=\"color: #f8f8f2\">check_port(host,</span> <span style=\"color: #f8f8f2\">port,</span> <span style=\"color: #f8f8f2\">results)</span>\n    <span style=\"color: #66d9ef\">while</span> <span style=\"color: #f92672\">not</span> <span style=\"color: #f8f8f2\">results</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">empty():</span>\n    \t<span style=\"color: #f8f8f2\">print(</span><span style=\"color: #e6db74\">&quot;Port {0} is open&quot;</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">format(results</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">get()))</span>\n    <span style=\"color: #f8f8f2\">print(</span><span style=\"color: #e6db74\">&quot;Completed scan in {0} seconds&quot;</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">format(time</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">time()</span> <span style=\"color: #f92672\">-</span> <span style=\"color: #f8f8f2\">start))</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">The execution will print out the open ports and the time taken:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span>python portscanner.py\nPort 80 is open\nCompleted scan in 19.623435020446777 seconds\n</pre></div>\n\n<p style=\"font-size: 16px;\">This example can be refactored to use multiprocessing. The <code>Queue</code> interface is swapped for <code>multiprocessing.Queue</code> and the ports are scanned together using a pool executor:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">multiprocessing</span> <span style=\"color: #66d9ef\">as</span> <span style=\"color: #f8f8f2\">mp</span>\n<span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">time</span>\n<span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">socket</span>\n\n<span style=\"color: #f8f8f2\">timeout</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #ae81ff\">1</span>\n\n<span style=\"color: #66d9ef\">def</span> <span style=\"color: #a6e22e\">check_port</span><span style=\"color: #f8f8f2\">(host:</span> <span style=\"color: #f8f8f2\">str,</span> <span style=\"color: #f8f8f2\">port:</span> <span style=\"color: #f8f8f2\">int,</span> <span style=\"color: #f8f8f2\">results:</span> <span style=\"color: #f8f8f2\">mp</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">Queue):</span>\n    <span style=\"color: #f8f8f2\">sock</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">socket</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">socket(socket</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">AF_INET,</span> <span style=\"color: #f8f8f2\">socket</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">SOCK_STREAM)</span>\n    <span style=\"color: #f8f8f2\">sock</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">settimeout(timeout)</span>\n    <span style=\"color: #f8f8f2\">result</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">sock</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">connect_ex((host,</span> <span style=\"color: #f8f8f2\">port))</span>\n    <span style=\"color: #66d9ef\">if</span> <span style=\"color: #f8f8f2\">result</span> <span style=\"color: #f92672\">==</span> <span style=\"color: #ae81ff\">0</span><span style=\"color: #f8f8f2\">:</span>\n    \t<span style=\"color: #f8f8f2\">results</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">put(port)</span>\n    <span style=\"color: #f8f8f2\">sock</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">close()</span>\n\n<span style=\"color: #66d9ef\">if</span> <span style=\"color: #f8f8f2\">__name__</span> <span style=\"color: #f92672\">==</span> <span style=\"color: #e6db74\">&#39;__main__&#39;</span><span style=\"color: #f8f8f2\">:</span>\n    <span style=\"color: #f8f8f2\">start</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">time</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">time()</span>\n    <span style=\"color: #f8f8f2\">processes</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">[]</span>\n    <span style=\"color: #f8f8f2\">scan_range</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">range(</span><span style=\"color: #ae81ff\">80</span><span style=\"color: #f8f8f2\">,</span> <span style=\"color: #ae81ff\">100</span><span style=\"color: #f8f8f2\">)</span>\n    <span style=\"color: #f8f8f2\">host</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #e6db74\">&quot;localhost&quot;</span> <span style=\"color: #75715e\"># replace with a host you own</span>\n    <span style=\"color: #f8f8f2\">mp</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">set_start_method(</span><span style=\"color: #e6db74\">&#39;spawn&#39;</span><span style=\"color: #f8f8f2\">)</span>\n    <span style=\"color: #f8f8f2\">pool_manager</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">mp</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">Manager()</span>\n    <span style=\"color: #66d9ef\">with</span> <span style=\"color: #f8f8f2\">mp</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">Pool(len(scan_range))</span> <span style=\"color: #66d9ef\">as</span> <span style=\"color: #f8f8f2\">pool:</span>\n        <span style=\"color: #f8f8f2\">outputs</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">pool_manager</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">Queue()</span>\n        <span style=\"color: #66d9ef\">for</span> <span style=\"color: #f8f8f2\">port</span> <span style=\"color: #f92672\">in</span> <span style=\"color: #f8f8f2\">scan_range:</span>\n        \t<span style=\"color: #f8f8f2\">processes</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">append(pool</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">apply_async(check_port,</span>\n                                              <span style=\"color: #f8f8f2\">(host,</span> <span style=\"color: #f8f8f2\">port,</span> <span style=\"color: #f8f8f2\">outputs)))</span>\n        <span style=\"color: #66d9ef\">for</span> <span style=\"color: #f8f8f2\">process</span> <span style=\"color: #f92672\">in</span> <span style=\"color: #f8f8f2\">processes:</span>\n        \t<span style=\"color: #f8f8f2\">process</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">get()</span>\n        <span style=\"color: #66d9ef\">while</span> <span style=\"color: #f92672\">not</span> <span style=\"color: #f8f8f2\">outputs</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">empty():</span>\n        \t<span style=\"color: #f8f8f2\">print(</span><span style=\"color: #e6db74\">&quot;Port {0} is open&quot;</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">format(outputs</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">get()))</span>\n        <span style=\"color: #f8f8f2\">print(</span><span style=\"color: #e6db74\">&quot;Completed scan in {0} seconds&quot;</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">format(time</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">time()</span> <span style=\"color: #f92672\">-</span> <span style=\"color: #f8f8f2\">start))</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">As you might expect, this application is much faster because it is testing each port in parallel:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span>python portscanner_mp_queue.py\nPort 80 is open\nCompleted scan in 1.556523084640503 seconds\n</pre></div>\n\n<h4 id=conclusion>Conclusion</h4>\n<p style=\"font-size: 16px;\">Multiprocessing offers a scalable, parallel execution API for Python. Data can be shared between processes, and CPU-intensive work can be broken into parallel tasks to take advantage of multiple core or CPU computers.</p>\n<p style=\"font-size: 16px;\">Multiprocessing is not a suitable solution when the task to be completed is not CPU intensive, but instead IO-bound. For example, if you spawned 4 worker processes to read and write to the same files, one would do all the work, and the other 3 would wait for the lock to be released.</p>\n<p style=\"font-size: 16px;\">Multiprocessing is also not suitable for short-lived tasks, because of the time and processing overhead of starting a new Python interpreter.</p>\n<p style=\"font-size: 16px;\">In both of those scenarios, you main find one of the next approaches is more suited.</p>\n<h2 id=multithreading>Multithreading</h2>\n<p style=\"font-size: 16px;\">CPython provides a high-level and a low-level API for creating, spawning, and controlling threads from Python. To understand Python threads, you should first understand how Operating System threads work. There are two implementations of threading in CPython.</p>\n<ul>\n<li><code>pthreads</code> - POSIX threads for Linux and macOS</li>\n<li><code>nt threads</code> - NT threads for Windows</li>\n</ul>\n<p style=\"font-size: 16px;\">In the section on The Structure of a Process, you saw how a process has:</p>\n<ul>\n<li>A <strong>Stack</strong> of subroutines</li>\n<li>A <strong>Heap</strong> of memory</li>\n<li>Access to <strong>Files</strong>, <strong>Locks</strong>, and <strong>Sockets</strong> on the Operating System</li>\n</ul>\n<p style=\"font-size: 16px;\">The biggest limitation to scaling a single process is that the Operating System will have a single <strong>Program Counter</strong> for that executable.</p>\n<p style=\"font-size: 16px;\">To get around this, modern Operating Systems allow processes to signal the Operating System to branch their execution into multiple threads.</p>\n<p style=\"font-size: 16px;\">Each thread will have its own Program Counter, but use the same resources as the host process. Each thread also has it’s own call stack, so it can be executing a different function.</p>\n<p style=\"font-size: 16px;\">Because multiple threads can read and write to the same memory space, collisions could occur. The solution to this is <strong>thread safety</strong> and involves making sure that memory space is locked by a single thread before it is accessed.</p>\n<p style=\"font-size: 16px;\">A single process with 3 threads would have a structure:</p>\n<p style=\"font-size: 16px;\"><center><img src=\"/media/post/python_internals/74.png\" alt=\"74\" /></center></p>\n<blockquote>\n<p style=\"font-size: 16px;\"><strong>Note</strong></p>\n<p style=\"font-size: 16px;\">For a great introductory tutorial on the Python threading API, check out <a href=\"https://realpython.com/intro-to-python-threading/\">Jim Anderson’s “Intro to Python Threading.”</a></p>\n</blockquote>\n<h4 id=the-gil>The GIL</h4>\n<p style=\"font-size: 16px;\">If you’re familiar with NT threads or POSIX threads from C, or you’ve used another high-level language, you may expect multithreading to be parallel.</p>\n<p style=\"font-size: 16px;\">In CPython, the threads are based on the C APIs, but the threads are Python threads. This means that every Python thread needs to execute Python bytecode through the evaluation loop.</p>\n<p style=\"font-size: 16px;\">The Python evaluation loop is not thread-safe. There are many parts of the interpreter state, such as the Garbage Collector, which are shared, and global.</p>\n<p style=\"font-size: 16px;\">To get around this, the CPython developers implemented a mega-lock, called the <strong>Global Interpreter Lock (GIL)</strong>. Before any opcode is executed in the frame-evaluation loop, the GIL is acquired by the thread, then once the opcode has been executed, it is released.</p>\n<p style=\"font-size: 16px;\">Aside from providing a global thread-safety to every operation in Python, this approach has a major drawback. Any operations which take a long time to execute will leave other threads waiting for the GIL to be released before they can execute.</p>\n<p style=\"font-size: 16px;\">This means that only 1 thread can be executing a Python bytecode operation at any one time.</p>\n<p style=\"font-size: 16px;\">To acquire the GIL, a call is made to <a href=\"https://github.com/python/cpython/blob/v3.9.0b1/Python/ceval_gil.h#L215\"><code>take_gil()</code></a> and then again to <a href=\"https://github.com/python/cpython/blob/v3.9.0b1/Python/ceval_gil.h#L144\"><code>drop_gil()</code></a> to release it. The GIL acquisition is made within the core frame evaluation loop, <code>_PyEval_EvalFrameDefault()</code>.</p>\n<p style=\"font-size: 16px;\">To stop a single frame execution from permanently holding the GIL, the evaluation loop state stores a flag, <code>gil_drop_request</code>. After every bytecode operation has completed in a frame, this flag is checked, and the GIL is temporarily released and then reacquired:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #f8f8f2\">...</span>\n<span style=\"color: #f8f8f2\">    </span><span style=\"color: #66d9ef\">if</span><span style=\"color: #f8f8f2\"> (_Py_atomic_load_relaxed(</span><span style=\"color: #f92672\">&amp;</span><span style=\"color: #f8f8f2\">ceval</span><span style=\"color: #f92672\">-&gt;</span><span style=\"color: #f8f8f2\">gil_drop_request)) {</span>\n<span style=\"color: #f8f8f2\">        </span><span style=\"color: #75715e\">/* Give another thread a chance */</span><span style=\"color: #f8f8f2\"></span>\n<span style=\"color: #f8f8f2\">        </span><span style=\"color: #66d9ef\">if</span><span style=\"color: #f8f8f2\"> (_PyThreadState_Swap(</span><span style=\"color: #f92672\">&amp;</span><span style=\"color: #f8f8f2\">runtime</span><span style=\"color: #f92672\">-&gt;</span><span style=\"color: #f8f8f2\">gilstate, NULL) </span><span style=\"color: #f92672\">!=</span><span style=\"color: #f8f8f2\"> tstate) {</span>\n<span style=\"color: #f8f8f2\">        \tPy_FatalError(</span><span style=\"color: #e6db74\">&quot;ceval: tstate mix-up&quot;</span><span style=\"color: #f8f8f2\">);</span>\n<span style=\"color: #f8f8f2\">        }</span>\n<span style=\"color: #f8f8f2\">        drop_gil(ceval, tstate);</span>\n<span style=\"color: #f8f8f2\">        </span>\n<span style=\"color: #f8f8f2\">        </span><span style=\"color: #75715e\">/* Other threads may run now */</span><span style=\"color: #f8f8f2\"></span>\n<span style=\"color: #f8f8f2\">        </span>\n<span style=\"color: #f8f8f2\">        take_gil(ceval, tstate);</span>\n<span style=\"color: #f8f8f2\">        </span><span style=\"color: #75715e\">/* Check if we should make a quick exit. */</span><span style=\"color: #f8f8f2\"></span>\n<span style=\"color: #f8f8f2\">        </span>\n<span style=\"color: #f8f8f2\">        exit_thread_if_finalizing(tstate);</span>\n<span style=\"color: #f8f8f2\">        </span>\n<span style=\"color: #f8f8f2\">        </span><span style=\"color: #66d9ef\">if</span><span style=\"color: #f8f8f2\"> (_PyThreadState_Swap(</span><span style=\"color: #f92672\">&amp;</span><span style=\"color: #f8f8f2\">runtime</span><span style=\"color: #f92672\">-&gt;</span><span style=\"color: #f8f8f2\">gilstate, tstate) </span><span style=\"color: #f92672\">!=</span><span style=\"color: #f8f8f2\"> NULL) {</span>\n<span style=\"color: #f8f8f2\">        \tPy_FatalError(</span><span style=\"color: #e6db74\">&quot;ceval: orphan tstate&quot;</span><span style=\"color: #f8f8f2\">);</span>\n<span style=\"color: #f8f8f2\">        }</span>\n<span style=\"color: #f8f8f2\">    }</span>\n<span style=\"color: #f8f8f2\">...</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">Despite the limitations that the GIL enforces on parallel execution, it means that multithreading in Python is very safe and ideal for running IO-bound tasks concurrently.</p>\n<h4 id=related-source-files>Related Source Files</h4>\n<p style=\"font-size: 16px;\">Source files related to threading are:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">File</th>\n<th align=\"left\">Purpose</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>Include/pythread.h</code></td>\n<td align=\"left\">PyThread API and definition</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Lib/threading.py</code></td>\n<td align=\"left\">High Level threading API and Standard Library module</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Modules/_threadmodule.c</code></td>\n<td align=\"left\">Low Level thread API and Standard Library module</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Python/thread.c</code></td>\n<td align=\"left\">C extension for the thread module</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Python/thread_nt.h</code></td>\n<td align=\"left\">Windows Threading API</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Python/thread_pthread.h</code></td>\n<td align=\"left\">POSIX Threading API</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Python/ceval_gil.h</code></td>\n<td align=\"left\">GIL lock implementation</td>\n</tr>\n</tbody>\n</table>\n<h4 id=starting-threads-in-python>Starting Threads in Python</h4>\n<p style=\"font-size: 16px;\">To demonstrate the performance gains of having multithreaded code (in spite of the GIL), you can implement a simple network port scanner in Python.</p>\n<p style=\"font-size: 16px;\">Now clone the previous script but change the logic to spawn a thread for each port using <code>threading.Thread()</code>. This is similar to the <code>multiprocessing</code> API, where it takes a <code>callable</code>, <code>target</code>, and a <code>tuple</code>, <code>args</code>. Start the threads inside the loop, but don’t wait for them to complete. Instead, append the thread instance to a list, <code>threads</code>:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #66d9ef\">for</span> <span style=\"color: #f8f8f2\">port</span> <span style=\"color: #f92672\">in</span> <span style=\"color: #f8f8f2\">range(</span><span style=\"color: #ae81ff\">800</span><span style=\"color: #f8f8f2\">,</span> <span style=\"color: #ae81ff\">100</span><span style=\"color: #f8f8f2\">):</span>\n    <span style=\"color: #f8f8f2\">t</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">Thread(target</span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\">check_port,</span> <span style=\"color: #f8f8f2\">args</span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\">(host,</span> <span style=\"color: #f8f8f2\">port,</span> <span style=\"color: #f8f8f2\">results))</span>\n    <span style=\"color: #f8f8f2\">t</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">start()</span>\n    <span style=\"color: #f8f8f2\">threads</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">append(t)</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">Once all threads have been created, iterate through the thread list and call <code>.join()</code> to wait for them to complete:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #66d9ef\">for</span> <span style=\"color: #f8f8f2\">t</span> <span style=\"color: #f92672\">in</span> <span style=\"color: #f8f8f2\">threads:</span>\n    <span style=\"color: #f8f8f2\">t</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">join()</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">Next, exhaust all the items in the results queue and print them to the screen:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #66d9ef\">while</span> <span style=\"color: #f92672\">not</span> <span style=\"color: #f8f8f2\">results</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">empty():</span>\n    <span style=\"color: #f8f8f2\">print(</span><span style=\"color: #e6db74\">&quot;Port {0} is open&quot;</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">format(results</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">get()))</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">The whole script is:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #f92672\">from</span> <span style=\"color: #f8f8f2\">threading</span> <span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">Thread</span>\n<span style=\"color: #f92672\">from</span> <span style=\"color: #f8f8f2\">queue</span> <span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">Queue</span>\n<span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">socket</span>\n<span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">time</span>\n\n<span style=\"color: #f8f8f2\">timeout</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #ae81ff\">1.0</span>\n\n<span style=\"color: #66d9ef\">def</span> <span style=\"color: #a6e22e\">check_port</span><span style=\"color: #f8f8f2\">(host:</span> <span style=\"color: #f8f8f2\">str,</span> <span style=\"color: #f8f8f2\">port:</span> <span style=\"color: #f8f8f2\">int,</span> <span style=\"color: #f8f8f2\">results:</span> <span style=\"color: #f8f8f2\">Queue):</span>\n    <span style=\"color: #f8f8f2\">sock</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">socket</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">socket(socket</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">AF_INET,</span> <span style=\"color: #f8f8f2\">socket</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">SOCK_STREAM)</span>\n    <span style=\"color: #f8f8f2\">sock</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">settimeout(timeout)</span>\n    <span style=\"color: #f8f8f2\">result</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">sock</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">connect_ex((host,</span> <span style=\"color: #f8f8f2\">port))</span>\n    <span style=\"color: #66d9ef\">if</span> <span style=\"color: #f8f8f2\">result</span> <span style=\"color: #f92672\">==</span> <span style=\"color: #ae81ff\">0</span><span style=\"color: #f8f8f2\">:</span>\n        <span style=\"color: #f8f8f2\">results</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">put(port)</span>\n    <span style=\"color: #f8f8f2\">sock</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">close()</span>\n    \n<span style=\"color: #66d9ef\">def</span> <span style=\"color: #a6e22e\">main</span><span style=\"color: #f8f8f2\">():</span>\n    <span style=\"color: #f8f8f2\">start</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">time</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">time()</span>\n    <span style=\"color: #f8f8f2\">host</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #e6db74\">&quot;localhost&quot;</span> <span style=\"color: #75715e\"># replace with a host you own</span>\n    <span style=\"color: #f8f8f2\">threads</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">[]</span>\n    <span style=\"color: #f8f8f2\">results</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">Queue()</span>\n    <span style=\"color: #66d9ef\">for</span> <span style=\"color: #f8f8f2\">port</span> <span style=\"color: #f92672\">in</span> <span style=\"color: #f8f8f2\">range(</span><span style=\"color: #ae81ff\">80</span><span style=\"color: #f8f8f2\">,</span> <span style=\"color: #ae81ff\">100</span><span style=\"color: #f8f8f2\">):</span>\n    \t<span style=\"color: #f8f8f2\">t</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">Thread(target</span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\">check_port,</span> <span style=\"color: #f8f8f2\">args</span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\">(host,</span> <span style=\"color: #f8f8f2\">port,</span> <span style=\"color: #f8f8f2\">results))</span>\n    \t<span style=\"color: #f8f8f2\">t</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">start()</span>\n    \t<span style=\"color: #f8f8f2\">threads</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">append(t)</span>\n    <span style=\"color: #66d9ef\">for</span> <span style=\"color: #f8f8f2\">t</span> <span style=\"color: #f92672\">in</span> <span style=\"color: #f8f8f2\">threads:</span>\n    \t<span style=\"color: #f8f8f2\">t</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">join()</span>\n    <span style=\"color: #66d9ef\">while</span> <span style=\"color: #f92672\">not</span> <span style=\"color: #f8f8f2\">results</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">empty():</span>\n    \t<span style=\"color: #f8f8f2\">print(</span><span style=\"color: #e6db74\">&quot;Port {0} is open&quot;</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">format(results</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">get()))</span>\n    <span style=\"color: #f8f8f2\">print(</span><span style=\"color: #e6db74\">&quot;Completed scan in {0} seconds&quot;</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">format(time</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">time()</span> <span style=\"color: #f92672\">-</span> <span style=\"color: #f8f8f2\">start))</span>\n    \n<span style=\"color: #66d9ef\">if</span> <span style=\"color: #f8f8f2\">__name__</span> <span style=\"color: #f92672\">==</span> <span style=\"color: #e6db74\">&#39;__main__&#39;</span><span style=\"color: #f8f8f2\">:</span>\n    <span style=\"color: #f8f8f2\">main()</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">When you call this threaded script at the command-line, it will execute 10+ times faster than the single-threaded example:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span>python portscanner_threads.py\nPort 80 is open\nCompleted scan in 1.0101029872894287 seconds\n</pre></div>\n\n<p style=\"font-size: 16px;\">This also runs 50-60% faster than the multiprocessing example. Remember that multiprocessing has an overhead for starting the new processes, threading does have an overhead, but it is much smaller.</p>\n<p style=\"font-size: 16px;\">You may be wondering- if the GIL means that only a single operation can execute at once, why is this faster?</p>\n<p style=\"font-size: 16px;\">The statement that takes 1-1000ms is:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #f8f8f2\">result</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">sock</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">connect_ex((host,</span> <span style=\"color: #f8f8f2\">port))</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">In the C extension module, <code>Modules/socketmodule.c</code>, the function that implements the connection is:</p>\n<p style=\"font-size: 16px;\"><code>Modules/socketmodule.c</code> line 3246</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #66d9ef\">static</span><span style=\"color: #f8f8f2\"> </span><span style=\"color: #66d9ef\">int</span><span style=\"color: #f8f8f2\"></span>\n<span style=\"color: #a6e22e\">internal_connect</span><span style=\"color: #f8f8f2\">(PySocketSockObject </span><span style=\"color: #f92672\">*</span><span style=\"color: #f8f8f2\">s, </span><span style=\"color: #66d9ef\">struct</span><span style=\"color: #f8f8f2\"> </span><span style=\"color: #a6e22e\">sockaddr</span><span style=\"color: #f8f8f2\"> </span><span style=\"color: #f92672\">*</span><span style=\"color: #f8f8f2\">addr, </span><span style=\"color: #66d9ef\">int</span><span style=\"color: #f8f8f2\"> addrlen, </span><span style=\"color: #66d9ef\">int</span><span style=\"color: #f8f8f2\"> raise)</span>\n<span style=\"color: #f8f8f2\">{</span>\n<span style=\"color: #f8f8f2\">    </span><span style=\"color: #66d9ef\">int</span><span style=\"color: #f8f8f2\"> res, err, wait_connect;</span>\n<span style=\"color: #f8f8f2\">    </span>\n<span style=\"color: #f8f8f2\">    Py_BEGIN_ALLOW_THREADS</span>\n<span style=\"color: #f8f8f2\">    res </span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\"> connect(s</span><span style=\"color: #f92672\">-&gt;</span><span style=\"color: #f8f8f2\">sock_fd, addr, addrlen);</span>\n<span style=\"color: #f8f8f2\">    Py_END_ALLOW_THREADS</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">Surrounding the system <code>connect()</code> call are the <code>Py_BEGIN_ALLOW_THREADS</code> and <code>Py_END_ALLOW_THREADS</code> macros.</p>\n<p style=\"font-size: 16px;\">These macros are defined in <code>Include/ceval.h</code> as:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #75715e\">#define Py_BEGIN_ALLOW_THREADS {</span>\n<span style=\"color: #f8f8f2\">    PyThreadState </span><span style=\"color: #f92672\">*</span><span style=\"color: #f8f8f2\">_save;</span>\n<span style=\"color: #f8f8f2\">    _save </span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\"> PyEval_SaveThread();</span>\n<span style=\"color: #75715e\">#define Py_BLOCK_THREADS PyEval_RestoreThread(_save);</span>\n<span style=\"color: #75715e\">#define Py_UNBLOCK_THREADS _save = PyEval_SaveThread();</span>\n<span style=\"color: #75715e\">#define Py_END_ALLOW_THREADS PyEval_RestoreThread(_save);</span>\n<span style=\"color: #f8f8f2\">}</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">So, when <code>Py_BEGIN_ALLOW_THREADS</code> is called, it calls <a href=\"https://github.com/python/cpython/blob/v3.9.0b1/Python/ceval.c#L480\"><code>PyEval_SaveThread()</code></a>. This function changes the thread state to NULL and <strong>drops</strong> the GIL:</p>\n<p style=\"font-size: 16px;\"><code>Python/ceval.c</code> line 480</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #f8f8f2\">PyThreadState </span><span style=\"color: #f92672\">*</span><span style=\"color: #a6e22e\">PyEval_SaveThread</span><span style=\"color: #f8f8f2\">(</span><span style=\"color: #66d9ef\">void</span><span style=\"color: #f8f8f2\">)</span>\n<span style=\"color: #f8f8f2\">{</span>\n<span style=\"color: #f8f8f2\">    PyThreadState </span><span style=\"color: #f92672\">*</span><span style=\"color: #f8f8f2\">tstate </span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\"> PyThreadState_Swap(NULL);</span>\n<span style=\"color: #f8f8f2\">    </span><span style=\"color: #66d9ef\">if</span><span style=\"color: #f8f8f2\"> (tstate </span><span style=\"color: #f92672\">==</span><span style=\"color: #f8f8f2\"> NULL)</span>\n<span style=\"color: #f8f8f2\">    \tPy_FatalError(</span><span style=\"color: #e6db74\">&quot;PyEval_SaveThread: NULL tstate&quot;</span><span style=\"color: #f8f8f2\">);</span>\n<span style=\"color: #f8f8f2\">    assert(gil_created());</span>\n<span style=\"color: #f8f8f2\">    drop_gil(tstate);</span>\n<span style=\"color: #f8f8f2\">    </span><span style=\"color: #66d9ef\">return</span><span style=\"color: #f8f8f2\"> tstate;</span>\n<span style=\"color: #f8f8f2\">}</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">Because the GIL is dropped, it means any other executing thread can continue. This thread will sit and wait for the system call without blocking the evaluation loop.</p>\n<p style=\"font-size: 16px;\">Once the <code>connect()</code> function has succeeded or timed out, the <code>Py_END_ALLOW_THREADS</code> runs the <a href=\"https://github.com/python/cpython/blob/v3.9.0b1/Python/ceval.c#L503\">PyEval_RestoreThread()</a> function with the original thread state.</p>\n<p style=\"font-size: 16px;\">The thread state is recovered and the GIL is retaken. The call to <code>take_gil()</code> is a blocking call, waiting on a semaphore:</p>\n<p style=\"font-size: 16px;\"><code>Python/ceval.c</code> line 503</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #66d9ef\">void</span><span style=\"color: #f8f8f2\"></span>\n<span style=\"color: #a6e22e\">PyEval_RestoreThread</span><span style=\"color: #f8f8f2\">(PyThreadState </span><span style=\"color: #f92672\">*</span><span style=\"color: #f8f8f2\">tstate)</span>\n<span style=\"color: #f8f8f2\">{</span>\n<span style=\"color: #f8f8f2\">    </span><span style=\"color: #66d9ef\">if</span><span style=\"color: #f8f8f2\"> (tstate </span><span style=\"color: #f92672\">==</span><span style=\"color: #f8f8f2\"> NULL)</span>\n<span style=\"color: #f8f8f2\">    \tPy_FatalError(</span><span style=\"color: #e6db74\">&quot;PyEval_RestoreThread: NULL tstate&quot;</span><span style=\"color: #f8f8f2\">);</span>\n<span style=\"color: #f8f8f2\">    assert(gil_created());</span>\n<span style=\"color: #f8f8f2\">    </span>\n<span style=\"color: #f8f8f2\">    </span><span style=\"color: #66d9ef\">int</span><span style=\"color: #f8f8f2\"> err </span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\"> errno;</span>\n<span style=\"color: #f8f8f2\">    take_gil(tstate);</span>\n<span style=\"color: #f8f8f2\">    </span><span style=\"color: #75715e\">/* _Py_Finalizing is protected by the GIL */</span><span style=\"color: #f8f8f2\"></span>\n<span style=\"color: #f8f8f2\">    </span><span style=\"color: #66d9ef\">if</span><span style=\"color: #f8f8f2\"> (_Py_IsFinalizing() </span><span style=\"color: #f92672\">&amp;&amp;</span><span style=\"color: #f8f8f2\"> </span><span style=\"color: #f92672\">!</span><span style=\"color: #f8f8f2\">_Py_CURRENTLY_FINALIZING(tstate)) {</span>\n<span style=\"color: #f8f8f2\">        drop_gil(tstate);</span>\n<span style=\"color: #f8f8f2\">        PyThread_exit_thread();</span>\n<span style=\"color: #f8f8f2\">            Py_UNREACHABLE();</span>\n<span style=\"color: #f8f8f2\">    }</span>\n<span style=\"color: #f8f8f2\">    errno </span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\"> err;</span>\n<span style=\"color: #f8f8f2\">    </span>\n<span style=\"color: #f8f8f2\">    PyThreadState_Swap(tstate);</span>\n<span style=\"color: #f8f8f2\">}</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">This is not the only system call wrapped by the non-GIL-blocking pair <code>Py_BEGIN_ALLOW_THREADS</code> and <code>Py_END_ALLOW_THREADS</code>. There are over 300 uses of it in the Standard Library. Including:</p>\n<ul>\n<li>Making HTTP requests</li>\n<li>Interacting with local hardware</li>\n<li>Encryption</li>\n<li>Reading and writing files</li>\n</ul>\n<h4 id=thread-state>Thread State</h4>\n<p style=\"font-size: 16px;\">CPython provides its own implementation of thread management. Because threads need to execute Python bytecode in the evaluation loop, running a thread in CPython isn’t as simple as spawning an OS thread. Python threads are called PyThread, and you covered them briefly on the CPython Evaluation Loop chapter.</p>\n<p style=\"font-size: 16px;\">Python threads execute code objects and are spawned by the interpreter.</p>\n<p style=\"font-size: 16px;\">To recap:</p>\n<ul>\n<li>CPython has a single runtime, which has its own <strong>runtime state</strong></li>\n<li>CPython can have one or many interpreters</li>\n<li>An interpreter has a state, called the <strong>interpreter state</strong></li>\n<li>An interpreter will take a <strong>code object</strong> and convert it into a series of <strong>frame objects</strong></li>\n<li>An interpreter has at least one <strong>thread</strong>, each thread has a <strong>thread state</strong></li>\n<li>Frame Objects are executed in a stack, called the <strong>frame stack</strong></li>\n<li>CPython references variables in a <strong>value stack</strong></li>\n<li>The <strong>interpreter state</strong> includes a linked-list of its threads</li>\n</ul>\n<p style=\"font-size: 16px;\">A single-threaded, single-interpreter runtime would have the states:</p>\n<p style=\"font-size: 16px;\"><center><img src=\"/media/post/python_internals/75.png\" alt=\"75\" /></center></p>\n<p style=\"font-size: 16px;\">The thread state type, <code>PyThreadState</code> has over 30 properties, including:</p>\n<ul>\n<li>A unique identifier</li>\n<li>A linked-list to the other thread states</li>\n<li>The interpreter state it was spawned by</li>\n<li>The currently executing frame</li>\n<li>The current recursion depth</li>\n<li>Optional tracing functions</li>\n<li>The exception currently being handled</li>\n<li>Any async exception currently being handled</li>\n<li>A stack of exceptions raised</li>\n<li>A GIL counter</li>\n<li>Async generator counters</li>\n</ul>\n<p style=\"font-size: 16px;\">Similar to the multiprocessing <strong>preparation data</strong>, threads have a boot state. However, threads share the same memory space, so there is no need to serialize data and send it over a file stream.</p>\n<p style=\"font-size: 16px;\">Threads are instantiated with the <code>threading.Thread</code> type. This is a highlevel module that abstracts the <code>PyThread</code> type. <code>PyThread</code> instances are managed by the C extension module <code>_thread</code>.</p>\n<p style=\"font-size: 16px;\">The <code>_thread</code> module has the entry point for executing a new thread, <a href=\"https://github.com/python/cpython/blob/v3.9.0b1/Modules/_threadmodule.c#L1063\"><code>thread_PyThread_start_new_thread()</code></a>. <code>start_new_thread()</code> is a method on an instance of the type <code>Thread</code>.</p>\n<p style=\"font-size: 16px;\">New threads are instantiated in this sequence:</p>\n<ul>\n<li>The <code>bootstate</code> is created, linking to the <code>target</code>, with arguments <code>args</code> and <code>kwargs</code></li>\n<li>The <code>bootstate</code> is linked to the interpreter state</li>\n<li>A new <code>PyThreadState</code> is created, linking to the current interpreter</li>\n<li>The GIL is enabled, if not already with a call to <a href=\"https://github.com/python/cpython/blob/v3.9.0b1/Python/ceval.c#L338\"><code>PyEval_InitThreads()</code></a></li>\n<li>The new thread is started on the Operating System-specific implementation of <code>PyThread_start_new_thread</code></li>\n</ul>\n<p style=\"font-size: 16px;\"><center><img src=\"/media/post/python_internals/76.png\" alt=\"76\" /></center></p>\n<p style=\"font-size: 16px;\">Thread <code>bootstate</code> has the properties:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Purpose</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>interp</code></td>\n<td align=\"left\"><code>PyInterpreterState*</code></td>\n<td align=\"left\">Link to the interpreter managing this thread</td>\n</tr>\n<tr>\n<td align=\"left\"><code>func</code></td>\n<td align=\"left\"><code>PyObject *</code></td>\n<td align=\"left\">Link to the <code>callable</code> to execute upon running the thread</td>\n</tr>\n<tr>\n<td align=\"left\"><code>args</code></td>\n<td align=\"left\"><code>PyObject *(tuple)</code></td>\n<td align=\"left\">Arguments to call <code>func</code> with</td>\n</tr>\n<tr>\n<td align=\"left\"><code>key</code></td>\n<td align=\"left\"><code>PyObject * (dict)</code></td>\n<td align=\"left\">Keyword arguments to call <code>func</code> with</td>\n</tr>\n<tr>\n<td align=\"left\"><code>tstate</code></td>\n<td align=\"left\"><code>PyThreadState *</code></td>\n<td align=\"left\">Thread state for the new thread</td>\n</tr>\n</tbody>\n</table>\n<p style=\"font-size: 16px;\">With the thread bootstate, there are two implementations <code>PyThread</code> - POSIX threads for Linux and macOS, and NT threads for Windows.</p>\n<p style=\"font-size: 16px;\">Both of these implementations create the Operating System thread, set it’s attribute and then execute the callback <a href=\"https://github.com/python/cpython/blob/v3.9.0b1/Modules/_threadmodule.c#L1029\"><code>t_bootstrap()</code></a> from within the new thread. This function is called with the single argument boot_raw, assigned to the bootstate constructed in <a href=\"https://github.com/python/cpython/blob/v3.9.0b1/Modules/_threadmodule.c#L1063\"><code>thread_PyThread_start_new_thread()</code></a>.</p>\n<p style=\"font-size: 16px;\">The <a href=\"https://github.com/python/cpython/blob/v3.9.0b1/Modules/_threadmodule.c#L1029\"><code>t_bootstrap()</code></a> function is the interface between a low-level thread and the Python runtime. The bootstrap will initiatilize the thread, then execute the <code>target</code> callable using <a href=\"https://github.com/python/cpython/blob/v3.9.0b1/Objects/call.c#L289\"><code>PyObject_Call()</code></a>. Once the callable target has been executed, the thread will exit:</p>\n<p style=\"font-size: 16px;\"><center><img src=\"/media/post/python_internals/77.png\" alt=\"77\" /></center></p>\n<h4 id=posix-threads>POSIX Threads</h4>\n<p style=\"font-size: 16px;\">POSIX threads, named pthreads, have an implementation in <code>Python/thread_pthread.h</code>. This implementation abstracts the <code>pthread.h</code>  C API with some additional safeguards and optimizations.</p>\n<p style=\"font-size: 16px;\">Threads can have a configured stack size. Python has it’s own stack frame construct, as you explored in the chapter on the Evaluation Loop. If there is an issue causing a recursive loop, and the frame execution hits the depth limit, Python will raise a <code>RecursionError</code> which can be handled from a <code>try..except</code> block in Python code. Because pthreads have their own stack size, the max depth of Python and the stack size of the pthread might conflict.</p>\n<p style=\"font-size: 16px;\">If the thread stack size is smaller than the max frame depth in Python, the entire Python process will crash before a <code>RecursionError</code> is raised. Also, the max depth in Python can be configured at runtime using <a href=\"https://docs.python.org/3/library/sys.html#sys.setrecursionlimit\"><code>sys.setrecursionlimit()</code></a>.</p>\n<p style=\"font-size: 16px;\">To avoid these crashes, the CPython pthread implementation sets the stack size to the <code>pythread_stacksize</code> value of the Interpreter State</p>\n<p style=\"font-size: 16px;\">Most modern POSIX-compliant Operating Systems support system scheduling of pthreads. If <code>PTHREAD_SYSTEM_SCHED_SUPPORTED</code> is defined in <code>pyconfig.h</code>, the pthread is set to <code>PTHREAD_SCOPE_SYSTEM</code>, meaning that the priority of the thread on the Operating System scheduler is decided against the other threads on the system, not just the ones within the Python process.</p>\n<p style=\"font-size: 16px;\">Once the thread properties have been configured, the thread is created using the <code>pthread_create()</code> API. This runs the bootstrap function from inside the new thread.</p>\n<p style=\"font-size: 16px;\">Lastly, the thread handle, <code>pthread_t</code> is cast into an <code>unsigned long</code> and returned to become the thread ID.</p>\n<h4 id=windows-threads>Windows Threads</h4>\n<p style=\"font-size: 16px;\">Windows threads implemented in <code>Python/thread_nt.h</code> follow a similar, but simpler pattern. The stack size of the new thread is configured to the interpreter <code>pythread_stacksize</code> value (if set). The thread is created using the <a href=\"https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/beginthread-beginthreadex?view=vs-2019\"><code>_beginthreadex()</code> Windows API</a> using the bootstrap function as the callback.</p>\n<p style=\"font-size: 16px;\">Lastly, the thread ID is returned.</p>\n<h4 id=conclusion>Conclusion</h4>\n<p style=\"font-size: 16px;\">This was not an exhaustive tutorial on Python threads. Python’s thread implementation is extensive and offers many mechanisms for sharing data between threads, locking objects, and resources.</p>\n<p style=\"font-size: 16px;\">Threads are a great, efficient way of improving the runtime of your Python applications when they are IO-bound. In this section, you have seen what the GIL is, why it exists and which parts of the standard library may be exempt from its constraints.</p>\n<h2 id=asynchronous-programming>Asynchronous Programming</h2>\n<p style=\"font-size: 16px;\">Python offers many ways of accomplishing concurrent programming without using threads or multiprocessing. These features have been added, expanded, and often replaced with better alternatives.</p>\n<p style=\"font-size: 16px;\">For the target version of this book, 3.9.0b1, the following asynchronous systems are deprecated:</p>\n<ul>\n<li>The <code>@coroutine</code> decorator</li>\n</ul>\n<p style=\"font-size: 16px;\">The following systems are still available:</p>\n<ul>\n<li>Creating futures from <code>async</code> keywords</li>\n<li>Coroutines using the <code>yield from</code> keywords</li>\n</ul>\n<h2 id=generators>Generators</h2>\n<p style=\"font-size: 16px;\">Python Generators are functions that return a yield statement and can be called continually to generate further values.</p>\n<p style=\"font-size: 16px;\">Generators are often used as a more memory efficient way of looping through values in a large block of data, like a file, a database, or over a network. Generator objects are returned in place of a <strong>value</strong> when <code>yield</code> is used instead of <code>return</code>. The generator object is created from the <code>yield</code> statement and returned to the caller.</p>\n<p style=\"font-size: 16px;\">This simple generator function will yield the letters a-z:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #66d9ef\">def</span> <span style=\"color: #a6e22e\">letters</span><span style=\"color: #f8f8f2\">():</span>\n    <span style=\"color: #f8f8f2\">i</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #ae81ff\">97</span> <span style=\"color: #75715e\"># letter &#39;a&#39; in ASCII</span>\n    <span style=\"color: #f8f8f2\">end</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #ae81ff\">97</span> <span style=\"color: #f92672\">+</span> <span style=\"color: #ae81ff\">26</span> <span style=\"color: #75715e\"># letter &#39;z&#39; in ASCII</span>\n    <span style=\"color: #66d9ef\">while</span> <span style=\"color: #f8f8f2\">i</span> <span style=\"color: #f92672\">&lt;</span> <span style=\"color: #f8f8f2\">end:</span>\n        <span style=\"color: #66d9ef\">yield</span> <span style=\"color: #f8f8f2\">chr(i)</span>\n        <span style=\"color: #f8f8f2\">i</span> <span style=\"color: #f92672\">+=</span> <span style=\"color: #ae81ff\">1</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">If you call <code>letters()</code>, it won’t return a value, but instead it returns a generator object:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #f92672\">&gt;&gt;&gt;</span> <span style=\"color: #f92672\">from</span> <span style=\"color: #f8f8f2\">letter_generator</span> <span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">letters</span>\n<span style=\"color: #f92672\">&gt;&gt;&gt;</span> <span style=\"color: #f8f8f2\">letters()</span>\n<span style=\"color: #f92672\">&lt;</span><span style=\"color: #f8f8f2\">generator</span> <span style=\"color: #f8f8f2\">object</span> <span style=\"color: #f8f8f2\">letters</span> <span style=\"color: #f8f8f2\">at</span> <span style=\"color: #ae81ff\">0x1004d39b0</span><span style=\"color: #f92672\">&gt;</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">Built into the syntax of the <code>for</code> statement is the ability to iterate through a generator object until it stops yielding values:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #f92672\">&gt;&gt;&gt;</span> <span style=\"color: #66d9ef\">for</span> <span style=\"color: #f8f8f2\">letter</span> <span style=\"color: #f92672\">in</span> <span style=\"color: #f8f8f2\">letters():</span>\n<span style=\"color: #f92672\">...</span> \t<span style=\"color: #f8f8f2\">print(letter)</span>\n<span style=\"color: #f8f8f2\">a</span>\n<span style=\"color: #f8f8f2\">b</span>\n<span style=\"color: #f8f8f2\">c</span>\n<span style=\"color: #f8f8f2\">d</span>\n<span style=\"color: #f92672\">...</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">This implementation uses the iterator protocol. Objects that have a <code>__next__()</code>method can be looped over by <code>for</code> and <code>while</code> loops, or using the <code>next()</code> builtin.</p>\n<p style=\"font-size: 16px;\">All container types (like lists, sets, tuples) in Python implement the iterator protocol. Generators are unique because the implementation of the <code>__next__()</code> method recalls the generator function from its last state. Generators are not executing in the background, they are paused. When you request another value, they resume execution.</p>\n<p style=\"font-size: 16px;\">Within the generator object structure is the frame object as it was at the last <code>yield</code> statement.</p>\n<h4 id=generator-structure>Generator Structure</h4>\n<p style=\"font-size: 16px;\">Generator objects are created by a template macro, <code>PyGenObject_HEAD</code>(prefix).</p>\n<p style=\"font-size: 16px;\">This macro is used by the following types and prefixes:</p>\n<ul>\n<li><code>PyGenObject</code> - <code>gi_</code> (Generator objects)</li>\n<li><code>PyCoroObject</code> - <code>cr_</code> (Coroutine objects)</li>\n<li><code>PyAsyncGenObject</code> - <code>ag_</code> (Async generator objects)</li>\n</ul>\n<p style=\"font-size: 16px;\">You will cover coroutine and async generator objects later in this chapter.</p>\n<p style=\"font-size: 16px;\">The <code>PyGenObject</code> type has the base properties:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Purpose</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>[x]_frame</code></td>\n<td align=\"left\"><code>PyFrameObject*</code></td>\n<td align=\"left\">Current frame object for the generator</td>\n</tr>\n<tr>\n<td align=\"left\"><code>[x]_running</code></td>\n<td align=\"left\"><code>char</code></td>\n<td align=\"left\">char Set to 0 or 1 if the generator is currently runing</td>\n</tr>\n<tr>\n<td align=\"left\"><code>[x]_code</code></td>\n<td align=\"left\"><code>PyObject *</code> <code>(PyCodeObject*)</code></td>\n<td align=\"left\">Compiled function that yielded the generator</td>\n</tr>\n<tr>\n<td align=\"left\"><code>[x]_weakreflist</code></td>\n<td align=\"left\"><code>PyObject *(list)</code></td>\n<td align=\"left\">List of weak references to objects inside the generator function</td>\n</tr>\n<tr>\n<td align=\"left\"><code>[x]_name</code></td>\n<td align=\"left\"><code>PyObject * (str)</code></td>\n<td align=\"left\">Name of the generator</td>\n</tr>\n<tr>\n<td align=\"left\"><code>[x]_qualname</code></td>\n<td align=\"left\"><code>PyObject * (str)</code></td>\n<td align=\"left\">Qualified name of the generator</td>\n</tr>\n<tr>\n<td align=\"left\"><code>[x]_exc_state</code></td>\n<td align=\"left\"><code>_PyErr_StackItem</code></td>\n<td align=\"left\">Exception data if the generator call raises an exception</td>\n</tr>\n</tbody>\n</table>\n<p style=\"font-size: 16px;\">On top of the base properties, the <code>PyCoroObject</code> type has:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Purpose</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>cr_origin</code></td>\n<td align=\"left\"><code>PyObject * (tuple)</code></td>\n<td align=\"left\">Tuple containing the originating frame and caller</td>\n</tr>\n</tbody>\n</table>\n<p style=\"font-size: 16px;\">On top of the base properties, the <code>PyAsyncGenObject</code> type has:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Field</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Purpose</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>ag_finalizer</code></td>\n<td align=\"left\"><code>PyObject *</code></td>\n<td align=\"left\">Link to the finalizer method</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ag_hooks_inited</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">Flag to mark that the hooks have been initialized</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ag_closed</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">Flag to mark that the generator is closed</td>\n</tr>\n<tr>\n<td align=\"left\"><code>ag_running_async</code></td>\n<td align=\"left\"><code>int</code></td>\n<td align=\"left\">Flag to mark that the generator is running</td>\n</tr>\n</tbody>\n</table>\n<h4 id=related-source-file>Related Source File</h4>\n<p style=\"font-size: 16px;\">Source files related to generators are:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">File</th>\n<th align=\"left\">Purpose</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>Include/genobject.h</code></td>\n<td align=\"left\">Generator API and <code>PyGenObject</code> definition</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Objects/genobject.c</code></td>\n<td align=\"left\">Generator Object implementation</td>\n</tr>\n</tbody>\n</table>\n<h4 id=creating-generators>Creating Generators</h4>\n<p style=\"font-size: 16px;\">When a function containing a <code>yield</code> statement is compiled, the resulting code object has an additional flag, <code>CO_GENERATOR</code>.</p>\n<p style=\"font-size: 16px;\">In the chapter on the Execution Loop: Constructing Frames, you explored how a compiled code object is converted into a frame object when it is executed. In the process, there is a special case for generators, coroutines, and async generators. The <a href=\"https://github.com/python/cpython/blob/v3.9.0b1/Python/ceval.c#L4101\"><code>_PyEval_EvalCode()</code></a> function checks the code object for the <code>CO_GENERATOR</code>, <code>CO_COROUTINE</code>, and <code>CO_ASYNC_GENERATOR</code> flags.</p>\n<p style=\"font-size: 16px;\">Instead of evaluation a code object inline, the frame is created and turned into a Generator, Coroutine or Async Generator Object. A coroutine is created using <a href=\"https://github.com/python/cpython/blob/v3.9.0b1/Objects/genobject.c#L1135\"><code>PyCoro_New()</code></a>, an async generator is created with <a href=\"https://github.com/python/cpython/blob/v3.9.0b1/Objects/genobject.c#L1414\"><code>PyAsyncGen_New()</code></a>, and a generator with <a href=\"https://github.com/python/cpython/blob/v3.9.0b1/Objects/genobject.c#L810\"><code>PyGen_NewWithQualName()</code></a>:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #f8f8f2\">PyObject </span><span style=\"color: #f92672\">*</span><span style=\"color: #f8f8f2\"></span>\n<span style=\"color: #a6e22e\">_PyEval_EvalCode</span><span style=\"color: #f8f8f2\">(PyObject </span><span style=\"color: #f92672\">*</span><span style=\"color: #f8f8f2\">_co, PyObject </span><span style=\"color: #f92672\">*</span><span style=\"color: #f8f8f2\">globals, PyObject </span><span style=\"color: #f92672\">*</span><span style=\"color: #f8f8f2\">locals, ...</span>\n<span style=\"color: #f8f8f2\">...</span>\n<span style=\"color: #f8f8f2\">    </span><span style=\"color: #75715e\">/* Handle generator/coroutine/asynchronous generator */</span><span style=\"color: #f8f8f2\"></span>\n<span style=\"color: #f8f8f2\">    </span><span style=\"color: #66d9ef\">if</span><span style=\"color: #f8f8f2\"> (co</span><span style=\"color: #f92672\">-&gt;</span><span style=\"color: #f8f8f2\">co_flags </span><span style=\"color: #f92672\">&amp;</span><span style=\"color: #f8f8f2\"> (CO_GENERATOR </span><span style=\"color: #f92672\">|</span><span style=\"color: #f8f8f2\"> CO_COROUTINE </span><span style=\"color: #f92672\">|</span><span style=\"color: #f8f8f2\"> CO_ASYNC_GENERATOR)) {</span>\n<span style=\"color: #f8f8f2\">        PyObject </span><span style=\"color: #f92672\">*</span><span style=\"color: #f8f8f2\">gen;</span>\n<span style=\"color: #f8f8f2\">        PyObject </span><span style=\"color: #f92672\">*</span><span style=\"color: #f8f8f2\">coro_wrapper </span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\"> tstate</span><span style=\"color: #f92672\">-&gt;</span><span style=\"color: #f8f8f2\">coroutine_wrapper;</span>\n<span style=\"color: #f8f8f2\">        </span><span style=\"color: #66d9ef\">int</span><span style=\"color: #f8f8f2\"> is_coro </span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\"> co</span><span style=\"color: #f92672\">-&gt;</span><span style=\"color: #f8f8f2\">co_flags </span><span style=\"color: #f92672\">&amp;</span><span style=\"color: #f8f8f2\"> CO_COROUTINE;</span>\n<span style=\"color: #f8f8f2\">        ...</span>\n<span style=\"color: #f8f8f2\">        </span><span style=\"color: #75715e\">/* Create a new generator that owns the ready to run frame</span>\n<span style=\"color: #75715e\">        * and return that as the value. */</span><span style=\"color: #f8f8f2\"></span>\n<span style=\"color: #f8f8f2\">        </span><span style=\"color: #66d9ef\">if</span><span style=\"color: #f8f8f2\"> (is_coro) {</span>\n<span style=\"color: #f92672\">&gt;&gt;&gt;</span><span style=\"color: #f8f8f2\"> \t\tgen </span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\"> PyCoro_New(f, name, qualname);</span>\n<span style=\"color: #f8f8f2\">        } </span><span style=\"color: #66d9ef\">else</span><span style=\"color: #f8f8f2\"> </span><span style=\"color: #66d9ef\">if</span><span style=\"color: #f8f8f2\"> (co</span><span style=\"color: #f92672\">-&gt;</span><span style=\"color: #f8f8f2\">co_flags </span><span style=\"color: #f92672\">&amp;</span><span style=\"color: #f8f8f2\"> CO_ASYNC_GENERATOR) {</span>\n<span style=\"color: #f92672\">&gt;&gt;&gt;</span><span style=\"color: #f8f8f2\"> \t\tgen </span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\"> PyAsyncGen_New(f, name, qualname);</span>\n<span style=\"color: #f8f8f2\">        } </span><span style=\"color: #66d9ef\">else</span><span style=\"color: #f8f8f2\"> {</span>\n<span style=\"color: #f92672\">&gt;&gt;&gt;</span><span style=\"color: #f8f8f2\"> \t\tgen </span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\"> PyGen_NewWithQualName(f, name, qualname);</span>\n<span style=\"color: #f8f8f2\">        }</span>\n<span style=\"color: #f8f8f2\">        ...</span>\n<span style=\"color: #f8f8f2\">        </span><span style=\"color: #66d9ef\">return</span><span style=\"color: #f8f8f2\"> gen;</span>\n<span style=\"color: #f8f8f2\">    }</span>\n<span style=\"color: #f8f8f2\">...</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">The generator factory, <a href=\"https://github.com/python/cpython/blob/v3.9.0b1/Objects/genobject.c#L810\"><code>PyGen_NewWithQualName()</code></a>, takes the frame and completes some steps to populate the generator object fields:</p>\n<ul>\n<li>Sets the gi_code property to the compiled code object</li>\n<li>Sets the generator to not running (<code>gi_running = 0</code>)</li>\n<li>Sets the exception and weakref lists to <code>NULL</code></li>\n</ul>\n<p style=\"font-size: 16px;\">You can also see that <code>gi_code</code> is the compiled code object for the generator function by importing the <code>dis</code> module and disassembling the bytecode inside:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #f92672\">&gt;&gt;&gt;</span> <span style=\"color: #f92672\">from</span> <span style=\"color: #f8f8f2\">letter_generator</span> <span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">letters</span>\n<span style=\"color: #f92672\">&gt;&gt;&gt;</span> <span style=\"color: #f8f8f2\">gen</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">letters()</span>\n<span style=\"color: #f92672\">&gt;&gt;&gt;</span> <span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">dis</span>\n<span style=\"color: #f92672\">&gt;&gt;&gt;</span> <span style=\"color: #f8f8f2\">dis</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">disco(gen</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">gi_code)</span>\n<span style=\"color: #ae81ff\">2</span> \t\t\t<span style=\"color: #ae81ff\">0</span> <span style=\"color: #f8f8f2\">LOAD_CONST</span> \t\t<span style=\"color: #ae81ff\">1</span> <span style=\"color: #f8f8f2\">(</span><span style=\"color: #ae81ff\">97</span><span style=\"color: #f8f8f2\">)</span>\n\t\t\t<span style=\"color: #ae81ff\">2</span> <span style=\"color: #f8f8f2\">STORE_FAST</span> \t\t<span style=\"color: #ae81ff\">0</span> <span style=\"color: #f8f8f2\">(i)</span>\n<span style=\"color: #f92672\">...</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">In the chapter on the Evaluation Loop, you explored the Frame Object Type. Frame objects contain locals and globals, the last executed instructions, and the code to be executed.</p>\n<p style=\"font-size: 16px;\">The builtin behavior and state of the frame object are how generators can <em>pause</em> and be <em>resumed</em> on demand.</p>\n<h4 id=executing-generators>Executing Generators</h4>\n<p style=\"font-size: 16px;\">Whenever <code>__next__()</code> is called on a generator object, <a href=\"https://github.com/python/cpython/blob/v3.9.0b1/Objects/genobject.c#L540\"><code>gen_iternext()</code></a> is called with the generator instance, which immediately calls <a href=\"https://github.com/python/cpython/blob/v3.9.0b1/Objects/genobject.c#L140\"><code>gen_send_ex()</code></a> inside <code>Objects/genobject.c</code>.</p>\n<p style=\"font-size: 16px;\"><a href=\"https://github.com/python/cpython/blob/v3.9.0b1/Objects/genobject.c#L140\"><code>gen_send_ex()</code></a> is the function that converts a generator object into the next yielded result. You’ll see many similarities with the way frames are constructed from a code object as these functions have similar tasks.</p>\n<p style=\"font-size: 16px;\">The <a href=\"https://github.com/python/cpython/blob/v3.9.0b1/Objects/genobject.c#L140\"><code>gen_send_ex()</code></a> function is shared with generators, coroutines, and async generators and has the following steps:</p>\n<ul>\n<li>The current thread state is fetched</li>\n<li>The frame object from the generator object is fetched</li>\n<li>If the generator is running when <code>__next__()</code> was called, raise a <code>ValueError</code></li>\n<li>If the frame inside the generator is at the top of the stack:\n<ul>\n<li>In the case of a coroutine, if the coroutine is not already marked as closing, a <code>RuntimeError</code> is raised</li>\n<li>If this is an async generator, raise a <code>StopAsyncIteration</code></li>\n<li>For a standard generator, a <code>StopIteration</code> is raised.</li>\n</ul>\n</li>\n<li>If the last instruction in the frame (<code>f-&gt;f_lasti</code>) is still -1 because it has just been started, and this is a coroutine or async generator, then a non-None value can’t be passed as an argument, so an exception is raised</li>\n<li>Else, this is the first time it’s being called, and arguments are allowed. The value of the argument is pushed to the frame’s value stack</li>\n<li>The <code>f_back</code> field of the frame is the caller to which return values are sent, so this is set to the current frame in the thread. This means that the return value is sent to the caller, not the creator of the generator</li>\n<li>The generator is marked as running</li>\n<li>The last exception in the generator’s exception info is copied from the last exception in the thread state</li>\n<li>The thread state exception info is set to the address of the generator’s exception info. This means that if the caller enters a breakpoint around the execution of a generator, the stack trace goes through the generator and the offending code is clear</li>\n<li>The frame inside the generator is executed within the <code>Python/ceval.c</code> main execution loop, and the value returned</li>\n<li>The thread state last exception is reset to the value before the frame was called</li>\n<li>The generator is marked as not running</li>\n<li>The following cases then match the return value and any exceptions thrown by the call to the generator. Remember that generators should raise a <code>StopIteration</code> when they are exhausted, either manually, or by not yielding a value. Coroutines and async generators should not:\n<ul>\n<li>If no result was returned from the frame, raise a <code>StopIteration</code> for generators and <code>StopAsyncIteration</code> for async generators</li>\n<li>If a <code>StopIteration</code> was explicitly raised, but this is a coroutine or an async generator, raise a <code>RuntimeError</code> as this is not allowed</li>\n<li>If a <code>StopAsyncIteration</code> was explicitly raised and this is an async generator, raise a <code>RuntimeError</code>, as this is not allowed</li>\n</ul>\n</li>\n<li>Lastly, the result is returned back to the caller of <code>__next__()</code></li>\n</ul>\n<p style=\"font-size: 16px;\">Bringing this all together, you can see how the generator expression is a powerful syntax where a single keyword, <code>yield</code> triggers a whole flow to create a unique object, copy a compiled code object as a property, set a frame, and store a list of variables in the local scope.</p>\n<h2 id=coroutines>Coroutines</h2>\n<p style=\"font-size: 16px;\">Generators have a big limitation. They can only yield values to their immediate caller. An additional syntax was added to Python to overcome this the <code>yield from</code> statement. Using this syntax, you can refactor generators into utility functions and then <code>yield from</code> them.</p>\n<p style=\"font-size: 16px;\">For example, the letter generator can be refactored into a utility function where the starting letter is an argument. Using <code>yield from</code>, you can choose which generator object to return:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #66d9ef\">def</span> <span style=\"color: #a6e22e\">gen_letters</span><span style=\"color: #f8f8f2\">(start,</span> <span style=\"color: #f8f8f2\">x):</span>\n    <span style=\"color: #f8f8f2\">i</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">start</span>\n    <span style=\"color: #f8f8f2\">end</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">start</span> <span style=\"color: #f92672\">+</span> <span style=\"color: #f8f8f2\">x</span>\n    <span style=\"color: #66d9ef\">while</span> <span style=\"color: #f8f8f2\">i</span> <span style=\"color: #f92672\">&lt;</span> <span style=\"color: #f8f8f2\">end:</span>\n        <span style=\"color: #66d9ef\">yield</span> <span style=\"color: #f8f8f2\">chr(i)</span>\n        <span style=\"color: #f8f8f2\">i</span> <span style=\"color: #f92672\">+=</span> <span style=\"color: #ae81ff\">1</span>\n\n<span style=\"color: #66d9ef\">def</span> <span style=\"color: #a6e22e\">letters</span><span style=\"color: #f8f8f2\">(upper):</span>\n    <span style=\"color: #66d9ef\">if</span> <span style=\"color: #f8f8f2\">upper:</span>\n    \t<span style=\"color: #66d9ef\">yield from</span> <span style=\"color: #f8f8f2\">gen_letters(</span><span style=\"color: #ae81ff\">65</span><span style=\"color: #f8f8f2\">,</span> <span style=\"color: #ae81ff\">26</span><span style=\"color: #f8f8f2\">)</span> <span style=\"color: #75715e\"># A-Z</span>\n    <span style=\"color: #66d9ef\">else</span><span style=\"color: #f8f8f2\">:</span>\n    \t<span style=\"color: #66d9ef\">yield from</span> <span style=\"color: #f8f8f2\">gen_letters(</span><span style=\"color: #ae81ff\">97</span><span style=\"color: #f8f8f2\">,</span> <span style=\"color: #ae81ff\">26</span><span style=\"color: #f8f8f2\">)</span> <span style=\"color: #75715e\"># a-z</span>\n\n<span style=\"color: #66d9ef\">for</span> <span style=\"color: #f8f8f2\">letter</span> <span style=\"color: #f92672\">in</span> <span style=\"color: #f8f8f2\">letters(</span><span style=\"color: #66d9ef\">False</span><span style=\"color: #f8f8f2\">):</span>\n    <span style=\"color: #75715e\"># Lower case a-z</span>\n    <span style=\"color: #f8f8f2\">print(letter)</span>\n\n<span style=\"color: #66d9ef\">for</span> <span style=\"color: #f8f8f2\">letter</span> <span style=\"color: #f92672\">in</span> <span style=\"color: #f8f8f2\">letters(</span><span style=\"color: #66d9ef\">True</span><span style=\"color: #f8f8f2\">):</span>\n    <span style=\"color: #75715e\"># Upper case A-Z</span>\n    <span style=\"color: #f8f8f2\">print(letter)</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">Generators are also great for lazy sequences, where they can be called multiple times. Building on the behaviors of generators, such as being able to pause and resume execution, the concept of a coroutine was iterated in Python over multiple APIs. Generators are a limited form of coroutine because you can send data to them using the <code>.send()</code> method.</p>\n<p style=\"font-size: 16px;\">It is possible to send messages bi-directionally between the caller and the target. Coroutines also store the caller in the <code>cr_origin</code> attribute.</p>\n<p style=\"font-size: 16px;\">Coroutines were initially available via a decorator, but this has since been deprecated in favor of “native” coroutines using the keywords <code>async</code> and <code>await</code>.</p>\n<p style=\"font-size: 16px;\">To mark that a function returns a coroutine, it must be preceded with the <code>async</code> keyword. The async keyword makes it explicit (unlike generators) that this function returns a coroutine and not a value.</p>\n<p style=\"font-size: 16px;\">To create a coroutine, define a function with the keyword <code>async def</code>. In this example, add a timer using the <code>asyncio.sleep()</code> function and return a wake-up string:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #f92672\">&gt;&gt;&gt;</span> <span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">asyncio</span>\n<span style=\"color: #f92672\">&gt;&gt;&gt;</span> <span style=\"color: #66d9ef\">async</span> <span style=\"color: #66d9ef\">def</span> <span style=\"color: #a6e22e\">sleepy_alarm</span><span style=\"color: #f8f8f2\">(time):</span>\n<span style=\"color: #f92672\">...</span> \t<span style=\"color: #66d9ef\">await</span> <span style=\"color: #f8f8f2\">asyncio</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">sleep(time)</span>\n<span style=\"color: #f92672\">...</span> \t<span style=\"color: #66d9ef\">return</span> <span style=\"color: #e6db74\">&quot;wake up!&quot;</span>\n<span style=\"color: #f92672\">&gt;&gt;&gt;</span> <span style=\"color: #f8f8f2\">alarm</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">sleepy_alarm(</span><span style=\"color: #ae81ff\">10</span><span style=\"color: #f8f8f2\">)</span>\n<span style=\"color: #f92672\">&gt;&gt;&gt;</span> <span style=\"color: #f8f8f2\">alarm</span>\n<span style=\"color: #f92672\">&lt;</span><span style=\"color: #f8f8f2\">coroutine</span> <span style=\"color: #f8f8f2\">object</span> <span style=\"color: #f8f8f2\">sleepy_alarm</span> <span style=\"color: #f8f8f2\">at</span> <span style=\"color: #ae81ff\">0x1041de340</span><span style=\"color: #f92672\">&gt;</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">When you call the function, it returns a coroutine object. There are many ways to execute a coroutine. The easiest is using <code>asyncio.run(coro)</code>.</p>\n<p style=\"font-size: 16px;\">Run <code>asyncio.run()</code> with your coroutine object, then after 10 seconds it will sound the alarm:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #f92672\">&gt;&gt;&gt;</span> <span style=\"color: #f8f8f2\">asyncio</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">run(alarm)</span>\n<span style=\"color: #e6db74\">&#39;wake up&#39;</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">So far, there is a small benefit over a regular function. The benefit of coroutines is that you can run them concurrently. Because the coroutine object is a variable that you can pass to a function, these objects can be linked together and chained, or created in a sequence.</p>\n<p style=\"font-size: 16px;\">For example, if you wanted to have 10 alarms with different intervals and start them all at the same time, these coroutine objects can be converted into tasks.</p>\n<p style=\"font-size: 16px;\">The task API is used to schedule and execute multiple coroutines concurrently. Before tasks are scheduled, an event loop must be running. The job of the event loop is to schedule concurrent tasks and connect events such as completion, cancellation, and exceptions with callbacks. When you called <code>asyncio.run()</code>, the run function (in <code>Lib/asyncio/runners.py</code>) did these tasks for you:</p>\n<ul>\n<li>Started a new event loop</li>\n<li>Wrapped the coroutine object in a task</li>\n<li>Set a callback on the completion of the task</li>\n<li>Looped over the task until it completed</li>\n<li>Returned the result</li>\n</ul>\n<h4 id=related-source-files>Related Source Files</h4>\n<p style=\"font-size: 16px;\">Source files related to coroutines are:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">File</th>\n<th align=\"left\">Purpose</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>Lib/asyncio</code></td>\n<td align=\"left\">Python standard library implementation for asyncio</td>\n</tr>\n</tbody>\n</table>\n<h4 id=event-loops>Event Loops</h4>\n<p style=\"font-size: 16px;\">Event loops are the glue that holds async code together. Written in pure Python, event loops are an object containing tasks. When started, a loop can either run once or run forever. Any of the tasks in the loop can have callbacks. The loop will run the callbacks if a task completes or fails.</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #f8f8f2\">loop</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">asyncio</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">new_event_loop()</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">Inside a loop is a sequence of tasks, represented by the type <code>asyncio.Task</code>, tasks are scheduled onto a loop, then once the loop is running, it loops over all the tasks until they complete.</p>\n<p style=\"font-size: 16px;\">You can convert the single timer into a task loop:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">asyncio</span>\n\n<span style=\"color: #66d9ef\">async</span> <span style=\"color: #66d9ef\">def</span> <span style=\"color: #a6e22e\">sleepy_alarm</span><span style=\"color: #f8f8f2\">(person,</span> <span style=\"color: #f8f8f2\">time):</span>\n    <span style=\"color: #66d9ef\">await</span> <span style=\"color: #f8f8f2\">asyncio</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">sleep(time)</span>\n    <span style=\"color: #f8f8f2\">print(</span><span style=\"color: #e6db74\">f&quot;{</span><span style=\"color: #f8f8f2\">person</span><span style=\"color: #e6db74\">} -- wake up!&quot;</span><span style=\"color: #f8f8f2\">)</span>\n    \n<span style=\"color: #66d9ef\">async</span> <span style=\"color: #66d9ef\">def</span> <span style=\"color: #a6e22e\">wake_up_gang</span><span style=\"color: #f8f8f2\">():</span>\n    <span style=\"color: #f8f8f2\">tasks</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">[</span>\n        <span style=\"color: #f8f8f2\">asyncio</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">create_task(sleepy_alarm(</span><span style=\"color: #e6db74\">&quot;Bob&quot;</span><span style=\"color: #f8f8f2\">,</span> <span style=\"color: #ae81ff\">3</span><span style=\"color: #f8f8f2\">),</span> <span style=\"color: #f8f8f2\">name</span><span style=\"color: #f92672\">=</span><span style=\"color: #e6db74\">&quot;wake up Bob&quot;</span><span style=\"color: #f8f8f2\">),</span>\n        <span style=\"color: #f8f8f2\">asyncio</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">create_task(sleepy_alarm(</span><span style=\"color: #e6db74\">&quot;Sanjeet&quot;</span><span style=\"color: #f8f8f2\">,</span> <span style=\"color: #ae81ff\">4</span><span style=\"color: #f8f8f2\">),</span> <span style=\"color: #f8f8f2\">name</span><span style=\"color: #f92672\">=</span><span style=\"color: #e6db74\">&quot;wake up Sanjeet&quot;</span><span style=\"color: #f8f8f2\">),</span>\n        <span style=\"color: #f8f8f2\">asyncio</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">create_task(sleepy_alarm(</span><span style=\"color: #e6db74\">&quot;Doris&quot;</span><span style=\"color: #f8f8f2\">,</span> <span style=\"color: #ae81ff\">2</span><span style=\"color: #f8f8f2\">),</span> <span style=\"color: #f8f8f2\">name</span><span style=\"color: #f92672\">=</span><span style=\"color: #e6db74\">&quot;wake up Doris&quot;</span><span style=\"color: #f8f8f2\">),</span>\n        <span style=\"color: #f8f8f2\">asyncio</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">create_task(sleepy_alarm(</span><span style=\"color: #e6db74\">&quot;Kim&quot;</span><span style=\"color: #f8f8f2\">,</span> <span style=\"color: #ae81ff\">5</span><span style=\"color: #f8f8f2\">),</span> <span style=\"color: #f8f8f2\">name</span><span style=\"color: #f92672\">=</span><span style=\"color: #e6db74\">&quot;wake up Kim&quot;</span><span style=\"color: #f8f8f2\">)</span>\n    <span style=\"color: #f8f8f2\">]</span>\n    <span style=\"color: #66d9ef\">await</span> <span style=\"color: #f8f8f2\">asyncio</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">gather(</span><span style=\"color: #f92672\">*</span><span style=\"color: #f8f8f2\">tasks)</span>\n    \n<span style=\"color: #f8f8f2\">asyncio</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">run(wake_up_gang())</span>\n</pre></div>\n\n<h4 id=this-will-print>This will print:</h4>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span>Doris -- wake up!\nBob -- wake up!\nSanjeet -- wake up!\nKim -- wake up!\n</pre></div>\n\n<p style=\"font-size: 16px;\">In the event loop, it will run over each of the coroutines to see if they are completed. Similar to how the <code>yield</code> keyword can return multiple values from the same frame, the <code>await</code> keyword can return multiple states. The event loop will execute the <code>sleepy_alarm()</code> coroutine objects again and again until the <code>await asyncio.sleep()</code> yields a completed result, and the <code>print()</code> function is able to execute.</p>\n<p style=\"font-size: 16px;\">For this to work, <code>asyncio.sleep()</code> must be used instead of the blocking (and not async-aware) <code>time.sleep()</code>.</p>\n<h4 id=example>Example</h4>\n<p style=\"font-size: 16px;\">You can convert the multithreaded port scanner example to asyncio with these steps:</p>\n<ul>\n<li>Change the <code>check_port()</code> function to use a socket connection from <code>asyncio.open_connection()</code>, which creates a future instead of an immediate connection</li>\n<li>Use the socket connection future in a timer event, with <code>asyncio.wait_for()</code></li>\n<li>Append the port to the results list if succeeded</li>\n<li>Add a new function, <code>scan()</code> to create the <code>check_port()</code> coroutines for each port and add them to a list, <code>tasks</code></li>\n<li>Merge all the tasks into a new coroutine using <code>asyncio.gather()</code></li>\n<li>Run the scan using <code>asyncio.run()</code></li>\n</ul>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">time</span>\n<span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">asyncio</span>\n\n<span style=\"color: #f8f8f2\">timeout</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #ae81ff\">1.0</span>\n\n<span style=\"color: #66d9ef\">async</span> <span style=\"color: #66d9ef\">def</span> <span style=\"color: #a6e22e\">check_port</span><span style=\"color: #f8f8f2\">(host:</span> <span style=\"color: #f8f8f2\">str,</span> <span style=\"color: #f8f8f2\">port:</span> <span style=\"color: #f8f8f2\">int,</span> <span style=\"color: #f8f8f2\">results:</span> <span style=\"color: #f8f8f2\">list):</span>\n    <span style=\"color: #66d9ef\">try</span><span style=\"color: #f8f8f2\">:</span>\n    \t<span style=\"color: #f8f8f2\">future</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">asyncio</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">open_connection(host</span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\">host,</span> <span style=\"color: #f8f8f2\">port</span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\">port)</span>\n    \t<span style=\"color: #f8f8f2\">r,</span> <span style=\"color: #f8f8f2\">w</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #66d9ef\">await</span> <span style=\"color: #f8f8f2\">asyncio</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">wait_for(future,</span> <span style=\"color: #f8f8f2\">timeout</span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\">timeout)</span>\n    \t<span style=\"color: #f8f8f2\">results</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">append(port)</span>\n    \t<span style=\"color: #f8f8f2\">w</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">close()</span>\n    <span style=\"color: #66d9ef\">except</span> <span style=\"color: #f8f8f2\">asyncio</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">TimeoutError:</span>\n    \t<span style=\"color: #66d9ef\">pass</span> <span style=\"color: #75715e\"># port is closed, skip-and-continue</span>\n\n<span style=\"color: #66d9ef\">async</span> <span style=\"color: #66d9ef\">def</span> <span style=\"color: #a6e22e\">scan</span><span style=\"color: #f8f8f2\">(start,</span> <span style=\"color: #f8f8f2\">end,</span> <span style=\"color: #f8f8f2\">host):</span>\n    <span style=\"color: #f8f8f2\">tasks</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">[]</span>\n    <span style=\"color: #f8f8f2\">results</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">[]</span>\n    <span style=\"color: #66d9ef\">for</span> <span style=\"color: #f8f8f2\">port</span> <span style=\"color: #f92672\">in</span> <span style=\"color: #f8f8f2\">range(start,</span> <span style=\"color: #f8f8f2\">end):</span>\n    \t<span style=\"color: #f8f8f2\">tasks</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">append(check_port(host,</span> <span style=\"color: #f8f8f2\">port,</span> <span style=\"color: #f8f8f2\">results))</span>\n    <span style=\"color: #66d9ef\">await</span> <span style=\"color: #f8f8f2\">asyncio</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">gather(</span><span style=\"color: #f92672\">*</span><span style=\"color: #f8f8f2\">tasks)</span>\n    <span style=\"color: #66d9ef\">return</span> <span style=\"color: #f8f8f2\">results</span>\n\n<span style=\"color: #66d9ef\">if</span> <span style=\"color: #f8f8f2\">__name__</span> <span style=\"color: #f92672\">==</span> <span style=\"color: #e6db74\">&#39;__main__&#39;</span><span style=\"color: #f8f8f2\">:</span>\n    <span style=\"color: #f8f8f2\">start</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">time</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">time()</span>\n    <span style=\"color: #f8f8f2\">host</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #e6db74\">&quot;localhost&quot;</span> <span style=\"color: #75715e\"># pick a host you own</span>\n    <span style=\"color: #f8f8f2\">results</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">asyncio</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">run(scan(</span><span style=\"color: #ae81ff\">80</span><span style=\"color: #f8f8f2\">,</span> <span style=\"color: #ae81ff\">100</span><span style=\"color: #f8f8f2\">,</span> <span style=\"color: #f8f8f2\">host))</span>\n    <span style=\"color: #66d9ef\">for</span> <span style=\"color: #f8f8f2\">result</span> <span style=\"color: #f92672\">in</span> <span style=\"color: #f8f8f2\">results:</span>\n    \t<span style=\"color: #f8f8f2\">print(</span><span style=\"color: #e6db74\">&quot;Port {0} is open&quot;</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">format(result))</span>\n    <span style=\"color: #f8f8f2\">print(</span><span style=\"color: #e6db74\">&quot;Completed scan in {0} seconds&quot;</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">format(time</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">time()</span> <span style=\"color: #f92672\">-</span> <span style=\"color: #f8f8f2\">start))</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">Finally, this scan completes in just over 1 second:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span>python portscanner_async.py\nPort 80 is open\nCompleted scan in 1.0058400630950928 seconds\n</pre></div>\n\n<h2 id=asynchronous-generators>Asynchronous Generators</h2>\n<p style=\"font-size: 16px;\">The concepts you have learned so far, generators and coroutines can be combined into a type - <strong>asynchronous generators</strong>. If a function is declared with both the async keyword and it contains a yield statement, it is converted into an async generator object when called. Like generators, async generators must be executed by something that understands the protocol. In place of <code>__next__()</code>, async generators have a method <code>__anext__()</code>. A regular <code>for</code> loop would not understand an async generator, so instead, the <code>async for</code> statement is used.</p>\n<p style=\"font-size: 16px;\">You can refactor the <code>check_port()</code> function into an async generator that yields the next open port until it hits the last port, or it has found a specified number of open ports:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #66d9ef\">async</span> <span style=\"color: #66d9ef\">def</span> <span style=\"color: #a6e22e\">check_ports</span><span style=\"color: #f8f8f2\">(host:</span> <span style=\"color: #f8f8f2\">str,</span> <span style=\"color: #f8f8f2\">start:</span> <span style=\"color: #f8f8f2\">int,</span> <span style=\"color: #f8f8f2\">end:</span> <span style=\"color: #f8f8f2\">int,</span> <span style=\"color: #f8f8f2\">max</span><span style=\"color: #f92672\">=</span><span style=\"color: #ae81ff\">10</span><span style=\"color: #f8f8f2\">):</span>\n    <span style=\"color: #f8f8f2\">found</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #ae81ff\">0</span>\n    <span style=\"color: #66d9ef\">for</span> <span style=\"color: #f8f8f2\">port</span> <span style=\"color: #f92672\">in</span> <span style=\"color: #f8f8f2\">range(start,</span> <span style=\"color: #f8f8f2\">end):</span>\n        <span style=\"color: #66d9ef\">try</span><span style=\"color: #f8f8f2\">:</span>\n            <span style=\"color: #f8f8f2\">future</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">asyncio</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">open_connection(host</span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\">host,</span> <span style=\"color: #f8f8f2\">port</span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\">port)</span>\n            <span style=\"color: #f8f8f2\">r,</span> <span style=\"color: #f8f8f2\">w</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #66d9ef\">await</span> <span style=\"color: #f8f8f2\">asyncio</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">wait_for(future,</span> <span style=\"color: #f8f8f2\">timeout</span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\">timeout)</span>\n            <span style=\"color: #66d9ef\">yield</span> <span style=\"color: #f8f8f2\">port</span>\n            <span style=\"color: #f8f8f2\">found</span> <span style=\"color: #f92672\">+=</span> <span style=\"color: #ae81ff\">1</span>\n            <span style=\"color: #f8f8f2\">w</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">close()</span>\n            <span style=\"color: #66d9ef\">if</span> <span style=\"color: #f8f8f2\">found</span> <span style=\"color: #f92672\">&gt;=</span> <span style=\"color: #f8f8f2\">max:</span>\n            \t<span style=\"color: #66d9ef\">return</span>\n        <span style=\"color: #66d9ef\">except</span> <span style=\"color: #f8f8f2\">asyncio</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">TimeoutError:</span>\n        \t<span style=\"color: #66d9ef\">pass</span> <span style=\"color: #75715e\"># closed</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">To execute this, use the <code>async for</code> statement:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #66d9ef\">async</span> <span style=\"color: #66d9ef\">def</span> <span style=\"color: #a6e22e\">scan</span><span style=\"color: #f8f8f2\">(start,</span> <span style=\"color: #f8f8f2\">end,</span> <span style=\"color: #f8f8f2\">host):</span>\n    <span style=\"color: #f8f8f2\">results</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">[]</span>\n    <span style=\"color: #66d9ef\">async</span> <span style=\"color: #66d9ef\">for</span> <span style=\"color: #f8f8f2\">port</span> <span style=\"color: #f92672\">in</span> <span style=\"color: #f8f8f2\">check_ports(host,</span> <span style=\"color: #f8f8f2\">start,</span> <span style=\"color: #f8f8f2\">end,</span> <span style=\"color: #f8f8f2\">max</span><span style=\"color: #f92672\">=</span><span style=\"color: #ae81ff\">1</span><span style=\"color: #f8f8f2\">):</span>\n    \t<span style=\"color: #f8f8f2\">results</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">append(port)</span>\n    <span style=\"color: #66d9ef\">return</span> <span style=\"color: #f8f8f2\">results</span>\n</pre></div>\n\n<h2 id=subinterpreters>Subinterpreters</h2>\n<p style=\"font-size: 16px;\">So far, you have covered:</p>\n<ul>\n<li>Parallel execution with multiprocessing</li>\n<li>Concurrent execution with threads and async</li>\n</ul>\n<p style=\"font-size: 16px;\">The downside of multiprocessing is that the inter-process communication using pipes and queues is slower than shared memory. Also the overhead to start a new process is significant.</p>\n<p style=\"font-size: 16px;\">Threading and async have small overhead but don’t offer truly parallel execution because of the thread-safety guarantees in the GIL. The fourth option is <code>subinterpreters</code>, which have a smaller overhead than <code>multiprocessing</code>, and allow a GIL per subinterpreter. After all, it is the Global <strong>Interpreter</strong> Lock. Within the CPython runtime, there is always 1 interpreter. The interpreter holds the interpreter state, and within an interpreter, you can have 1 or many Python threads. The interpreter is the container for the evaluation loop. the interpreter also manages its own memory, reference counter, and garbage collection. CPython has low-level C APIs for creating interpreters, like the <a href=\"https://github.com/python/cpython/blob/v3.9.0b1/Python/pylifecycle.c#L1626\"><code>Py_NewInterpreter()</code></a>.</p>\n<p style=\"font-size: 16px;\"><center><img src=\"/media/post/python_internals/78.png\" alt=\"78\" /></center></p>\n<blockquote>\n<p style=\"font-size: 16px;\"><strong>Note</strong></p>\n<p style=\"font-size: 16px;\">The subinterpreters module is still experimental in 3.9.0b1, so the API is subject to change and the implementation is still buggy.</p>\n</blockquote>\n<p style=\"font-size: 16px;\">Because Interpreter state contains the memory allocation arena, a collection of all pointers to Python objects (local and global), subinterpreters cannot access the global variables of other interpreters. Similar to multiprocessing, to share objects between interpreters you must serialize them, or use ctypes, and use a form of IPC (network, disk or shared memory).</p>\n<h4 id=related-source-files>Related Source Files</h4>\n<p style=\"font-size: 16px;\">Source files related to subinterpreters are:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">File</th>\n<th align=\"left\">Purpose</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\"><code>Lib/_xxsubinterpreters.c</code></td>\n<td align=\"left\">C implementation of the <code>subinterpreters</code> module</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Python/pylifecycle.c</code></td>\n<td align=\"left\">C implementation of the interpreter management API</td>\n</tr>\n</tbody>\n</table>\n<h4 id=example>Example</h4>\n<p style=\"font-size: 16px;\">In the final example application, the actual connection code has to be captured in a string. In 3.9.0b1, subinterpreters can only be executed with a string of code.</p>\n<p style=\"font-size: 16px;\">To start each of the subinterpreters, a list of threads is started, with a callback to a function, <code>run()</code>.</p>\n<p style=\"font-size: 16px;\">This function will:</p>\n<ul>\n<li>Create a communication channel</li>\n<li>Start a new subinterpreter</li>\n<li>Send it the code to execute</li>\n<li>Receive data over the communication channel</li>\n<li>If the port connection succeeded, add it to the thread-safe queue</li>\n</ul>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span><span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">time</span>\n<span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">_xxsubinterpreters</span> <span style=\"color: #66d9ef\">as</span> <span style=\"color: #f8f8f2\">subinterpreters</span>\n<span style=\"color: #f92672\">from</span> <span style=\"color: #f8f8f2\">threading</span> <span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">Thread</span>\n<span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">textwrap</span> <span style=\"color: #66d9ef\">as</span> <span style=\"color: #f8f8f2\">tw</span>\n<span style=\"color: #f92672\">from</span> <span style=\"color: #f8f8f2\">queue</span> <span style=\"color: #f92672\">import</span> <span style=\"color: #f8f8f2\">Queue</span>\n\n<span style=\"color: #f8f8f2\">timeout</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #ae81ff\">1</span> <span style=\"color: #75715e\"># in seconds..</span>\n\n<span style=\"color: #66d9ef\">def</span> <span style=\"color: #a6e22e\">run</span><span style=\"color: #f8f8f2\">(host:</span> <span style=\"color: #f8f8f2\">str,</span> <span style=\"color: #f8f8f2\">port:</span> <span style=\"color: #f8f8f2\">int,</span> <span style=\"color: #f8f8f2\">results:</span> <span style=\"color: #f8f8f2\">Queue):</span>\n    <span style=\"color: #75715e\"># Create a communication channel</span>\n    <span style=\"color: #f8f8f2\">channel_id</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">subinterpreters</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">channel_create()</span>\n    <span style=\"color: #f8f8f2\">interpid</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">subinterpreters</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">create()</span>\n    <span style=\"color: #f8f8f2\">subinterpreters</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">run_string(</span>\n        <span style=\"color: #f8f8f2\">interpid,</span>\n        <span style=\"color: #f8f8f2\">tw</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">dedent(</span>\n            <span style=\"color: #e6db74\">&quot;&quot;&quot;</span>\n<span style=\"color: #e6db74\">            import socket; import _xxsubinterpreters as subinterpreters</span>\n<span style=\"color: #e6db74\">            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span>\n<span style=\"color: #e6db74\">            sock.settimeout(timeout)</span>\n<span style=\"color: #e6db74\">            result = sock.connect_ex((host, port))</span>\n<span style=\"color: #e6db74\">            subinterpreters.channel_send(channel_id, result)</span>\n<span style=\"color: #e6db74\">            sock.close()</span>\n<span style=\"color: #e6db74\">            &quot;&quot;&quot;</span><span style=\"color: #f8f8f2\">),</span>\n        <span style=\"color: #f8f8f2\">shared</span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\">dict(</span>\n            <span style=\"color: #f8f8f2\">channel_id</span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\">channel_id,</span>\n            <span style=\"color: #f8f8f2\">host</span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\">host,</span>\n            <span style=\"color: #f8f8f2\">port</span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\">port,</span>\n            <span style=\"color: #f8f8f2\">timeout</span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\">timeout</span>\n        <span style=\"color: #f8f8f2\">))</span>\n    <span style=\"color: #f8f8f2\">output</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">subinterpreters</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">channel_recv(channel_id)</span>\n    <span style=\"color: #f8f8f2\">subinterpreters</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">channel_release(channel_id)</span>\n    <span style=\"color: #66d9ef\">if</span> <span style=\"color: #f8f8f2\">output</span> <span style=\"color: #f92672\">==</span> <span style=\"color: #ae81ff\">0</span><span style=\"color: #f8f8f2\">:</span>\n    \t<span style=\"color: #f8f8f2\">results</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">put(port)</span>\n\n<span style=\"color: #66d9ef\">if</span> <span style=\"color: #f8f8f2\">__name__</span> <span style=\"color: #f92672\">==</span> <span style=\"color: #e6db74\">&#39;__main__&#39;</span><span style=\"color: #f8f8f2\">:</span>\n    <span style=\"color: #f8f8f2\">start</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">time</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">time()</span>\n    <span style=\"color: #f8f8f2\">host</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #e6db74\">&quot;127.0.0.1&quot;</span> <span style=\"color: #75715e\"># pick a host you own</span>\n    <span style=\"color: #f8f8f2\">threads</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">[]</span>\n    <span style=\"color: #f8f8f2\">results</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">Queue()</span>\n    <span style=\"color: #66d9ef\">for</span> <span style=\"color: #f8f8f2\">port</span> <span style=\"color: #f92672\">in</span> <span style=\"color: #f8f8f2\">range(</span><span style=\"color: #ae81ff\">80</span><span style=\"color: #f8f8f2\">,</span> <span style=\"color: #ae81ff\">100</span><span style=\"color: #f8f8f2\">):</span>\n    \t<span style=\"color: #f8f8f2\">t</span> <span style=\"color: #f92672\">=</span> <span style=\"color: #f8f8f2\">Thread(target</span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\">run,</span> <span style=\"color: #f8f8f2\">args</span><span style=\"color: #f92672\">=</span><span style=\"color: #f8f8f2\">(host,</span> <span style=\"color: #f8f8f2\">port,</span> <span style=\"color: #f8f8f2\">results))</span>\n        <span style=\"color: #f8f8f2\">t</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">start()</span>\n\t\t<span style=\"color: #f8f8f2\">threads</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">append(t)</span>\n    <span style=\"color: #66d9ef\">for</span> <span style=\"color: #f8f8f2\">t</span> <span style=\"color: #f92672\">in</span> <span style=\"color: #f8f8f2\">threads:</span>\n\t\t<span style=\"color: #f8f8f2\">t</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">join()</span>\n    <span style=\"color: #66d9ef\">while</span> <span style=\"color: #f92672\">not</span> <span style=\"color: #f8f8f2\">results</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">empty():</span>\n    \t<span style=\"color: #f8f8f2\">print(</span><span style=\"color: #e6db74\">&quot;Port {0} is open&quot;</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">format(results</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">get()))</span>\n    <span style=\"color: #f8f8f2\">print(</span><span style=\"color: #e6db74\">&quot;Completed scan in {0} seconds&quot;</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">format(time</span><span style=\"color: #f92672\">.</span><span style=\"color: #f8f8f2\">time()</span> <span style=\"color: #f92672\">-</span> <span style=\"color: #f8f8f2\">start))</span>\n</pre></div>\n\n<p style=\"font-size: 16px;\">Because of the reduced overheads compared with multiprocessing, this example should execute 30-40% faster and with fewer memory resources:</p>\n<div class=\"highlight\" style=\"background: #272822\"><pre style=\"line-height: 125%;; font-size: 16px\"><span></span>python portscanner_subinterpreters.py\nPort 80 is open\nCompleted scan in 1.3474230766296387 seconds\n</pre></div>\n\n<h4 id=conclusion>Conclusion</h4>\n<p style=\"font-size: 16px;\">Congratulations on getting through the biggest chapter in the book! You’ve covered a lot of ground. Let us recap some of the concepts and their applications.</p>\n<p style=\"font-size: 16px;\">For truly <strong>parallel execution</strong>, you need multiple CPUs or cores. You also need to use either <strong>multiprocessing</strong> or <strong>subinterpreters</strong> packages so that the Python interpreter can be executed in parallel. Remember that startup time is significant, and each interpreter has a big memory overhead. If the tasks that you want to execute are shortlived, use a pool of workers and a queue of tasks.</p>\n<p style=\"font-size: 16px;\">If you have multiple IO-bound tasks and want them to run <strong>concurrently</strong>, you should use multithreading, or use coroutines with the <strong>asyncio</strong> package.</p>\n<p style=\"font-size: 16px;\">All four of these approaches require an understanding of how to safely and efficiently transfer data between processes or threads. The best way to reinforce what you’ve learned is to look at an application you’ve written and seen how it can be refactored to leverage these techniques.</p>\n", "category": 4, "author": "Tom White", "author_contact": null, "is_comments_available": false, "is_already_formatted": true, "is_published": true, "is_isolated": false, "tags": [9, 10, 11, 12]}}]