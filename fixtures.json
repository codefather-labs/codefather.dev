[
  {
    "model": "admin.logentry",
    "pk": 1,
    "fields": {
      "action_time": "2022-06-08T13:25:27.726Z",
      "user": 1,
      "content_type": 7,
      "object_id": "1",
      "object_repr": "Книги",
      "action_flag": 1,
      "change_message": "[{\"added\": {}}]"
    }
  },
  {
    "model": "admin.logentry",
    "pk": 2,
    "fields": {
      "action_time": "2022-06-08T13:25:39.641Z",
      "user": 1,
      "content_type": 7,
      "object_id": "2",
      "object_repr": "Статьи",
      "action_flag": 1,
      "change_message": "[{\"added\": {}}]"
    }
  },
  {
    "model": "admin.logentry",
    "pk": 3,
    "fields": {
      "action_time": "2022-06-08T13:27:34.209Z",
      "user": 1,
      "content_type": 8,
      "object_id": "1",
      "object_repr": "Hashing",
      "action_flag": 1,
      "change_message": "[{\"added\": {}}]"
    }
  },
  {
    "model": "admin.logentry",
    "pk": 4,
    "fields": {
      "action_time": "2022-06-08T13:27:41.324Z",
      "user": 1,
      "content_type": 8,
      "object_id": "2",
      "object_repr": "Optimisation",
      "action_flag": 1,
      "change_message": "[{\"added\": {}}]"
    }
  },
  {
    "model": "admin.logentry",
    "pk": 5,
    "fields": {
      "action_time": "2022-06-08T13:28:06.031Z",
      "user": 1,
      "content_type": 8,
      "object_id": "3",
      "object_repr": "Consistent hashing",
      "action_flag": 1,
      "change_message": "[{\"added\": {}}]"
    }
  },
  {
    "model": "admin.logentry",
    "pk": 6,
    "fields": {
      "action_time": "2022-06-08T13:28:09.659Z",
      "user": 1,
      "content_type": 8,
      "object_id": "4",
      "object_repr": "Перевод",
      "action_flag": 1,
      "change_message": "[{\"added\": {}}]"
    }
  },
  {
    "model": "admin.logentry",
    "pk": 7,
    "fields": {
      "action_time": "2022-06-08T13:30:08.968Z",
      "user": 1,
      "content_type": 9,
      "object_id": "1",
      "object_repr": "Согласованное хеширование, Tom White",
      "action_flag": 1,
      "change_message": "[{\"added\": {}}]"
    }
  },
  {
    "model": "admin.logentry",
    "pk": 8,
    "fields": {
      "action_time": "2022-06-08T13:31:16.943Z",
      "user": 1,
      "content_type": 9,
      "object_id": "1",
      "object_repr": "Согласованное хеширование, Tom White",
      "action_flag": 2,
      "change_message": "[{\"changed\": {\"fields\": [\"Body\", \"Is comments available\"]}}]"
    }
  },
  {
    "model": "admin.logentry",
    "pk": 9,
    "fields": {
      "action_time": "2022-06-08T13:33:53.487Z",
      "user": 1,
      "content_type": 9,
      "object_id": "1",
      "object_repr": "Согласованное хеширование, Tom White",
      "action_flag": 2,
      "change_message": "[{\"changed\": {\"fields\": [\"Body\"]}}]"
    }
  },
  {
    "model": "admin.logentry",
    "pk": 10,
    "fields": {
      "action_time": "2022-06-08T13:38:13.002Z",
      "user": 1,
      "content_type": 9,
      "object_id": "1",
      "object_repr": "Согласованное хеширование, Tom White",
      "action_flag": 2,
      "change_message": "[{\"changed\": {\"fields\": [\"Markdown\", \"Is already formatted\"]}}]"
    }
  },
  {
    "model": "admin.logentry",
    "pk": 11,
    "fields": {
      "action_time": "2022-06-08T13:39:46.006Z",
      "user": 1,
      "content_type": 9,
      "object_id": "1",
      "object_repr": "Согласованное хеширование, Tom White",
      "action_flag": 2,
      "change_message": "[{\"changed\": {\"fields\": [\"Body\"]}}]"
    }
  },
  {
    "model": "admin.logentry",
    "pk": 12,
    "fields": {
      "action_time": "2022-06-08T14:34:23.410Z",
      "user": 1,
      "content_type": 8,
      "object_id": "5",
      "object_repr": "Highload",
      "action_flag": 1,
      "change_message": "[{\"added\": {}}]"
    }
  },
  {
    "model": "admin.logentry",
    "pk": 13,
    "fields": {
      "action_time": "2022-06-08T14:34:40.445Z",
      "user": 1,
      "content_type": 8,
      "object_id": "6",
      "object_repr": "Limiting",
      "action_flag": 1,
      "change_message": "[{\"added\": {}}]"
    }
  },
  {
    "model": "admin.logentry",
    "pk": 14,
    "fields": {
      "action_time": "2022-06-08T14:36:11.511Z",
      "user": 1,
      "content_type": 9,
      "object_id": "2",
      "object_repr": "Стратегии и методы ограничения скорости, Cloud Architecture Center",
      "action_flag": 1,
      "change_message": "[{\"added\": {}}]"
    }
  },
  {
    "model": "admin.logentry",
    "pk": 15,
    "fields": {
      "action_time": "2022-06-08T14:37:48.041Z",
      "user": 1,
      "content_type": 9,
      "object_id": "2",
      "object_repr": "Стратегии и методы ограничения скорости, Cloud Architecture Center",
      "action_flag": 2,
      "change_message": "[{\"changed\": {\"fields\": [\"Markdown\", \"Body\", \"Is already formatted\"]}}]"
    }
  },
  {
    "model": "admin.logentry",
    "pk": 16,
    "fields": {
      "action_time": "2022-06-08T15:01:54.446Z",
      "user": 1,
      "content_type": 9,
      "object_id": "3",
      "object_repr": "Дроссельные запросы API для повышения пропускной способности, Amazon API Gateway",
      "action_flag": 1,
      "change_message": "[{\"added\": {}}]"
    }
  },
  {
    "model": "admin.logentry",
    "pk": 17,
    "fields": {
      "action_time": "2022-06-08T15:03:42.302Z",
      "user": 1,
      "content_type": 9,
      "object_id": "3",
      "object_repr": "Дроссельные запросы API для повышения пропускной способности, Amazon API Gateway",
      "action_flag": 2,
      "change_message": "[{\"changed\": {\"fields\": [\"Markdown\", \"Body\", \"Is already formatted\"]}}]"
    }
  },
  {
    "model": "admin.logentry",
    "pk": 18,
    "fields": {
      "action_time": "2022-06-08T15:04:46.740Z",
      "user": 1,
      "content_type": 9,
      "object_id": "3",
      "object_repr": "Дроссельные запросы API для повышения пропускной способности, Amazon API Gateway",
      "action_flag": 2,
      "change_message": "[{\"changed\": {\"fields\": [\"Markdown\", \"Body\", \"Is already formatted\"]}}]"
    }
  },
  {
    "model": "admin.logentry",
    "pk": 19,
    "fields": {
      "action_time": "2022-06-08T15:12:07.495Z",
      "user": 1,
      "content_type": 9,
      "object_id": "3",
      "object_repr": "Дроссельные запросы API для повышения пропускной способности, Amazon API Gateway",
      "action_flag": 2,
      "change_message": "[{\"changed\": {\"fields\": [\"Markdown\", \"Body\", \"Is already formatted\"]}}]"
    }
  },
  {
    "model": "auth.permission",
    "pk": 1,
    "fields": {
      "name": "Can add log entry",
      "content_type": 1,
      "codename": "add_logentry"
    }
  },
  {
    "model": "auth.permission",
    "pk": 2,
    "fields": {
      "name": "Can change log entry",
      "content_type": 1,
      "codename": "change_logentry"
    }
  },
  {
    "model": "auth.permission",
    "pk": 3,
    "fields": {
      "name": "Can delete log entry",
      "content_type": 1,
      "codename": "delete_logentry"
    }
  },
  {
    "model": "auth.permission",
    "pk": 4,
    "fields": {
      "name": "Can view log entry",
      "content_type": 1,
      "codename": "view_logentry"
    }
  },
  {
    "model": "auth.permission",
    "pk": 5,
    "fields": {
      "name": "Can add permission",
      "content_type": 2,
      "codename": "add_permission"
    }
  },
  {
    "model": "auth.permission",
    "pk": 6,
    "fields": {
      "name": "Can change permission",
      "content_type": 2,
      "codename": "change_permission"
    }
  },
  {
    "model": "auth.permission",
    "pk": 7,
    "fields": {
      "name": "Can delete permission",
      "content_type": 2,
      "codename": "delete_permission"
    }
  },
  {
    "model": "auth.permission",
    "pk": 8,
    "fields": {
      "name": "Can view permission",
      "content_type": 2,
      "codename": "view_permission"
    }
  },
  {
    "model": "auth.permission",
    "pk": 9,
    "fields": {
      "name": "Can add group",
      "content_type": 3,
      "codename": "add_group"
    }
  },
  {
    "model": "auth.permission",
    "pk": 10,
    "fields": {
      "name": "Can change group",
      "content_type": 3,
      "codename": "change_group"
    }
  },
  {
    "model": "auth.permission",
    "pk": 11,
    "fields": {
      "name": "Can delete group",
      "content_type": 3,
      "codename": "delete_group"
    }
  },
  {
    "model": "auth.permission",
    "pk": 12,
    "fields": {
      "name": "Can view group",
      "content_type": 3,
      "codename": "view_group"
    }
  },
  {
    "model": "auth.permission",
    "pk": 13,
    "fields": {
      "name": "Can add user",
      "content_type": 4,
      "codename": "add_user"
    }
  },
  {
    "model": "auth.permission",
    "pk": 14,
    "fields": {
      "name": "Can change user",
      "content_type": 4,
      "codename": "change_user"
    }
  },
  {
    "model": "auth.permission",
    "pk": 15,
    "fields": {
      "name": "Can delete user",
      "content_type": 4,
      "codename": "delete_user"
    }
  },
  {
    "model": "auth.permission",
    "pk": 16,
    "fields": {
      "name": "Can view user",
      "content_type": 4,
      "codename": "view_user"
    }
  },
  {
    "model": "auth.permission",
    "pk": 17,
    "fields": {
      "name": "Can add content type",
      "content_type": 5,
      "codename": "add_contenttype"
    }
  },
  {
    "model": "auth.permission",
    "pk": 18,
    "fields": {
      "name": "Can change content type",
      "content_type": 5,
      "codename": "change_contenttype"
    }
  },
  {
    "model": "auth.permission",
    "pk": 19,
    "fields": {
      "name": "Can delete content type",
      "content_type": 5,
      "codename": "delete_contenttype"
    }
  },
  {
    "model": "auth.permission",
    "pk": 20,
    "fields": {
      "name": "Can view content type",
      "content_type": 5,
      "codename": "view_contenttype"
    }
  },
  {
    "model": "auth.permission",
    "pk": 21,
    "fields": {
      "name": "Can add session",
      "content_type": 6,
      "codename": "add_session"
    }
  },
  {
    "model": "auth.permission",
    "pk": 22,
    "fields": {
      "name": "Can change session",
      "content_type": 6,
      "codename": "change_session"
    }
  },
  {
    "model": "auth.permission",
    "pk": 23,
    "fields": {
      "name": "Can delete session",
      "content_type": 6,
      "codename": "delete_session"
    }
  },
  {
    "model": "auth.permission",
    "pk": 24,
    "fields": {
      "name": "Can view session",
      "content_type": 6,
      "codename": "view_session"
    }
  },
  {
    "model": "auth.permission",
    "pk": 25,
    "fields": {
      "name": "Can add category",
      "content_type": 7,
      "codename": "add_category"
    }
  },
  {
    "model": "auth.permission",
    "pk": 26,
    "fields": {
      "name": "Can change category",
      "content_type": 7,
      "codename": "change_category"
    }
  },
  {
    "model": "auth.permission",
    "pk": 27,
    "fields": {
      "name": "Can delete category",
      "content_type": 7,
      "codename": "delete_category"
    }
  },
  {
    "model": "auth.permission",
    "pk": 28,
    "fields": {
      "name": "Can view category",
      "content_type": 7,
      "codename": "view_category"
    }
  },
  {
    "model": "auth.permission",
    "pk": 29,
    "fields": {
      "name": "Can add tag",
      "content_type": 8,
      "codename": "add_tag"
    }
  },
  {
    "model": "auth.permission",
    "pk": 30,
    "fields": {
      "name": "Can change tag",
      "content_type": 8,
      "codename": "change_tag"
    }
  },
  {
    "model": "auth.permission",
    "pk": 31,
    "fields": {
      "name": "Can delete tag",
      "content_type": 8,
      "codename": "delete_tag"
    }
  },
  {
    "model": "auth.permission",
    "pk": 32,
    "fields": {
      "name": "Can view tag",
      "content_type": 8,
      "codename": "view_tag"
    }
  },
  {
    "model": "auth.permission",
    "pk": 33,
    "fields": {
      "name": "Can add post",
      "content_type": 9,
      "codename": "add_post"
    }
  },
  {
    "model": "auth.permission",
    "pk": 34,
    "fields": {
      "name": "Can change post",
      "content_type": 9,
      "codename": "change_post"
    }
  },
  {
    "model": "auth.permission",
    "pk": 35,
    "fields": {
      "name": "Can delete post",
      "content_type": 9,
      "codename": "delete_post"
    }
  },
  {
    "model": "auth.permission",
    "pk": 36,
    "fields": {
      "name": "Can view post",
      "content_type": 9,
      "codename": "view_post"
    }
  },
  {
    "model": "auth.user",
    "pk": 1,
    "fields": {
      "password": "pbkdf2_sha256$320000$80IY3bG5cS1x2pBTsi0QQv$4Ym0KyTxZe+r0vxT5FXHXoUwV/xqox0hTHSoyc/RZcY=",
      "last_login": "2022-06-08T13:31:44.457Z",
      "is_superuser": true,
      "username": "root",
      "first_name": "",
      "last_name": "",
      "email": "",
      "is_staff": true,
      "is_active": true,
      "date_joined": "2022-06-08T13:20:47.666Z",
      "groups": [],
      "user_permissions": []
    }
  },
  {
    "model": "contenttypes.contenttype",
    "pk": 1,
    "fields": {
      "app_label": "admin",
      "model": "logentry"
    }
  },
  {
    "model": "contenttypes.contenttype",
    "pk": 2,
    "fields": {
      "app_label": "auth",
      "model": "permission"
    }
  },
  {
    "model": "contenttypes.contenttype",
    "pk": 3,
    "fields": {
      "app_label": "auth",
      "model": "group"
    }
  },
  {
    "model": "contenttypes.contenttype",
    "pk": 4,
    "fields": {
      "app_label": "auth",
      "model": "user"
    }
  },
  {
    "model": "contenttypes.contenttype",
    "pk": 5,
    "fields": {
      "app_label": "contenttypes",
      "model": "contenttype"
    }
  },
  {
    "model": "contenttypes.contenttype",
    "pk": 6,
    "fields": {
      "app_label": "sessions",
      "model": "session"
    }
  },
  {
    "model": "contenttypes.contenttype",
    "pk": 7,
    "fields": {
      "app_label": "core",
      "model": "category"
    }
  },
  {
    "model": "contenttypes.contenttype",
    "pk": 8,
    "fields": {
      "app_label": "core",
      "model": "tag"
    }
  },
  {
    "model": "contenttypes.contenttype",
    "pk": 9,
    "fields": {
      "app_label": "core",
      "model": "post"
    }
  },
  {
    "model": "sessions.session",
    "pk": "06db2eufexef6tpkumj9lhz81h2rqmd2",
    "fields": {
      "session_data": ".eJxVjc2OgjAYRd-la0Pa0t_ZiTJEEo2OkxjckEJbYDB8hqILJ_Pug4kbt_fce-4vKusw-gl6N6APdNinmz6kPN4HoMtMDjaZVHLvDyecrbZXnDUFgdVDsCI33zuA4zlZf-ZH6NaG5l87hRaoNLepLW_BjWVnZyV5zypTz1dPYH_M0EBUwzCNXRU9K9GLhmgL1l2SV_dN0JrQzmvBa2w0dariTAjnZSwx9cxb5anGnCorvNMx01owwmPKJdaCaK8YUVw6i_7-AeZJT-o:1nyvmi:ANmUknFoN-7fGmlkWDBUF1_bCyVcJ7W6cFg1g-AI1q8",
      "expire_date": "2022-06-22T13:31:44.458Z"
    }
  },
  {
    "model": "sessions.session",
    "pk": "qcspuvg29d8ylmgxcvten0fu9y0tgg44",
    "fields": {
      "session_data": ".eJxVjUuLgzAYRf9L1kWSmOfsZhgo1sdsrJRuJOZLam1RiUrBYf77WOim23vuPfcX1XYKfh5urkcfKElDZ9KOPYBIGOG4VPm-ypXERdUfTuu9KD_bJstMEka6ppifv8-lSsqT_amOWSdXtEO1Wea2XiYX6itsSvKeNcZuV08AnekvQ2SHfg7XJnpWohedonwAd_96dd8ErZnabS24xUZTpxrOhHBexhJTzzwoTzXmVIHwTsdMa8EIjymXWAuivWJEcekA_f0Do75Q0Q:1nyvd9:D9GF7uGpRvB6oHst7kCwDMM728ucRZxUtAvYu9CFE1E",
      "expire_date": "2022-06-22T13:21:51.370Z"
    }
  },
  {
    "model": "core.tag",
    "pk": 1,
    "fields": {
      "uuid": "643c26e7-1906-4e0c-88d8-fc5e97d6a872",
      "created_at": "2022-06-08T13:27:34.208Z",
      "updated_at": "2022-06-08T13:27:34.208Z",
      "name": "Hashing"
    }
  },
  {
    "model": "core.tag",
    "pk": 2,
    "fields": {
      "uuid": "4a71c1b9-9586-4866-9334-024a85babd02",
      "created_at": "2022-06-08T13:27:41.323Z",
      "updated_at": "2022-06-08T13:27:41.323Z",
      "name": "Optimisation"
    }
  },
  {
    "model": "core.tag",
    "pk": 3,
    "fields": {
      "uuid": "4878843c-4bfe-4af5-81d7-9556494d3fc7",
      "created_at": "2022-06-08T13:28:06.030Z",
      "updated_at": "2022-06-08T13:28:06.030Z",
      "name": "Consistent hashing"
    }
  },
  {
    "model": "core.tag",
    "pk": 4,
    "fields": {
      "uuid": "6e4b3918-66c7-4bd6-a5c7-506bb8caf5e5",
      "created_at": "2022-06-08T13:28:09.658Z",
      "updated_at": "2022-06-08T13:28:09.658Z",
      "name": "Перевод"
    }
  },
  {
    "model": "core.tag",
    "pk": 5,
    "fields": {
      "uuid": "a7877206-b755-4a6f-8701-c74be994b615",
      "created_at": "2022-06-08T14:34:23.408Z",
      "updated_at": "2022-06-08T14:34:23.408Z",
      "name": "Highload"
    }
  },
  {
    "model": "core.tag",
    "pk": 6,
    "fields": {
      "uuid": "3a4aa4f5-a3f6-46ee-8a9c-25b4f10bffb5",
      "created_at": "2022-06-08T14:34:40.444Z",
      "updated_at": "2022-06-08T14:34:40.444Z",
      "name": "Limiting"
    }
  },
  {
    "model": "core.category",
    "pk": 1,
    "fields": {
      "uuid": "8576cbd0-c7b1-41d5-9a38-11bee7025d98",
      "created_at": "2022-06-08T13:25:27.724Z",
      "updated_at": "2022-06-08T13:25:27.724Z",
      "name": "Книги"
    }
  },
  {
    "model": "core.category",
    "pk": 2,
    "fields": {
      "uuid": "267dbfc3-084b-4504-90b9-811454431b5c",
      "created_at": "2022-06-08T13:25:39.641Z",
      "updated_at": "2022-06-08T13:25:39.641Z",
      "name": "Статьи"
    }
  },
  {
    "model": "core.post",
    "pk": 1,
    "fields": {
      "uuid": "baed3c6e-f391-430a-8ccc-e5b1a3576a3d",
      "created_at": "2022-06-08T13:30:08.966Z",
      "updated_at": "2022-06-08T13:39:46.004Z",
      "language": "ru",
      "title": "Согласованное хеширование",
      "slug": "согласованное-хеширование",
      "markdown": "# Введение\r\n---\r\nВ последнее время я пару раз сталкивался с последовательным хешированием. Документ, в котором была представлена эта\r\nидея (`Consistent Hashing and Random Trees: Distributed Caching Protocols for Relief of Hot Spots on the World Wide Web`\r\nby David Karger et al.), появился десять лет назад, хотя в последнее время кажется, что эта идея незаметно находит свое\r\nприменение в более и другие сервисы, от Amazon Dynamo до memcached (любезно предоставлено Last.fm). Так что же такое\r\nпоследовательное хеширование и почему вас это должно волновать?\r\n\r\nПотребность в согласованном хешировании возникла из-за ограничений, возникающих при работе с наборами кэширующих машин —\r\nнапример, веб-кэшей. Если у вас есть набор из n кэш-машин, то общий способ балансировки нагрузки между ними состоит в\r\nтом, чтобы поместить объект o в кэш-машину с номером `hash(o)` `mod n`. Это хорошо работает до тех пор, пока вы не\r\nдобавите или не удалите кеш-машины (по какой-либо причине), тогда n изменится, и каждый объект хэшируется в новое место.\r\nЭто может привести к катастрофе, поскольку исходные серверы контента перегружены запросами от кэш-машин. Как будто кэш\r\nвнезапно пропал. Что у него есть, в некотором смысле. (Вот почему вам следует позаботиться о том, чтобы последовательное\r\nхеширование не перегружало ваши серверы!)\r\n\r\nБыло бы неплохо, если бы при добавлении кэш-машины она брала свою справедливую долю объектов со всех других кэш-машин.\r\nТочно так же, когда кэш-машина была удалена, было бы неплохо, если бы ее объекты были разделены между оставшимися\r\nмашинами. Это именно то, что делает согласованное хеширование — последовательно отображает объекты на одну и ту же\r\nмашину кэширования, по крайней мере, насколько это возможно. Основная идея последовательного алгоритма хеширования\r\nсостоит в том, чтобы хешировать как объекты, так и кэши, используя одну и ту же хеш-функцию. Это делается для того,\r\nчтобы сопоставить кэш с интервалом, который будет содержать некоторое количество хэшей объектов. Если кеш удаляется, то\r\nего интервал заменяется кешем с соседним интервалом. Все остальные кэши остаются без изменений.\r\n\r\n# Демонстрация\r\n---\r\nДавайте рассмотрим это более подробно. Хэш-функция фактически сопоставляет объекты и кэши с диапазоном чисел. Это должно\r\nбыть знакомо каждому Java-программисту: метод `hashCode` для `Object ` возвращает `int`, лежащее в диапазоне от -231 до\r\n231-1. Представьте, что этот диапазон отображается в виде круга, чтобы значения зацикливались. Вот изображение круга с\r\nрядом объектов (1, 2, 3, 4) и кешей (A, B, C), отмеченных в точках, к которым они хэшируются (на основе диаграммы\r\nиз `Web Caching with Consistent Hashing` Дэвида Каргер и др.):\r\n\r\n![](/media/editor/2007-11-27-image-0000_20220608133731218516.png)\r\n\r\nЧтобы узнать, в какой кэш помещается объект, мы двигаемся по часовой стрелке по кругу, пока не найдем точку кэша. Итак,\r\nна диаграмме выше мы видим, что объекты 1 и 4 принадлежат кешу A, объект 2 принадлежит кешу B, а объект 3 принадлежит\r\nкешу C. Рассмотрим, что произойдет, если кеш C будет удален: объект 3 теперь принадлежит кешу A, и все другие\r\nсопоставления объектов не изменяются. Если затем добавить еще один кэш D в отмеченную позицию, он займет объекты 3 и 4,\r\nоставив только объект 1, принадлежащий A.\r\n\r\n![](/media/editor/2007-11-27-image-0001_20220608133739087452.png)\r\n\r\nЭто работает хорошо, за исключением того, что размер интервалов, назначенных каждому кешу, довольно удачен. Поскольку\r\nэто по существу случайно, возможно очень неравномерное распределение объектов между кэшами. Решение этой проблемы\r\nсостоит в том, чтобы представить идею «виртуальных узлов», которые являются копиями точек кэша по кругу. Поэтому всякий\r\nраз, когда мы добавляем кеш, мы создаем для него несколько точек в круге. Вы можете увидеть эффект этого на следующем\r\nграфике, который я создал путем моделирования хранения 10 000 объектов в 10 кешах с использованием кода, описанного\r\nниже. По оси x указано количество реплик точек кэша (в логарифмическом масштабе). Когда он мал, мы видим, что\r\nраспределение объектов по кешам несбалансированное, так как стандартное отклонение в процентах от среднего количества\r\nобъектов в кеше (по оси Y, также логарифмическое) велико. По мере увеличения количества реплик распределение объектов\r\nстановится более сбалансированным. Этот эксперимент показывает, что цифра в одну или две сотни реплик обеспечивает\r\nприемлемый баланс (стандартное отклонение, которое составляет примерно от 5% до 10% от среднего значения).\r\n\r\n![](/media/editor/2007-11-27-image-0002_20220608133747403741.png)\r\n\r\n# Реализация\r\n---\r\nДля полноты вот простая реализация на Java. Чтобы последовательное хеширование было эффективным, важно иметь\r\nхеш-функцию, которая хорошо смешивается. Большинство реализаций `hashCode` `Object` плохо смешиваются — например, они\r\nобычно производят ограниченное количество небольших целочисленных значений — поэтому у нас есть интерфейс `HashFunction`\r\n, позволяющий использовать пользовательскую хеш-функцию. Здесь рекомендуются хеши MD5.\r\n\r\n```java\r\nimport java.util.Collection;\r\nimport java.util.SortedMap;\r\nimport java.util.TreeMap;\r\n\r\npublic class ConsistentHash<T> {\r\n\r\n  private final HashFunction hashFunction;\r\n  private final int numberOfReplicas;\r\n  private final SortedMap<Integer, T> circle =\r\n    new TreeMap<Integer, T>();\r\n\r\n  public ConsistentHash(HashFunction hashFunction,\r\n    int numberOfReplicas, Collection<T> nodes) {\r\n\r\n    this.hashFunction = hashFunction;\r\n    this.numberOfReplicas = numberOfReplicas;\r\n\r\n    for (T node : nodes) {\r\n      add(node);\r\n    }\r\n  }\r\n\r\n  public void add(T node) {\r\n    for (int i = 0; i < numberOfReplicas; i++) {\r\n      circle.put(hashFunction.hash(node.toString() + i),\r\n        node);\r\n    }\r\n  }\r\n\r\n  public void remove(T node) {\r\n    for (int i = 0; i < numberOfReplicas; i++) {\r\n      circle.remove(hashFunction.hash(node.toString() + i));\r\n    }\r\n  }\r\n\r\n  public T get(Object key) {\r\n    if (circle.isEmpty()) {\r\n      return null;\r\n    }\r\n    int hash = hashFunction.hash(key);\r\n    if (!circle.containsKey(hash)) {\r\n      SortedMap<Integer, T> tailMap =\r\n        circle.tailMap(hash);\r\n      hash = tailMap.isEmpty() ?\r\n             circle.firstKey() : tailMap.firstKey();\r\n    }\r\n    return circle.get(hash);\r\n  }\r\n\r\n}\r\n```\r\n\r\nКруг представлен в виде отсортированной карты целых чисел, которые представляют хэш-значения, в кеши (здесь типа `T`).\r\nКогда создается объект `ConsistentHash`, каждый узел добавляется в карту круга несколько раз (\r\nконтролируется `numberOfReplicas`). Расположение каждой реплики выбирается путем хэширования имени узла вместе с\r\nчисловым суффиксом, и узел сохраняется в каждой из этих точек на карте. Чтобы найти узел для объекта (метод `get`),\r\nхеш-значение объекта используется для поиска на карте. В большинстве случаев в этом хеш-значении не будет узла,\r\nхранящегося (поскольку пространство хеш-значений обычно намного больше, чем количество узлов, даже с репликами), поэтому\r\nследующий узел находится путем поиска первого ключа в хвостовая карта. Если хвостовая карта пуста, то мы обходим круг,\r\nполучая первый ключ в круге.\r\n\r\n# Использование\r\n---\r\nИтак, как вы можете использовать согласованное хеширование? Скорее всего, вы встретите его в библиотеке, а не будете\r\nкодировать самостоятельно. Например, как упоминалось выше, memcached, система кэширования объектов с распределенной\r\nпамятью, теперь имеет клиентов, поддерживающих последовательное хеширование. Кетама Last.fm Ричарда Джонса была первой,\r\nи теперь есть реализация Java Дастином Саллингсом (которая вдохновила мою упрощенную демонстрационную реализацию выше).\r\nИнтересно отметить, что алгоритм последовательного хеширования должен быть реализован только на клиенте —\r\nсервер `memcached` не изменился. Другие системы, использующие согласованное хеширование, включают Chord, который\r\nпредставляет собой реализацию распределенной хэш-таблицы, и Dynamo от Amazon, который представляет собой хранилище\r\nключей и значений (недоступно за пределами Amazon).",
      "body": "<h1>Введение</h1>\r\n<hr />\r\n<p style=\"font-size: 16px;\">В последнее время я пару раз сталкивался с последовательным хешированием. Документ, в котором была представлена эта идея (<code>Consistent Hashing and Random Trees: Distributed Caching Protocols for Relief of Hot Spots on the World Wide Web</code> by David Karger et al.), появился десять лет назад, хотя в последнее время кажется, что эта идея незаметно находит свое применение в более и другие сервисы, от Amazon Dynamo до memcached (любезно предоставлено Last.fm). Так что же такое последовательное хеширование и почему вас это должно волновать?</p>\r\n<p style=\"font-size: 16px;\">Потребность в согласованном хешировании возникла из-за ограничений, возникающих при работе с наборами кэширующих машин &mdash; например, веб-кэшей. Если у вас есть набор из n кэш-машин, то общий способ балансировки нагрузки между ними состоит в том, чтобы поместить объект o в кэш-машину с номером <code>hash(o)</code> <code>mod n</code>. Это хорошо работает до тех пор, пока вы не добавите или не удалите кеш-машины (по какой-либо причине), тогда n изменится, и каждый объект хэшируется в новое место. Это может привести к катастрофе, поскольку исходные серверы контента перегружены запросами от кэш-машин. Как будто кэш внезапно пропал. Что у него есть, в некотором смысле. (Вот почему вам следует позаботиться о том, чтобы последовательное хеширование не перегружало ваши серверы!)</p>\r\n<p style=\"font-size: 16px;\">Было бы неплохо, если бы при добавлении кэш-машины она брала свою справедливую долю объектов со всех других кэш-машин. Точно так же, когда кэш-машина была удалена, было бы неплохо, если бы ее объекты были разделены между оставшимися машинами. Это именно то, что делает согласованное хеширование &mdash; последовательно отображает объекты на одну и ту же машину кэширования, по крайней мере, насколько это возможно. Основная идея последовательного алгоритма хеширования состоит в том, чтобы хешировать как объекты, так и кэши, используя одну и ту же хеш-функцию. Это делается для того, чтобы сопоставить кэш с интервалом, который будет содержать некоторое количество хэшей объектов. Если кеш удаляется, то его интервал заменяется кешем с соседним интервалом. Все остальные кэши остаются без изменений.</p>\r\n<h1>Демонстрация</h1>\r\n<hr />\r\n<p style=\"font-size: 16px;\">Давайте рассмотрим это более подробно. Хэш-функция фактически сопоставляет объекты и кэши с диапазоном чисел. Это должно быть знакомо каждому Java-программисту: метод <code>hashCode</code> для <code>Object</code> возвращает <code>int</code>, лежащее в диапазоне от -231 до 231-1. Представьте, что этот диапазон отображается в виде круга, чтобы значения зацикливались. Вот изображение круга с рядом объектов (1, 2, 3, 4) и кешей (A, B, C), отмеченных в точках, к которым они хэшируются (на основе диаграммы из <code>Web Caching with Consistent Hashing</code> Дэвида Каргер и др.):</p>\r\n<center><img src=\"data:image/png;base64,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\" alt=\"\" /></center>\r\n<p style=\"font-size: 16px;\">Чтобы узнать, в какой кэш помещается объект, мы двигаемся по часовой стрелке по кругу, пока не найдем точку кэша. Итак, на диаграмме выше мы видим, что объекты 1 и 4 принадлежат кешу A, объект 2 принадлежит кешу B, а объект 3 принадлежит кешу C. Рассмотрим, что произойдет, если кеш C будет удален: объект 3 теперь принадлежит кешу A, и все другие сопоставления объектов не изменяются. Если затем добавить еще один кэш D в отмеченную позицию, он займет объекты 3 и 4, оставив только объект 1, принадлежащий A.</p>\r\n<center><img src=\"data:image/png;base64,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\" alt=\"\" /></center>\r\n<p style=\"font-size: 16px;\">Это работает хорошо, за исключением того, что размер интервалов, назначенных каждому кешу, довольно удачен. Поскольку это по существу случайно, возможно очень неравномерное распределение объектов между кэшами. Решение этой проблемы состоит в том, чтобы представить идею &laquo;виртуальных узлов&raquo;, которые являются копиями точек кэша по кругу. Поэтому всякий раз, когда мы добавляем кеш, мы создаем для него несколько точек в круге. Вы можете увидеть эффект этого на следующем графике, который я создал путем моделирования хранения 10 000 объектов в 10 кешах с использованием кода, описанного ниже. По оси x указано количество реплик точек кэша (в логарифмическом масштабе). Когда он мал, мы видим, что распределение объектов по кешам несбалансированное, так как стандартное отклонение в процентах от среднего количества объектов в кеше (по оси Y, также логарифмическое) велико. По мере увеличения количества реплик распределение объектов становится более сбалансированным. Этот эксперимент показывает, что цифра в одну или две сотни реплик обеспечивает приемлемый баланс (стандартное отклонение, которое составляет примерно от 5% до 10% от среднего значения).</p>\r\n<center><img src=\"data:image/png;base64,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\" alt=\"\" /></center>\r\n<h1>Реализация</h1>\r\n<hr />\r\n<p style=\"font-size: 16px;\">Для полноты вот простая реализация на Java. Чтобы последовательное хеширование было эффективным, важно иметь хеш-функцию, которая хорошо смешивается. Большинство реализаций <code>hashCode</code> <code>Object</code> плохо смешиваются &mdash; например, они обычно производят ограниченное количество небольших целочисленных значений &mdash; поэтому у нас есть интерфейс <code>HashFunction</code> , позволяющий использовать пользовательскую хеш-функцию. Здесь рекомендуются хеши MD5.</p>\r\n<div class=\"highlight\" style=\"background: #272822;\">\r\n<pre style=\"line-height: 125%;\"><span style=\"font-size: 12pt;\"><span style=\"color: #f92672;\">import</span><span style=\"color: #f8f8f2;\"> java.util.Collection;</span>\r\n<span style=\"color: #f92672;\">import</span><span style=\"color: #f8f8f2;\"> java.util.SortedMap;</span>\r\n<span style=\"color: #f92672;\">import</span><span style=\"color: #f8f8f2;\"> java.util.TreeMap;</span>\r\n\r\n<span style=\"color: #66d9ef;\">public</span><span style=\"color: #f8f8f2;\"> </span><span style=\"color: #66d9ef;\">class</span> <span style=\"color: #a6e22e;\">ConsistentHash</span><span style=\"color: #f92672;\">&lt;</span><span style=\"color: #f8f8f2;\">T</span><span style=\"color: #f92672;\">&gt;</span><span style=\"color: #f8f8f2;\"> {</span>\r\n\r\n<span style=\"color: #f8f8f2;\">  </span><span style=\"color: #66d9ef;\">private</span><span style=\"color: #f8f8f2;\"> </span><span style=\"color: #66d9ef;\">final</span><span style=\"color: #f8f8f2;\"> HashFunction hashFunction;</span>\r\n<span style=\"color: #f8f8f2;\">  </span><span style=\"color: #66d9ef;\">private</span><span style=\"color: #f8f8f2;\"> </span><span style=\"color: #66d9ef;\">final</span><span style=\"color: #f8f8f2;\"> </span><span style=\"color: #66d9ef;\">int</span><span style=\"color: #f8f8f2;\"> numberOfReplicas;</span>\r\n<span style=\"color: #f8f8f2;\">  </span><span style=\"color: #66d9ef;\">private</span><span style=\"color: #f8f8f2;\"> </span><span style=\"color: #66d9ef;\">final</span><span style=\"color: #f8f8f2;\"> SortedMap</span><span style=\"color: #f92672;\">&lt;</span><span style=\"color: #f8f8f2;\">Integer, T</span><span style=\"color: #f92672;\">&gt;</span><span style=\"color: #f8f8f2;\"> circle </span><span style=\"color: #f92672;\">=</span>\r\n<span style=\"color: #f8f8f2;\">    </span><span style=\"color: #66d9ef;\">new</span><span style=\"color: #f8f8f2;\"> TreeMap</span><span style=\"color: #f92672;\">&lt;</span><span style=\"color: #f8f8f2;\">Integer, T</span><span style=\"color: #f92672;\">&gt;</span><span style=\"color: #f8f8f2;\">();</span>\r\n\r\n<span style=\"color: #f8f8f2;\">  </span><span style=\"color: #66d9ef;\">public</span><span style=\"color: #f8f8f2;\"> </span><span style=\"color: #a6e22e;\">ConsistentHash</span><span style=\"color: #f8f8f2;\">(HashFunction hashFunction,</span>\r\n<span style=\"color: #f8f8f2;\">    </span><span style=\"color: #66d9ef;\">int</span><span style=\"color: #f8f8f2;\"> numberOfReplicas, Collection</span><span style=\"color: #f92672;\">&lt;</span><span style=\"color: #f8f8f2;\">T</span><span style=\"color: #f92672;\">&gt;</span><span style=\"color: #f8f8f2;\"> nodes) {</span>\r\n\r\n<span style=\"color: #f8f8f2;\">    </span><span style=\"color: #66d9ef;\">this</span><span style=\"color: #f8f8f2;\">.</span><span style=\"color: #a6e22e;\">hashFunction</span><span style=\"color: #f8f8f2;\"> </span><span style=\"color: #f92672;\">=</span><span style=\"color: #f8f8f2;\"> hashFunction;</span>\r\n<span style=\"color: #f8f8f2;\">    </span><span style=\"color: #66d9ef;\">this</span><span style=\"color: #f8f8f2;\">.</span><span style=\"color: #a6e22e;\">numberOfReplicas</span><span style=\"color: #f8f8f2;\"> </span><span style=\"color: #f92672;\">=</span><span style=\"color: #f8f8f2;\"> numberOfReplicas;</span>\r\n\r\n<span style=\"color: #f8f8f2;\">    </span><span style=\"color: #66d9ef;\">for</span><span style=\"color: #f8f8f2;\"> (T node : nodes) {</span>\r\n<span style=\"color: #f8f8f2;\">      add(node);</span>\r\n<span style=\"color: #f8f8f2;\">    }</span>\r\n<span style=\"color: #f8f8f2;\">  }</span>\r\n\r\n<span style=\"color: #f8f8f2;\">  </span><span style=\"color: #66d9ef;\">public</span><span style=\"color: #f8f8f2;\"> </span><span style=\"color: #66d9ef;\">void</span><span style=\"color: #f8f8f2;\"> </span><span style=\"color: #a6e22e;\">add</span><span style=\"color: #f8f8f2;\">(T node) {</span>\r\n<span style=\"color: #f8f8f2;\">    </span><span style=\"color: #66d9ef;\">for</span><span style=\"color: #f8f8f2;\"> (</span><span style=\"color: #66d9ef;\">int</span><span style=\"color: #f8f8f2;\"> i </span><span style=\"color: #f92672;\">=</span><span style=\"color: #f8f8f2;\"> </span><span style=\"color: #ae81ff;\">0</span><span style=\"color: #f8f8f2;\">; i </span><span style=\"color: #f92672;\">&lt;</span><span style=\"color: #f8f8f2;\"> numberOfReplicas; i</span><span style=\"color: #f92672;\">++</span><span style=\"color: #f8f8f2;\">) {</span>\r\n<span style=\"color: #f8f8f2;\">      circle.</span><span style=\"color: #a6e22e;\">put</span><span style=\"color: #f8f8f2;\">(hashFunction.</span><span style=\"color: #a6e22e;\">hash</span><span style=\"color: #f8f8f2;\">(node.</span><span style=\"color: #a6e22e;\">toString</span><span style=\"color: #f8f8f2;\">() </span><span style=\"color: #f92672;\">+</span><span style=\"color: #f8f8f2;\"> i),</span>\r\n<span style=\"color: #f8f8f2;\">        node);</span>\r\n<span style=\"color: #f8f8f2;\">    }</span>\r\n<span style=\"color: #f8f8f2;\">  }</span>\r\n\r\n<span style=\"color: #f8f8f2;\">  </span><span style=\"color: #66d9ef;\">public</span><span style=\"color: #f8f8f2;\"> </span><span style=\"color: #66d9ef;\">void</span><span style=\"color: #f8f8f2;\"> </span><span style=\"color: #a6e22e;\">remove</span><span style=\"color: #f8f8f2;\">(T node) {</span>\r\n<span style=\"color: #f8f8f2;\">    </span><span style=\"color: #66d9ef;\">for</span><span style=\"color: #f8f8f2;\"> (</span><span style=\"color: #66d9ef;\">int</span><span style=\"color: #f8f8f2;\"> i </span><span style=\"color: #f92672;\">=</span><span style=\"color: #f8f8f2;\"> </span><span style=\"color: #ae81ff;\">0</span><span style=\"color: #f8f8f2;\">; i </span><span style=\"color: #f92672;\">&lt;</span><span style=\"color: #f8f8f2;\"> numberOfReplicas; i</span><span style=\"color: #f92672;\">++</span><span style=\"color: #f8f8f2;\">) {</span>\r\n<span style=\"color: #f8f8f2;\">      circle.</span><span style=\"color: #a6e22e;\">remove</span><span style=\"color: #f8f8f2;\">(hashFunction.</span><span style=\"color: #a6e22e;\">hash</span><span style=\"color: #f8f8f2;\">(node.</span><span style=\"color: #a6e22e;\">toString</span><span style=\"color: #f8f8f2;\">() </span><span style=\"color: #f92672;\">+</span><span style=\"color: #f8f8f2;\"> i));</span>\r\n<span style=\"color: #f8f8f2;\">    }</span>\r\n<span style=\"color: #f8f8f2;\">  }</span>\r\n\r\n<span style=\"color: #f8f8f2;\">  </span><span style=\"color: #66d9ef;\">public</span><span style=\"color: #f8f8f2;\"> T </span><span style=\"color: #a6e22e;\">get</span><span style=\"color: #f8f8f2;\">(Object key) {</span>\r\n<span style=\"color: #f8f8f2;\">    </span><span style=\"color: #66d9ef;\">if</span><span style=\"color: #f8f8f2;\"> (circle.</span><span style=\"color: #a6e22e;\">isEmpty</span><span style=\"color: #f8f8f2;\">()) {</span>\r\n<span style=\"color: #f8f8f2;\">      </span><span style=\"color: #66d9ef;\">return</span><span style=\"color: #f8f8f2;\"> </span><span style=\"color: #66d9ef;\">null</span><span style=\"color: #f8f8f2;\">;</span>\r\n<span style=\"color: #f8f8f2;\">    }</span>\r\n<span style=\"color: #f8f8f2;\">    </span><span style=\"color: #66d9ef;\">int</span><span style=\"color: #f8f8f2;\"> hash </span><span style=\"color: #f92672;\">=</span><span style=\"color: #f8f8f2;\"> hashFunction.</span><span style=\"color: #a6e22e;\">hash</span><span style=\"color: #f8f8f2;\">(key);</span>\r\n<span style=\"color: #f8f8f2;\">    </span><span style=\"color: #66d9ef;\">if</span><span style=\"color: #f8f8f2;\"> (</span><span style=\"color: #f92672;\">!</span><span style=\"color: #f8f8f2;\">circle.</span><span style=\"color: #a6e22e;\">containsKey</span><span style=\"color: #f8f8f2;\">(hash)) {</span>\r\n<span style=\"color: #f8f8f2;\">      SortedMap</span><span style=\"color: #f92672;\">&lt;</span><span style=\"color: #f8f8f2;\">Integer, T</span><span style=\"color: #f92672;\">&gt;</span><span style=\"color: #f8f8f2;\"> tailMap </span><span style=\"color: #f92672;\">=</span>\r\n<span style=\"color: #f8f8f2;\">        circle.</span><span style=\"color: #a6e22e;\">tailMap</span><span style=\"color: #f8f8f2;\">(hash);</span>\r\n<span style=\"color: #f8f8f2;\">      hash </span><span style=\"color: #f92672;\">=</span><span style=\"color: #f8f8f2;\"> tailMap.</span><span style=\"color: #a6e22e;\">isEmpty</span><span style=\"color: #f8f8f2;\">() </span><span style=\"color: #f92672;\">?</span>\r\n<span style=\"color: #f8f8f2;\">             circle.</span><span style=\"color: #a6e22e;\">firstKey</span><span style=\"color: #f8f8f2;\">() : tailMap.</span><span style=\"color: #a6e22e;\">firstKey</span><span style=\"color: #f8f8f2;\">();</span>\r\n<span style=\"color: #f8f8f2;\">    }</span>\r\n<span style=\"color: #f8f8f2;\">    </span><span style=\"color: #66d9ef;\">return</span><span style=\"color: #f8f8f2;\"> circle.</span><span style=\"color: #a6e22e;\">get</span><span style=\"color: #f8f8f2;\">(hash);</span>\r\n<span style=\"color: #f8f8f2;\">  }</span>\r\n\r\n<span style=\"color: #f8f8f2;\">}</span>\r\n</span></pre>\r\n</div>\r\n<p style=\"font-size: 16px;\">Круг представлен в виде отсортированной карты целых чисел, которые представляют хэш-значения, в кеши (здесь типа <code>T</code>). Когда создается объект <code>ConsistentHash</code>, каждый узел добавляется в карту круга несколько раз ( контролируется <code>numberOfReplicas</code>). Расположение каждой реплики выбирается путем хэширования имени узла вместе с числовым суффиксом, и узел сохраняется в каждой из этих точек на карте. Чтобы найти узел для объекта (метод <code>get</code>), хеш-значение объекта используется для поиска на карте. В большинстве случаев в этом хеш-значении не будет узла, хранящегося (поскольку пространство хеш-значений обычно намного больше, чем количество узлов, даже с репликами), поэтому следующий узел находится путем поиска первого ключа в хвостовая карта. Если хвостовая карта пуста, то мы обходим круг, получая первый ключ в круге.</p>\r\n<h1>Использование</h1>\r\n<hr />\r\n<p style=\"font-size: 16px;\">Итак, как вы можете использовать согласованное хеширование? Скорее всего, вы встретите его в библиотеке, а не будете кодировать самостоятельно. Например, как упоминалось выше, memcached, система кэширования объектов с распределенной памятью, теперь имеет клиентов, поддерживающих последовательное хеширование. Кетама Last.fm Ричарда Джонса была первой, и теперь есть реализация Java Дастином Саллингсом (которая вдохновила мою упрощенную демонстрационную реализацию выше). Интересно отметить, что алгоритм последовательного хеширования должен быть реализован только на клиенте &mdash; сервер <code>memcached</code> не изменился. Другие системы, использующие согласованное хеширование, включают Chord, который представляет собой реализацию распределенной хэш-таблицы, и Dynamo от Amazon, который представляет собой хранилище ключей и значений (недоступно за пределами Amazon).</p>",
      "category": 2,
      "author": "Tom White",
      "author_contact": "tom.e.white@gmail.com",
      "is_comments_available": false,
      "is_already_formatted": true,
      "tags": [
        1,
        2,
        3,
        4
      ]
    }
  },
  {
    "model": "core.post",
    "pk": 2,
    "fields": {
      "uuid": "50aabfab-4037-4abb-a603-aba1436e3129",
      "created_at": "2022-06-08T14:36:11.509Z",
      "updated_at": "2022-06-08T14:37:48.039Z",
      "language": "ru",
      "title": "Стратегии и методы ограничения скорости",
      "slug": "стратегии-и-методы-ограничения-скорости",
      "markdown": "### Введение\r\n---\r\n\r\nВ этом документе объясняется, почему используется ограничение скорости, описываются стратегии и методы ограничения скорости, а также объясняется, где ограничение скорости актуально для продуктов Google Cloud. Большая часть этой информации относится к нескольким уровням в стеках технологий, но в этом документе основное внимание уделяется ограничению скорости на уровне приложений.\r\n\r\nОграничение скорости относится к предотвращению превышения частоты операции некоторого ограничения. В крупномасштабных системах ограничение скорости обычно используется для защиты базовых служб и ресурсов.\r\n\r\n### Почему используется ограничение скорости\r\n---\r\n\r\nОграничение скорости обычно используется как защитная мера для услуг. Общие службы должны защищать себя от чрезмерного использования — преднамеренного или непреднамеренного — для поддержания доступности службы. Даже хорошо масштабируемые системы должны иметь ограничения на потребление на каком-то уровне. Чтобы система работала хорошо, клиенты также должны быть разработаны с учетом ограничения скорости, чтобы уменьшить вероятность [каскадного сбоя](https://sre.google/sre-book/addressing-cascading-failures/). Ограничение скорости как на стороне клиента, так и на стороне сервера имеет решающее значение для максимизации пропускной способности и минимизации сквозной задержки в больших распределенных системах.\r\n\r\n\r\n### Предотвращение нехватки ресурсов\r\n---\r\n\r\nНаиболее распространенная причина ограничения скорости — повысить доступность сервисов на основе API, избегая нехватки ресурсов. Многие инциденты отказа в обслуживании на основе нагрузки в больших системах являются непреднамеренными, вызванными ошибками в программном обеспечении или конфигурациями в какой-либо другой части системы, а не злонамеренными атаками (такими как распределенные атаки типа «отказ в обслуживании» на основе сети). Истощение ресурсов, не вызванное злонамеренной атакой, иногда называют [отказом в обслуживании (DoS) по дружественному огню.](https://cloud.google.com/blog/products/gcp/how-to-avoid-a-self-inflicted-ddos-attack-cre-life-lessons)\r\n\r\nКак правило, служба применяет ограничение скорости на этапе, предшествующем ограниченному ресурсу, с некоторым запасом безопасности для предварительного предупреждения. Маржа требуется, потому что может быть некоторая задержка в загрузке, и защита ограничения скорости должна быть на месте до того, как произойдет критическая конкуренция за ресурс. Например, RESTful API может применять ограничение скорости для защиты базовой базы данных; без ограничения скорости масштабируемая служба API может одновременно выполнять большое количество вызовов к базе данных, и база данных может быть не в состоянии отправлять четкие сигналы ограничения скорости.\r\n\r\n### Управление политиками и квотами\r\n---\r\n\r\nКогда пропускная способность службы распределяется между многими пользователями или потребителями, она может применять ограничение скорости для каждого пользователя, чтобы обеспечить справедливое и разумное использование, не затрагивая других пользователей. Эти ограничения могут применяться в течение более длительных периодов времени или они могут применяться к ресурсам, которые измеряются не скоростью, а выделенным количеством. Эти лимиты скорости и распределения вместе называются квотами. Квоты также могут применяться к пакетам монетизации API или ограничениям уровня бесплатного пользования. Дополнительные сведения см. в разделе [«Квоты и ограничения»](https://cloud.google.com/architecture/rate-limiting-strategies-techniques#quota_and_caps) данного документа.\r\n\r\nВажно понимать, как эти квоты распределяются между приложениями и проектами в вашей организации. Например, мошеннический канареечный выпуск в производственном проекте может потреблять квоту на ресурс, используемый обслуживающей производственной инфраструктурой.\r\n\r\n### Управление потоком\r\n---\r\n\r\nВ сложных связанных системах, которые обрабатывают большие объемы данных и сообщений, вы можете использовать ограничение скорости для управления этими потоками — будь то объединение многих потоков в одну службу или распределение одного рабочего потока среди многих рабочих.\r\n\r\nНапример, вы можете более равномерно распределить работу между рабочими, ограничив поток для каждого рабочего, не позволяя одному рабочему накапливать очередь необработанных элементов, пока другие рабочие простаивают. Управление потоком уравновешивает предварительную выборку данных, готовых к локальной обработке, и гарантирует, что каждый узел в системе имеет равные возможности для выполнения работы. Дополнительные сведения см. в разделе [Pub/Sub: управление потоком](https://cloud.google.com/architecture/rate-limiting-strategies-techniques#cloud_pub_sub_flow_control).\r\n\r\n### Избегание лишних затрат\r\n---\r\n\r\nВы можете использовать ограничение скорости для контроля затрат⁠, например, если базовый ресурс может автоматически масштабироваться для удовлетворения спроса, но бюджет на использование этого ресурса ограничен. Организация может использовать ограничение скорости, чтобы предотвратить выход экспериментов из-под контроля и накопление больших счетов. Эта проблема отчасти связана с тем, что многие квоты Google Cloud устанавливаются с начальными значениями, которые могут быть [увеличены по запросу](https://cloud.google.com/docs/quota#requesting_higher_quota). Другое ограничение ставок, мотивированное затратами, может применяться организациями, которые предлагают решения SaaS (программное обеспечение как услуга) с фиксированной стоимостью, которым необходимо смоделировать свои затраты, цену и маржу в расчете на одного клиента.\r\n\r\n### Стратегия\r\n---\r\n\r\nВ цепочке или сетке сервисов многие узлы системы являются и клиентами, и серверами. Каждая часть системы может вообще не применять стратегию ограничения скорости или может по-разному комбинировать одну или несколько стратегий, поэтому для обеспечения оптимальной работы требуется представление всей системы. Даже в тех случаях, когда ограничение скорости реализовано полностью на стороне сервера, клиент должен реагировать соответствующим образом. В большинстве ситуаций, если инструмент или инфраструктура, реализующая вашу стратегию ограничения скорости, не работает или недоступен, ваша служба должна открываться с ошибкой и пытаться обслужить все запросы. Клиенты, как правило, не выходят за рамки квот, и сбой при открытии менее опасен для крупномасштабных систем, чем сбой при закрытии. Отказ в закрытии приводит к полному выходу из строя, а отказ при открытии приводит к ухудшению состояния. Решения о неудачном открытии или закрытии в основном относятся к стороне сервера, но знание того, какие методы повторных попыток используют клиенты при неудачном запросе, может повлиять на ваши решения, принимаемые в отношении поведения сервера.\r\n\r\n### Без ограничения скорости\r\n---\r\n\r\nВажно рассмотреть вариант без ограничения скорости в качестве минимального уровня в вашем проекте, то есть как наихудший случай, который ваша система должна быть в состоянии приспособить. Создайте свою систему с надежной обработкой ошибок на случай, если какая-то часть вашей стратегии ограничения скорости перестанет работать, и поймите, что пользователи вашего сервиса получат в таких ситуациях. Убедитесь, что вы предоставляете полезные коды ошибок и не допускаете утечки конфиденциальных данных в кодах ошибок. Использование тайм-аутов, крайних сроков и шаблонов отключения помогает вашей службе быть более надежной при отсутствии ограничения скорости.\r\n\r\n### Пересечения\r\n---\r\n\r\nЕсли ваша служба вызывает другие службы для выполнения запросов, вы можете выбрать способ передачи любых сигналов ограничения скорости от этих служб обратно исходному вызывающему абоненту.\r\n\r\n> Примечание. В службах HTTP наиболее распространенным способом, которым службы сигнализируют о применении ограничения скорости, является возврат кода состояния `429` в ответе HTTP. Ответ `429` может предоставить дополнительную информацию о том, почему применяется ограничение (например, пользователь Freemium имеет меньшую квоту или система находится на обслуживании).\r\n\r\nСамый простой вариант — перенаправить только ответ об ограничении скорости от нисходящей службы вызывающей стороне. Альтернативой является принудительное ограничение скорости от имени нижестоящей службы и блокировка вызывающего абонента.\r\n\r\n### Применять ограничения скорости\r\n---\r\n\r\nНаиболее распространенная стратегия ограничения скорости заключается в том, что служба применяет один или несколько методов [принудительного ограничения скорости](https://cloud.google.com/architecture/rate-limiting-strategies-techniques#techniques-enforcing-rate-limits). Это ограничение скорости может быть введено для непосредственной защиты службы или может быть введено для защиты нижестоящего ресурса, когда известно, что нижестоящая служба не может защитить себя. Например, если вы используете службу API, которая подключается к устаревшей серверной системе, неустойчивой к большим нагрузкам, служба API не должна использовать стратегию сквозного доступа, предполагая, что устаревшая служба будет предоставлять свои собственные сигналы ограничения скорости. \r\n\r\nЧтобы применить ограничение скорости, сначала поймите, почему оно применяется в данном случае, а затем определите, какие атрибуты запроса лучше всего подходят для использования в качестве ограничивающего ключа (например, исходный IP-адрес, пользователь, ключ API). После выбора ограничивающего ключа ограничивающая реализация может использовать его для отслеживания использования. Когда лимиты достигнуты, сервис возвращает ограничивающий сигнал (обычно HTTP-ответ `429`).\r\n\r\n### Отложенные ответ\r\n---\r\n\r\nЕсли вычисление ответа обходится дорого или требует много времени, система может быть не в состоянии предоставить быстрый ответ на запрос, что усложняет для службы обработку запросов с высокой частотой. Альтернативой ограничению скорости в этих случаях является помещение запросов в очередь и возврат определенного идентификатора задания. Это позволяет службе поддерживать более высокую доступность и снижает объем вычислений для клиентов, которые в противном случае могли бы выполнять длительные блокирующие вызовы в ожидании ответа. То, как результат отложенного ответа возвращается вызывающей стороне, является другим набором вариантов, но обычно он включает опрос состояния идентификатора задания или через систему, полностью основанную на событиях, в которой вызывающая сторона может зарегистрировать обратный вызов или подписаться на запрос. канал событий. Такая система выходит за рамки данного документа. Шаблон отложенного ответа проще всего применить, когда немедленный ответ на запрос не содержит реальной информации. Если этим шаблоном злоупотреблять, это может увеличить сложность и режимы отказов вашей системы.\r\n\r\n### Стратегии на стороне клиента\r\n---\r\n\r\nОписанные до сих пор стратегии применяются для ограничения скорости на стороне сервера. Однако эти стратегии могут помочь при проектировании клиентов, особенно если учесть, что многие компоненты распределенной системы являются одновременно и клиентскими, и серверными. \r\n\r\nТочно так же, как основная цель службы при использовании ограничения скорости — защитить себя и поддерживать доступность, основная цель клиента — выполнить запрос, который он отправляет службе. Служба может быть не в состоянии выполнить запрос от клиента по разным причинам, включая следующие:\r\n\r\n* The service is unreachable because of network conditions.\r\n* The service returned a non-specific error.\r\n* The service denies the request because of an authentication or authorization failure.\r\n* The client request is invalid or malformed.\r\n* The service rate-limits the caller and sends a backpressure signal (commonly a `429` response).\r\n\r\nМы рекомендуем проектировать клиентов так, чтобы они были устойчивы к этим типам проблем. [Клиентские библиотеки](https://cloud.google.com/apis/docs/cloud-client-libraries), предоставляемые Google, имеют множество встроенных функций, которые распознают описанные выше сценарии. \r\n\r\nВ ответ на ограничивающие скорость, прерывистые или неспецифические ошибки клиент обычно должен повторить запрос после задержки. Рекомендуется увеличивать эту задержку экспоненциально после каждого неудачного запроса, что называется экспоненциальной отсрочкой. Когда многие клиенты могут делать запросы на основе расписания (например, выборка результатов каждый час), следует применять дополнительное случайное время (дрожание) к времени запроса, периоду отсрочки или к тому и другому, чтобы гарантировать, что эти несколько экземпляров клиента не станут периодические [гремящие стада](https://wikipedia.org/wiki/Thundering_herd_problem), а сами вызывают форму DDoS.\r\n\r\nПредставьте себе мобильное приложение со многими пользователями, которое регистрируется с помощью API каждый день ровно в полдень и применяет одну и ту же детерминированную логику отсрочки. В полдень многие клиенты звонят в службу, которая запускает ограничение скорости и возвращает ответы с кодом состояния 429. Затем клиенты послушно отступают и ждут установленное время (детерминированная задержка) ровно 60 секунд, а затем в 12:01 служба получает еще один большой набор запросов. Добавляя случайное смещение (джиттер) ко времени первоначального запроса или времени задержки, запросы и повторные попытки могут быть распределены более равномерно, что повышает шансы службы на выполнение запросов. \r\n\r\nВ идеале неидемпотентные запросы могут выполняться в контексте строго согласованной транзакции, но не все запросы на обслуживание могут предложить такие гарантии, поэтому при повторных попытках, изменяющих данные, необходимо учитывать последствия дублирования действий.\r\n\r\nВ ситуациях, когда разработчик клиента знает, что вызываемая им система неустойчива к стрессовым нагрузкам и не поддерживает сигналы, ограничивающие скорость (противодавление), разработчик клиентской библиотеки или разработчик клиентского приложения может выбрать применение самостоятельных ограничений. регулирование скорости с использованием тех же [методов ограничения скорости](https://cloud.google.com/architecture/rate-limiting-strategies-techniques#techniques-enforcing-rate-limits), что и на стороне сервера. \r\n\r\nДля клиентов API, которые откладывают ответ с идентификатором асинхронной длительной операции, клиент может войти в блокирующий цикл, опрашивая состояние отложенного ответа, устраняя эту сложность для пользователя клиентской библиотеки.\r\n\r\n### Методы обеспечения ограничения скорости\r\n---\r\n\r\nВ общем, скорость — это просто подсчет событий с течением времени. Тем не менее, существует несколько различных методов измерения и ограничения ставок, каждый из которых имеет свои собственные применения и последствия.\r\n\r\n- **Ведро токенов**: [ведро токенов](https://wikipedia.org/wiki/Token_bucket) поддерживает скользящий и накапливающийся бюджет использования в виде баланса токенов. Этот метод признает, что не все входные данные для службы соответствуют 1:1 запросам. Ведро токенов добавляет токены с определенной скоростью. Когда делается запрос на обслуживание, сервис пытается отозвать токен (уменьшая количество токенов) для выполнения запроса. Если в ведре нет токенов, сервис достиг своего предела и отвечает обратным давлением. Например, в службе GraphQL один запрос может привести к нескольким операциям, которые объединяются в результат. Каждая из этих операций может занимать по одному маркеру. Таким образом, служба может отслеживать пропускную способность, которая необходима для ограничения использования, а не привязывать метод ограничения скорости непосредственно к запросам.\r\n\r\n\r\n- **Дырявое ведро**: [Дырявое ведро](https://wikipedia.org/wiki/Leaky_bucket) похоже на ведро с жетонами, но скорость ограничена количеством, которое может капать или вытекать из ведра. Этот метод признает, что система имеет некоторую ограниченную способность удерживать запрос до тех пор, пока служба не сможет обработать его; все лишнее просто выливается за край и отбрасывается. Это понятие емкости буфера (но не обязательно использование дырявых корзин) также применимо к компонентам, смежным с вашей службой, таким как балансировщики нагрузки и дисковые буферы ввода-вывода.\r\n\r\n\r\n- **Фиксированное окно**. Пределы фиксированного окна, такие как 3000 запросов в час или 10 запросов в день, установить несложно, но они подвержены всплескам по краям окна по мере сброса доступной квоты. Возьмем, к примеру, ограничение в 3000 запросов в час, которое по-прежнему допускает всплеск всех 3000 запросов в первую минуту часа, что может привести к перегрузке службы.\r\n\r\n\r\n- **Скользящее окно**: Скользящее окно имеет преимущества фиксированного окна, но скользящее окно времени сглаживает всплески. Такие системы, как Redis, облегчают эту технику с помощью ключей с истекающим сроком действия.\r\n\r\n\r\nКогда у вас есть много независимо работающих экземпляров службы (например, облачных функций) в распределенной системе, и службу необходимо ограничить в целом, вам необходимо использовать быструю, логически глобальную (глобальную для всех запущенных функций, а не обязательно географически глобальное) хранилище ключей и значений, такое как Redis, для синхронизации различных счетчиков лимитов.\r\n\r\n### Функции ограничения скорости в Google Cloud\r\n---\r\n\r\nКаждый API Google (внутренний и внешний) применяет некоторую степень ограничения скорости или квоты. Это фундаментальный принцип дизайна услуг в Google. В этом разделе рассматривается, как эти службы также предоставляют ограничение скорости как функцию, которую вы можете использовать при создании в Google Cloud.\r\n\r\n### Квота и ограничения\r\n---\r\n\r\nGoogle Cloud применяет квоты, которые ограничивают объем определенного ресурса Google Cloud, который может использовать ваш проект. Квоты скорости указывают, сколько ресурсов может быть использовано в данный момент времени, например запросов API в день. Вы также можете установить свои собственные ограничения на то, сколько ресурсов можно использовать в данный момент времени; такие пользовательские ограничения называются ограничениями. \r\n\r\nДополнительные сведения о квотах и ​​ограничениях, включая информацию о том, как устанавливать ограничения и запрашивать увеличение квоты, см. в разделе [Работа с квотами](https://cloud.google.com/docs/quota). \r\n\r\nУ каждого продукта Google Cloud есть страница, на которой перечислены ограничения служб (например, максимальные размеры сообщений) и квоты на основе скорости (например, максимальное количество запросов в секунду для определенного API). На этих страницах также указано, можете ли вы запрашивать увеличение или нет. Чтобы найти эти страницы, начните с этого [поиска](https://cloud.google.com/s/results?q=%22quotas%20and%20limits%22).\r\n\r\nКак правило, квоты Google Cloud указаны для каждого проекта, а окна — в секунду или в минуту. Если в проекте запущено несколько частей решения, важно отметить, что они совместно используют эти квоты. \r\n\r\nВы можете [отслеживать](https://cloud.google.com/apis/docs/monitoring), как используется ваша квота, и даже устанавливать оповещения об изменениях в том, как вы используете квоту, или когда использование превышает определенное количество. Вы можете установить [собственное ограничение](https://cloud.google.com/apis/docs/capping-api-usage) на использование API и использовать [оповещения о бюджете](https://cloud.google.com/billing/docs/how-to/budgets), чтобы контролировать расходы, связанные с использованием API.\r\n\r\n### Cloud Tasks\r\n---\r\n\r\nCloud Tasks — это полностью управляемая служба, которую можно использовать для управления выполнением, отправкой и доставкой большого количества распределенных задач. Используя Cloud Tasks, вы можете асинхронно выполнять работу вне запроса пользователя. Cloud Tasks позволяет вам устанавливать [ограничения как на скорость, так и на параллелизм](https://cloud.google.com/tasks/docs/creating-appengine-queues#rate). Cloud Tasks использует технику корзины с маркерами, чтобы обеспечить [неравномерность](https://cloud.google.com/cloud-tasks/docs/reference/rest/v2beta2/projects.locations.queues#RateLimits) доставки сообщений в этих пределах.\r\n\r\n### Cloud Functions\r\n---\r\n\r\nCloud Functions — это легкое решение для вычислений, позволяющее разработчикам создавать одноцелевые автономные функции, которые реагируют на облачные события без необходимости управлять сервером или средой выполнения. Облачные функции по умолчанию не имеют состояния и легко масштабируются: управляемая инфраструктура Google автоматически создает экземпляры функций для обработки входящих запросов. Из-за такого поведения масштабирования функции могут стать объектами высокой частоты запросов, и если эти функции вызывают нижестоящие службы, функции могут стать источником непреднамеренного DoS для этих нижестоящих служб.\r\n\r\nОдним из типов DoS является исчерпание соединений в базах данных. Если каждый экземпляр функции устанавливает соединение базы данных с серверной частью, всплеск трафика может привести к автоматическому масштабированию многих экземпляров и, следовательно, к исчерпанию доступной емкости соединений на серверах баз данных. Чтобы предотвратить масштабирование функций за пределы определенного количества экземпляров, служба предоставляет настройку [максимального количества экземпляров для каждой функции](https://cloud.google.com/functions/docs/configuring/max-instances).\r\n\r\nДля фоновых функций Google Cloud вызывает вашу функцию с полезной нагрузкой и контекстом события. Вы можете указать, хотите ли вы, чтобы система [повторяла попытку доставки события](https://cloud.google.com/functions/docs/bestpractices/retries), если ваша функция дает сбой или не может обработать событие — возможно, из-за того, что его скорость ограничена чем-то нижестоящим.\r\n\r\nХотя настройка максимального количества экземпляров может помочь вам ограничить параллелизм, она не дает прямого контроля над тем, сколько раз в секунду может вызываться ваша функция. См. раздел «[Что дальше](https://cloud.google.com/architecture/rate-limiting-strategies-techniques#whats_next)» для руководств, демонстрирующих, как использовать Redis для глобальной координации ограничения скорости вызовов функций.\r\n\r\n### Pub/Sub: управление потоком\r\n---\r\n\r\nPub/Sub — это полностью управляемая служба обмена сообщениями в реальном времени, которая позволяет отправлять и получать сообщения между независимыми приложениями. При перемещении большого количества сообщений через темы Pub/Sub вам может потребоваться настроить скорость обработки сообщений на клиентах-потребителях, чтобы потребители, работающие параллельно, были эффективны и не удерживали слишком много ожидающих сообщений, влияя на общую задержку обработки. Чтобы настроить это поведение, клиенты Pub/Sub предоставляют несколько [параметров управления потоком](https://cloud.google.com/pubsub/docs/pull#flow_control).\r\n\r\n### Cloud Run\r\n---\r\n\r\nCloud Run — это управляемая вычислительная платформа, которая позволяет запускать контейнеры без сохранения состояния, которые можно вызывать с помощью HTTP-запросов. В отличие от облачных функций, один экземпляр контейнера может обрабатывать несколько запросов [одновременно](https://cloud.google.com/run/docs/about-concurrency), если это поддерживается обслуживающим стеком в контейнере.\r\n\r\n### Istio\r\n---\r\n\r\n[Istio](https://cloud.google.com/istio) — это независимая сервисная сетка с открытым исходным кодом, которая предоставляет основы, необходимые для успешного запуска распределенной микросервисной архитектуры. Отказоустойчивая микросервисная архитектура требует, чтобы сервисы были защищены от мошеннических одноранговых сервисов, поэтому Istio обеспечивает [ограничение скорости](https://istio.io/v1.4/docs/tasks/policy-enforcement/rate-limiting/#rate-limits) непосредственно в сервисной сетке.\r\n\r\n### Cloud Endpoints\r\n---\r\n\r\n[Cloud Endpoints](https://cloud.google.com/endpoints/docs) — это система управления API, которая помогает вам защищать, отслеживать, анализировать и устанавливать квоты для ваших API, используя ту же инфраструктуру, которую Google использует для своих собственных API. Являясь службой, призванной помочь вам предоставлять услуги внешнему миру, она предоставляет возможность [настраивать собственные квоты](https://cloud.google.com/endpoints/docs/openapi/quotas-configure), включая [политики на основе скорости](https://cloud.google.com/endpoints/docs/openapi/quotas-configure#quota_configuration_examples).\r\n\r\n### Apigee\r\n---\r\n\r\nApigee — это платформа для разработки и управления API-прокси. Прокси-сервер API — это ваш интерфейс для разработчиков, которые хотят использовать ваши серверные службы. Вместо того, чтобы напрямую использовать эти услуги, они получают доступ к прокси API Apigee, который вы создаете. Обычно Apigee размещают перед серверными службами, которые могут не иметь собственных возможностей ограничения скорости, поэтому ограничение скорости является встроенной функцией Apigee.\r\n\r\n### Google Cloud Armor\r\n---\r\n\r\nGoogle Cloud Armor использует [глобальную инфраструктуру и системы безопасности Google для защиты от распределенных атак типа «отказ в обслуживании» (DDoS)](https://cloud.google.com/armor) против инфраструктуры и приложений. Это включает в себя встроенную логику в отношении вредоносных всплесков и высокой нагрузки на ваши защищенные службы.\r\n\r\n### Project Shield\r\n---\r\n\r\nХотя [Project Shield](https://projectshield.withgoogle.com/public/) не является облачным сервисом Google, он использует инфраструктуру Google для защиты соответствующих сайтов от DDoS-атак.\r\n\r\n### Дополнительные методы для большей устойчивости\r\n---\r\n\r\nОграничение скорости на уровне приложения может предоставлять услуги с повышенной устойчивостью, но устойчивость можно дополнительно улучшить, комбинируя ограничение скорости на уровне приложения с другими методами: \r\n\r\n- **Кэширование**. Хранение результатов, вычисление которых происходит медленно, позволяет службе обрабатывать запросы с более высокой скоростью, что может привести к тому, что противодавление, ограничивающее скорость, будет применяться к клиентам реже. \r\n\r\n\r\n- **Разрыв цепи**: Вы можете сделать сервисные сети более устойчивыми к проблемам, возникающим из-за распространения повторяющихся ошибок, путем временной блокировки частей системы в тихое состояние. Пример реализации см. в разделе «Размыкание цепи» документации Istio. \r\n\r\n\r\n- **Приоритизация**: не все пользователи системы имеют одинаковый приоритет. Учитывайте дополнительные факторы при разработке ключей ограничения скорости, чтобы обеспечить обслуживание клиентов с более высоким приоритетом. Вы можете использовать сброс нагрузки, чтобы снять с систем бремя низкоприоритетного трафика.\r\n\r\n\r\n- **Ограничение скорости на нескольких уровнях**: если сетевой интерфейс вашего компьютера или ядро ​​ОС перегружены, то ограничение скорости на уровне приложения может никогда не начаться. Вы можете применять ограничения скорости на уровне 3 в iptables, или локальные устройства могут ограничивать на уровне 4. Вы также можете столкнуться с настраиваемыми ограничениями скорости, применяемыми к вводу-выводу вашей системы для таких вещей, как дисковые и сетевые буферы. \r\n\r\n\r\n- **Мониторинг**. Персоналу операционных систем крайне важно знать, когда происходит регулирование. Мониторинг ставок, превышающих квоты, имеет решающее значение для управления инцидентами и обнаружения регрессий в программном обеспечении. Мы рекомендуем реализовать такой мониторинг как для клиентской, так и для серверной точек зрения служб. Не все случаи ограничения скорости должны вызывать предупреждения, требующие немедленного внимания со стороны эксплуатационного персонала. В некритических случаях вы можете отреагировать на сигналы ограничения скорости позже, в рамках плановой оценки и обслуживания вашей системы. Вы можете использовать журналы о том, когда происходит ограничение скорости, как сигнал о необходимости внесения изменений, таких как увеличение емкости компонента, запрос на увеличение квоты или изменение политики.",
      "body": "<h3>Введение</h3>\n<hr />\n<p style=\"font-size: 16px;\">В этом документе объясняется, почему используется ограничение скорости, описываются стратегии и методы ограничения скорости, а также объясняется, где ограничение скорости актуально для продуктов Google Cloud. Большая часть этой информации относится к нескольким уровням в стеках технологий, но в этом документе основное внимание уделяется ограничению скорости на уровне приложений.</p>\n<p style=\"font-size: 16px;\">Ограничение скорости относится к предотвращению превышения частоты операции некоторого ограничения. В крупномасштабных системах ограничение скорости обычно используется для защиты базовых служб и ресурсов.</p>\n<h3>Почему используется ограничение скорости</h3>\n<hr />\n<p style=\"font-size: 16px;\">Ограничение скорости обычно используется как защитная мера для услуг. Общие службы должны защищать себя от чрезмерного использования — преднамеренного или непреднамеренного — для поддержания доступности службы. Даже хорошо масштабируемые системы должны иметь ограничения на потребление на каком-то уровне. Чтобы система работала хорошо, клиенты также должны быть разработаны с учетом ограничения скорости, чтобы уменьшить вероятность <a href=\"https://sre.google/sre-book/addressing-cascading-failures/\">каскадного сбоя</a>. Ограничение скорости как на стороне клиента, так и на стороне сервера имеет решающее значение для максимизации пропускной способности и минимизации сквозной задержки в больших распределенных системах.</p>\n<h3>Предотвращение нехватки ресурсов</h3>\n<hr />\n<p style=\"font-size: 16px;\">Наиболее распространенная причина ограничения скорости — повысить доступность сервисов на основе API, избегая нехватки ресурсов. Многие инциденты отказа в обслуживании на основе нагрузки в больших системах являются непреднамеренными, вызванными ошибками в программном обеспечении или конфигурациями в какой-либо другой части системы, а не злонамеренными атаками (такими как распределенные атаки типа «отказ в обслуживании» на основе сети). Истощение ресурсов, не вызванное злонамеренной атакой, иногда называют <a href=\"https://cloud.google.com/blog/products/gcp/how-to-avoid-a-self-inflicted-ddos-attack-cre-life-lessons\">отказом в обслуживании (DoS) по дружественному огню.</a></p>\n<p style=\"font-size: 16px;\">Как правило, служба применяет ограничение скорости на этапе, предшествующем ограниченному ресурсу, с некоторым запасом безопасности для предварительного предупреждения. Маржа требуется, потому что может быть некоторая задержка в загрузке, и защита ограничения скорости должна быть на месте до того, как произойдет критическая конкуренция за ресурс. Например, RESTful API может применять ограничение скорости для защиты базовой базы данных; без ограничения скорости масштабируемая служба API может одновременно выполнять большое количество вызовов к базе данных, и база данных может быть не в состоянии отправлять четкие сигналы ограничения скорости.</p>\n<h3>Управление политиками и квотами</h3>\n<hr />\n<p style=\"font-size: 16px;\">Когда пропускная способность службы распределяется между многими пользователями или потребителями, она может применять ограничение скорости для каждого пользователя, чтобы обеспечить справедливое и разумное использование, не затрагивая других пользователей. Эти ограничения могут применяться в течение более длительных периодов времени или они могут применяться к ресурсам, которые измеряются не скоростью, а выделенным количеством. Эти лимиты скорости и распределения вместе называются квотами. Квоты также могут применяться к пакетам монетизации API или ограничениям уровня бесплатного пользования. Дополнительные сведения см. в разделе <a href=\"https://cloud.google.com/architecture/rate-limiting-strategies-techniques#quota_and_caps\">«Квоты и ограничения»</a> данного документа.</p>\n<p style=\"font-size: 16px;\">Важно понимать, как эти квоты распределяются между приложениями и проектами в вашей организации. Например, мошеннический канареечный выпуск в производственном проекте может потреблять квоту на ресурс, используемый обслуживающей производственной инфраструктурой.</p>\n<h3>Управление потоком</h3>\n<hr />\n<p style=\"font-size: 16px;\">В сложных связанных системах, которые обрабатывают большие объемы данных и сообщений, вы можете использовать ограничение скорости для управления этими потоками — будь то объединение многих потоков в одну службу или распределение одного рабочего потока среди многих рабочих.</p>\n<p style=\"font-size: 16px;\">Например, вы можете более равномерно распределить работу между рабочими, ограничив поток для каждого рабочего, не позволяя одному рабочему накапливать очередь необработанных элементов, пока другие рабочие простаивают. Управление потоком уравновешивает предварительную выборку данных, готовых к локальной обработке, и гарантирует, что каждый узел в системе имеет равные возможности для выполнения работы. Дополнительные сведения см. в разделе <a href=\"https://cloud.google.com/architecture/rate-limiting-strategies-techniques#cloud_pub_sub_flow_control\">Pub/Sub: управление потоком</a>.</p>\n<h3>Избегание лишних затрат</h3>\n<hr />\n<p style=\"font-size: 16px;\">Вы можете использовать ограничение скорости для контроля затрат⁠, например, если базовый ресурс может автоматически масштабироваться для удовлетворения спроса, но бюджет на использование этого ресурса ограничен. Организация может использовать ограничение скорости, чтобы предотвратить выход экспериментов из-под контроля и накопление больших счетов. Эта проблема отчасти связана с тем, что многие квоты Google Cloud устанавливаются с начальными значениями, которые могут быть <a href=\"https://cloud.google.com/docs/quota#requesting_higher_quota\">увеличены по запросу</a>. Другое ограничение ставок, мотивированное затратами, может применяться организациями, которые предлагают решения SaaS (программное обеспечение как услуга) с фиксированной стоимостью, которым необходимо смоделировать свои затраты, цену и маржу в расчете на одного клиента.</p>\n<h3>Стратегия</h3>\n<hr />\n<p style=\"font-size: 16px;\">В цепочке или сетке сервисов многие узлы системы являются и клиентами, и серверами. Каждая часть системы может вообще не применять стратегию ограничения скорости или может по-разному комбинировать одну или несколько стратегий, поэтому для обеспечения оптимальной работы требуется представление всей системы. Даже в тех случаях, когда ограничение скорости реализовано полностью на стороне сервера, клиент должен реагировать соответствующим образом. В большинстве ситуаций, если инструмент или инфраструктура, реализующая вашу стратегию ограничения скорости, не работает или недоступен, ваша служба должна открываться с ошибкой и пытаться обслужить все запросы. Клиенты, как правило, не выходят за рамки квот, и сбой при открытии менее опасен для крупномасштабных систем, чем сбой при закрытии. Отказ в закрытии приводит к полному выходу из строя, а отказ при открытии приводит к ухудшению состояния. Решения о неудачном открытии или закрытии в основном относятся к стороне сервера, но знание того, какие методы повторных попыток используют клиенты при неудачном запросе, может повлиять на ваши решения, принимаемые в отношении поведения сервера.</p>\n<h3>Без ограничения скорости</h3>\n<hr />\n<p style=\"font-size: 16px;\">Важно рассмотреть вариант без ограничения скорости в качестве минимального уровня в вашем проекте, то есть как наихудший случай, который ваша система должна быть в состоянии приспособить. Создайте свою систему с надежной обработкой ошибок на случай, если какая-то часть вашей стратегии ограничения скорости перестанет работать, и поймите, что пользователи вашего сервиса получат в таких ситуациях. Убедитесь, что вы предоставляете полезные коды ошибок и не допускаете утечки конфиденциальных данных в кодах ошибок. Использование тайм-аутов, крайних сроков и шаблонов отключения помогает вашей службе быть более надежной при отсутствии ограничения скорости.</p>\n<h3>Пересечения</h3>\n<hr />\n<p style=\"font-size: 16px;\">Если ваша служба вызывает другие службы для выполнения запросов, вы можете выбрать способ передачи любых сигналов ограничения скорости от этих служб обратно исходному вызывающему абоненту.</p>\n<blockquote>\n<p style=\"font-size: 16px;\">Примечание. В службах HTTP наиболее распространенным способом, которым службы сигнализируют о применении ограничения скорости, является возврат кода состояния <code>429</code> в ответе HTTP. Ответ <code>429</code> может предоставить дополнительную информацию о том, почему применяется ограничение (например, пользователь Freemium имеет меньшую квоту или система находится на обслуживании).</p>\n</blockquote>\n<p style=\"font-size: 16px;\">Самый простой вариант — перенаправить только ответ об ограничении скорости от нисходящей службы вызывающей стороне. Альтернативой является принудительное ограничение скорости от имени нижестоящей службы и блокировка вызывающего абонента.</p>\n<h3>Применять ограничения скорости</h3>\n<hr />\n<p style=\"font-size: 16px;\">Наиболее распространенная стратегия ограничения скорости заключается в том, что служба применяет один или несколько методов <a href=\"https://cloud.google.com/architecture/rate-limiting-strategies-techniques#techniques-enforcing-rate-limits\">принудительного ограничения скорости</a>. Это ограничение скорости может быть введено для непосредственной защиты службы или может быть введено для защиты нижестоящего ресурса, когда известно, что нижестоящая служба не может защитить себя. Например, если вы используете службу API, которая подключается к устаревшей серверной системе, неустойчивой к большим нагрузкам, служба API не должна использовать стратегию сквозного доступа, предполагая, что устаревшая служба будет предоставлять свои собственные сигналы ограничения скорости.</p>\n<p style=\"font-size: 16px;\">Чтобы применить ограничение скорости, сначала поймите, почему оно применяется в данном случае, а затем определите, какие атрибуты запроса лучше всего подходят для использования в качестве ограничивающего ключа (например, исходный IP-адрес, пользователь, ключ API). После выбора ограничивающего ключа ограничивающая реализация может использовать его для отслеживания использования. Когда лимиты достигнуты, сервис возвращает ограничивающий сигнал (обычно HTTP-ответ <code>429</code>).</p>\n<h3>Отложенные ответ</h3>\n<hr />\n<p style=\"font-size: 16px;\">Если вычисление ответа обходится дорого или требует много времени, система может быть не в состоянии предоставить быстрый ответ на запрос, что усложняет для службы обработку запросов с высокой частотой. Альтернативой ограничению скорости в этих случаях является помещение запросов в очередь и возврат определенного идентификатора задания. Это позволяет службе поддерживать более высокую доступность и снижает объем вычислений для клиентов, которые в противном случае могли бы выполнять длительные блокирующие вызовы в ожидании ответа. То, как результат отложенного ответа возвращается вызывающей стороне, является другим набором вариантов, но обычно он включает опрос состояния идентификатора задания или через систему, полностью основанную на событиях, в которой вызывающая сторона может зарегистрировать обратный вызов или подписаться на запрос. канал событий. Такая система выходит за рамки данного документа. Шаблон отложенного ответа проще всего применить, когда немедленный ответ на запрос не содержит реальной информации. Если этим шаблоном злоупотреблять, это может увеличить сложность и режимы отказов вашей системы.</p>\n<h3>Стратегии на стороне клиента</h3>\n<hr />\n<p style=\"font-size: 16px;\">Описанные до сих пор стратегии применяются для ограничения скорости на стороне сервера. Однако эти стратегии могут помочь при проектировании клиентов, особенно если учесть, что многие компоненты распределенной системы являются одновременно и клиентскими, и серверными.</p>\n<p style=\"font-size: 16px;\">Точно так же, как основная цель службы при использовании ограничения скорости — защитить себя и поддерживать доступность, основная цель клиента — выполнить запрос, который он отправляет службе. Служба может быть не в состоянии выполнить запрос от клиента по разным причинам, включая следующие:</p>\n<ul>\n<li>The service is unreachable because of network conditions.</li>\n<li>The service returned a non-specific error.</li>\n<li>The service denies the request because of an authentication or authorization failure.</li>\n<li>The client request is invalid or malformed.</li>\n<li>The service rate-limits the caller and sends a backpressure signal (commonly a <code>429</code> response).</li>\n</ul>\n<p style=\"font-size: 16px;\">Мы рекомендуем проектировать клиентов так, чтобы они были устойчивы к этим типам проблем. <a href=\"https://cloud.google.com/apis/docs/cloud-client-libraries\">Клиентские библиотеки</a>, предоставляемые Google, имеют множество встроенных функций, которые распознают описанные выше сценарии.</p>\n<p style=\"font-size: 16px;\">В ответ на ограничивающие скорость, прерывистые или неспецифические ошибки клиент обычно должен повторить запрос после задержки. Рекомендуется увеличивать эту задержку экспоненциально после каждого неудачного запроса, что называется экспоненциальной отсрочкой. Когда многие клиенты могут делать запросы на основе расписания (например, выборка результатов каждый час), следует применять дополнительное случайное время (дрожание) к времени запроса, периоду отсрочки или к тому и другому, чтобы гарантировать, что эти несколько экземпляров клиента не станут периодические <a href=\"https://wikipedia.org/wiki/Thundering_herd_problem\">гремящие стада</a>, а сами вызывают форму DDoS.</p>\n<p style=\"font-size: 16px;\">Представьте себе мобильное приложение со многими пользователями, которое регистрируется с помощью API каждый день ровно в полдень и применяет одну и ту же детерминированную логику отсрочки. В полдень многие клиенты звонят в службу, которая запускает ограничение скорости и возвращает ответы с кодом состояния 429. Затем клиенты послушно отступают и ждут установленное время (детерминированная задержка) ровно 60 секунд, а затем в 12:01 служба получает еще один большой набор запросов. Добавляя случайное смещение (джиттер) ко времени первоначального запроса или времени задержки, запросы и повторные попытки могут быть распределены более равномерно, что повышает шансы службы на выполнение запросов.</p>\n<p style=\"font-size: 16px;\">В идеале неидемпотентные запросы могут выполняться в контексте строго согласованной транзакции, но не все запросы на обслуживание могут предложить такие гарантии, поэтому при повторных попытках, изменяющих данные, необходимо учитывать последствия дублирования действий.</p>\n<p style=\"font-size: 16px;\">В ситуациях, когда разработчик клиента знает, что вызываемая им система неустойчива к стрессовым нагрузкам и не поддерживает сигналы, ограничивающие скорость (противодавление), разработчик клиентской библиотеки или разработчик клиентского приложения может выбрать применение самостоятельных ограничений. регулирование скорости с использованием тех же <a href=\"https://cloud.google.com/architecture/rate-limiting-strategies-techniques#techniques-enforcing-rate-limits\">методов ограничения скорости</a>, что и на стороне сервера.</p>\n<p style=\"font-size: 16px;\">Для клиентов API, которые откладывают ответ с идентификатором асинхронной длительной операции, клиент может войти в блокирующий цикл, опрашивая состояние отложенного ответа, устраняя эту сложность для пользователя клиентской библиотеки.</p>\n<h3>Методы обеспечения ограничения скорости</h3>\n<hr />\n<p style=\"font-size: 16px;\">В общем, скорость — это просто подсчет событий с течением времени. Тем не менее, существует несколько различных методов измерения и ограничения ставок, каждый из которых имеет свои собственные применения и последствия.</p>\n<ul>\n<li>\n<p style=\"font-size: 16px;\"><strong>Ведро токенов</strong>: <a href=\"https://wikipedia.org/wiki/Token_bucket\">ведро токенов</a> поддерживает скользящий и накапливающийся бюджет использования в виде баланса токенов. Этот метод признает, что не все входные данные для службы соответствуют 1:1 запросам. Ведро токенов добавляет токены с определенной скоростью. Когда делается запрос на обслуживание, сервис пытается отозвать токен (уменьшая количество токенов) для выполнения запроса. Если в ведре нет токенов, сервис достиг своего предела и отвечает обратным давлением. Например, в службе GraphQL один запрос может привести к нескольким операциям, которые объединяются в результат. Каждая из этих операций может занимать по одному маркеру. Таким образом, служба может отслеживать пропускную способность, которая необходима для ограничения использования, а не привязывать метод ограничения скорости непосредственно к запросам.</p>\n</li>\n<li>\n<p style=\"font-size: 16px;\"><strong>Дырявое ведро</strong>: <a href=\"https://wikipedia.org/wiki/Leaky_bucket\">Дырявое ведро</a> похоже на ведро с жетонами, но скорость ограничена количеством, которое может капать или вытекать из ведра. Этот метод признает, что система имеет некоторую ограниченную способность удерживать запрос до тех пор, пока служба не сможет обработать его; все лишнее просто выливается за край и отбрасывается. Это понятие емкости буфера (но не обязательно использование дырявых корзин) также применимо к компонентам, смежным с вашей службой, таким как балансировщики нагрузки и дисковые буферы ввода-вывода.</p>\n</li>\n<li>\n<p style=\"font-size: 16px;\"><strong>Фиксированное окно</strong>. Пределы фиксированного окна, такие как 3000 запросов в час или 10 запросов в день, установить несложно, но они подвержены всплескам по краям окна по мере сброса доступной квоты. Возьмем, к примеру, ограничение в 3000 запросов в час, которое по-прежнему допускает всплеск всех 3000 запросов в первую минуту часа, что может привести к перегрузке службы.</p>\n</li>\n<li>\n<p style=\"font-size: 16px;\"><strong>Скользящее окно</strong>: Скользящее окно имеет преимущества фиксированного окна, но скользящее окно времени сглаживает всплески. Такие системы, как Redis, облегчают эту технику с помощью ключей с истекающим сроком действия.</p>\n</li>\n</ul>\n<p style=\"font-size: 16px;\">Когда у вас есть много независимо работающих экземпляров службы (например, облачных функций) в распределенной системе, и службу необходимо ограничить в целом, вам необходимо использовать быструю, логически глобальную (глобальную для всех запущенных функций, а не обязательно географически глобальное) хранилище ключей и значений, такое как Redis, для синхронизации различных счетчиков лимитов.</p>\n<h3>Функции ограничения скорости в Google Cloud</h3>\n<hr />\n<p style=\"font-size: 16px;\">Каждый API Google (внутренний и внешний) применяет некоторую степень ограничения скорости или квоты. Это фундаментальный принцип дизайна услуг в Google. В этом разделе рассматривается, как эти службы также предоставляют ограничение скорости как функцию, которую вы можете использовать при создании в Google Cloud.</p>\n<h3>Квота и ограничения</h3>\n<hr />\n<p style=\"font-size: 16px;\">Google Cloud применяет квоты, которые ограничивают объем определенного ресурса Google Cloud, который может использовать ваш проект. Квоты скорости указывают, сколько ресурсов может быть использовано в данный момент времени, например запросов API в день. Вы также можете установить свои собственные ограничения на то, сколько ресурсов можно использовать в данный момент времени; такие пользовательские ограничения называются ограничениями.</p>\n<p style=\"font-size: 16px;\">Дополнительные сведения о квотах и ​​ограничениях, включая информацию о том, как устанавливать ограничения и запрашивать увеличение квоты, см. в разделе <a href=\"https://cloud.google.com/docs/quota\">Работа с квотами</a>.</p>\n<p style=\"font-size: 16px;\">У каждого продукта Google Cloud есть страница, на которой перечислены ограничения служб (например, максимальные размеры сообщений) и квоты на основе скорости (например, максимальное количество запросов в секунду для определенного API). На этих страницах также указано, можете ли вы запрашивать увеличение или нет. Чтобы найти эти страницы, начните с этого <a href=\"https://cloud.google.com/s/results?q=%22quotas%20and%20limits%22\">поиска</a>.</p>\n<p style=\"font-size: 16px;\">Как правило, квоты Google Cloud указаны для каждого проекта, а окна — в секунду или в минуту. Если в проекте запущено несколько частей решения, важно отметить, что они совместно используют эти квоты.</p>\n<p style=\"font-size: 16px;\">Вы можете <a href=\"https://cloud.google.com/apis/docs/monitoring\">отслеживать</a>, как используется ваша квота, и даже устанавливать оповещения об изменениях в том, как вы используете квоту, или когда использование превышает определенное количество. Вы можете установить <a href=\"https://cloud.google.com/apis/docs/capping-api-usage\">собственное ограничение</a> на использование API и использовать <a href=\"https://cloud.google.com/billing/docs/how-to/budgets\">оповещения о бюджете</a>, чтобы контролировать расходы, связанные с использованием API.</p>\n<h3>Cloud Tasks</h3>\n<hr />\n<p style=\"font-size: 16px;\">Cloud Tasks — это полностью управляемая служба, которую можно использовать для управления выполнением, отправкой и доставкой большого количества распределенных задач. Используя Cloud Tasks, вы можете асинхронно выполнять работу вне запроса пользователя. Cloud Tasks позволяет вам устанавливать <a href=\"https://cloud.google.com/tasks/docs/creating-appengine-queues#rate\">ограничения как на скорость, так и на параллелизм</a>. Cloud Tasks использует технику корзины с маркерами, чтобы обеспечить <a href=\"https://cloud.google.com/cloud-tasks/docs/reference/rest/v2beta2/projects.locations.queues#RateLimits\">неравномерность</a> доставки сообщений в этих пределах.</p>\n<h3>Cloud Functions</h3>\n<hr />\n<p style=\"font-size: 16px;\">Cloud Functions — это легкое решение для вычислений, позволяющее разработчикам создавать одноцелевые автономные функции, которые реагируют на облачные события без необходимости управлять сервером или средой выполнения. Облачные функции по умолчанию не имеют состояния и легко масштабируются: управляемая инфраструктура Google автоматически создает экземпляры функций для обработки входящих запросов. Из-за такого поведения масштабирования функции могут стать объектами высокой частоты запросов, и если эти функции вызывают нижестоящие службы, функции могут стать источником непреднамеренного DoS для этих нижестоящих служб.</p>\n<p style=\"font-size: 16px;\">Одним из типов DoS является исчерпание соединений в базах данных. Если каждый экземпляр функции устанавливает соединение базы данных с серверной частью, всплеск трафика может привести к автоматическому масштабированию многих экземпляров и, следовательно, к исчерпанию доступной емкости соединений на серверах баз данных. Чтобы предотвратить масштабирование функций за пределы определенного количества экземпляров, служба предоставляет настройку <a href=\"https://cloud.google.com/functions/docs/configuring/max-instances\">максимального количества экземпляров для каждой функции</a>.</p>\n<p style=\"font-size: 16px;\">Для фоновых функций Google Cloud вызывает вашу функцию с полезной нагрузкой и контекстом события. Вы можете указать, хотите ли вы, чтобы система <a href=\"https://cloud.google.com/functions/docs/bestpractices/retries\">повторяла попытку доставки события</a>, если ваша функция дает сбой или не может обработать событие — возможно, из-за того, что его скорость ограничена чем-то нижестоящим.</p>\n<p style=\"font-size: 16px;\">Хотя настройка максимального количества экземпляров может помочь вам ограничить параллелизм, она не дает прямого контроля над тем, сколько раз в секунду может вызываться ваша функция. См. раздел «<a href=\"https://cloud.google.com/architecture/rate-limiting-strategies-techniques#whats_next\">Что дальше</a>» для руководств, демонстрирующих, как использовать Redis для глобальной координации ограничения скорости вызовов функций.</p>\n<h3>Pub/Sub: управление потоком</h3>\n<hr />\n<p style=\"font-size: 16px;\">Pub/Sub — это полностью управляемая служба обмена сообщениями в реальном времени, которая позволяет отправлять и получать сообщения между независимыми приложениями. При перемещении большого количества сообщений через темы Pub/Sub вам может потребоваться настроить скорость обработки сообщений на клиентах-потребителях, чтобы потребители, работающие параллельно, были эффективны и не удерживали слишком много ожидающих сообщений, влияя на общую задержку обработки. Чтобы настроить это поведение, клиенты Pub/Sub предоставляют несколько <a href=\"https://cloud.google.com/pubsub/docs/pull#flow_control\">параметров управления потоком</a>.</p>\n<h3>Cloud Run</h3>\n<hr />\n<p style=\"font-size: 16px;\">Cloud Run — это управляемая вычислительная платформа, которая позволяет запускать контейнеры без сохранения состояния, которые можно вызывать с помощью HTTP-запросов. В отличие от облачных функций, один экземпляр контейнера может обрабатывать несколько запросов <a href=\"https://cloud.google.com/run/docs/about-concurrency\">одновременно</a>, если это поддерживается обслуживающим стеком в контейнере.</p>\n<h3>Istio</h3>\n<hr />\n<p style=\"font-size: 16px;\"><a href=\"https://cloud.google.com/istio\">Istio</a> — это независимая сервисная сетка с открытым исходным кодом, которая предоставляет основы, необходимые для успешного запуска распределенной микросервисной архитектуры. Отказоустойчивая микросервисная архитектура требует, чтобы сервисы были защищены от мошеннических одноранговых сервисов, поэтому Istio обеспечивает <a href=\"https://istio.io/v1.4/docs/tasks/policy-enforcement/rate-limiting/#rate-limits\">ограничение скорости</a> непосредственно в сервисной сетке.</p>\n<h3>Cloud Endpoints</h3>\n<hr />\n<p style=\"font-size: 16px;\"><a href=\"https://cloud.google.com/endpoints/docs\">Cloud Endpoints</a> — это система управления API, которая помогает вам защищать, отслеживать, анализировать и устанавливать квоты для ваших API, используя ту же инфраструктуру, которую Google использует для своих собственных API. Являясь службой, призванной помочь вам предоставлять услуги внешнему миру, она предоставляет возможность <a href=\"https://cloud.google.com/endpoints/docs/openapi/quotas-configure\">настраивать собственные квоты</a>, включая <a href=\"https://cloud.google.com/endpoints/docs/openapi/quotas-configure#quota_configuration_examples\">политики на основе скорости</a>.</p>\n<h3>Apigee</h3>\n<hr />\n<p style=\"font-size: 16px;\">Apigee — это платформа для разработки и управления API-прокси. Прокси-сервер API — это ваш интерфейс для разработчиков, которые хотят использовать ваши серверные службы. Вместо того, чтобы напрямую использовать эти услуги, они получают доступ к прокси API Apigee, который вы создаете. Обычно Apigee размещают перед серверными службами, которые могут не иметь собственных возможностей ограничения скорости, поэтому ограничение скорости является встроенной функцией Apigee.</p>\n<h3>Google Cloud Armor</h3>\n<hr />\n<p style=\"font-size: 16px;\">Google Cloud Armor использует <a href=\"https://cloud.google.com/armor\">глобальную инфраструктуру и системы безопасности Google для защиты от распределенных атак типа «отказ в обслуживании» (DDoS)</a> против инфраструктуры и приложений. Это включает в себя встроенную логику в отношении вредоносных всплесков и высокой нагрузки на ваши защищенные службы.</p>\n<h3>Project Shield</h3>\n<hr />\n<p style=\"font-size: 16px;\">Хотя <a href=\"https://projectshield.withgoogle.com/public/\">Project Shield</a> не является облачным сервисом Google, он использует инфраструктуру Google для защиты соответствующих сайтов от DDoS-атак.</p>\n<h3>Дополнительные методы для большей устойчивости</h3>\n<hr />\n<p style=\"font-size: 16px;\">Ограничение скорости на уровне приложения может предоставлять услуги с повышенной устойчивостью, но устойчивость можно дополнительно улучшить, комбинируя ограничение скорости на уровне приложения с другими методами:</p>\n<ul>\n<li>\n<p style=\"font-size: 16px;\"><strong>Кэширование</strong>. Хранение результатов, вычисление которых происходит медленно, позволяет службе обрабатывать запросы с более высокой скоростью, что может привести к тому, что противодавление, ограничивающее скорость, будет применяться к клиентам реже.</p>\n</li>\n<li>\n<p style=\"font-size: 16px;\"><strong>Разрыв цепи</strong>: Вы можете сделать сервисные сети более устойчивыми к проблемам, возникающим из-за распространения повторяющихся ошибок, путем временной блокировки частей системы в тихое состояние. Пример реализации см. в разделе «Размыкание цепи» документации Istio.</p>\n</li>\n<li>\n<p style=\"font-size: 16px;\"><strong>Приоритизация</strong>: не все пользователи системы имеют одинаковый приоритет. Учитывайте дополнительные факторы при разработке ключей ограничения скорости, чтобы обеспечить обслуживание клиентов с более высоким приоритетом. Вы можете использовать сброс нагрузки, чтобы снять с систем бремя низкоприоритетного трафика.</p>\n</li>\n<li>\n<p style=\"font-size: 16px;\"><strong>Ограничение скорости на нескольких уровнях</strong>: если сетевой интерфейс вашего компьютера или ядро ​​ОС перегружены, то ограничение скорости на уровне приложения может никогда не начаться. Вы можете применять ограничения скорости на уровне 3 в iptables, или локальные устройства могут ограничивать на уровне 4. Вы также можете столкнуться с настраиваемыми ограничениями скорости, применяемыми к вводу-выводу вашей системы для таких вещей, как дисковые и сетевые буферы.</p>\n</li>\n<li>\n<p style=\"font-size: 16px;\"><strong>Мониторинг</strong>. Персоналу операционных систем крайне важно знать, когда происходит регулирование. Мониторинг ставок, превышающих квоты, имеет решающее значение для управления инцидентами и обнаружения регрессий в программном обеспечении. Мы рекомендуем реализовать такой мониторинг как для клиентской, так и для серверной точек зрения служб. Не все случаи ограничения скорости должны вызывать предупреждения, требующие немедленного внимания со стороны эксплуатационного персонала. В некритических случаях вы можете отреагировать на сигналы ограничения скорости позже, в рамках плановой оценки и обслуживания вашей системы. Вы можете использовать журналы о том, когда происходит ограничение скорости, как сигнал о необходимости внесения изменений, таких как увеличение емкости компонента, запрос на увеличение квоты или изменение политики.</p>\n</li>\n</ul>\n",
      "category": 2,
      "author": "Cloud Architecture Center",
      "author_contact": "https://cloud.google.com/architecture",
      "is_comments_available": false,
      "is_already_formatted": true,
      "tags": [
        2,
        4,
        5,
        6
      ]
    }
  },
  {
    "model": "core.post",
    "pk": 3,
    "fields": {
      "uuid": "02068d8b-6752-486f-b367-0fb4ff3a4bd6",
      "created_at": "2022-06-08T15:01:54.442Z",
      "updated_at": "2022-06-08T15:12:07.494Z",
      "language": "ru",
      "title": "Дроссельные запросы API для повышения пропускной способности",
      "slug": "дроссельные-запросы-api-для-повышения-пропускной-способности",
      "markdown": "Вы можете настроить регулирование и квоты для своих API, чтобы защитить их от перегрузки слишком большим количеством запросов. Как ограничения, так и квоты применяются на основе максимальных усилий, и их следует рассматривать как целевые показатели, а не как гарантированные потолки запросов.\r\n\r\nШлюз API регулирует запросы к вашему API, используя алгоритм корзины токенов, где токен учитывается в запросе. В частности, API Gateway проверяет скорость и количество отправленных запросов для всех API в вашей учетной записи по регионам. В алгоритме корзины токенов всплеск может позволить заранее заданное превышение этих пределов, но другие факторы также могут привести к превышению пределов в некоторых случаях.\r\n\r\nКогда отправленные запросы превышают стабильную скорость запросов и лимиты пакетов, API Gateway начинает блокировать запросы. В этот момент клиенты могут получить ответ об ошибке `429 Too Many Requests`. После перехвата таких исключений клиент может повторно отправить неудавшиеся запросы способом, ограничивающим скорость.\r\n\r\nКак разработчик API, вы можете установить целевые ограничения для отдельных этапов или методов API, чтобы повысить общую производительность всех API в вашей учетной записи. Кроме того, вы можете включить планы использования, чтобы установить ограничения на отправку клиентских запросов на основе указанных частот запросов и квот.\r\n\r\n### Как применяются настройки ограничения регулирования в API Gateway\r\n---\r\n\r\nПрежде чем настраивать параметры ограничения и квоты для своего API, полезно понять, как они применяются Amazon API Gateway.\r\n\r\nAmazon API Gateway предоставляет четыре основных типа настроек, связанных с регулированием:\r\n\r\n* Ограничения регулирования AWS применяются ко всем аккаунтам и клиентам в регионе. Эти ограничения существуют для того, чтобы ваш API и ваша учетная запись не перегружались слишком большим количеством запросов. Эти ограничения устанавливаются AWS и не могут быть изменены клиентом.\r\n\r\n* Ограничения на учетную запись применяются ко всем API в учетной записи в указанном регионе. Ограничение скорости на уровне учетной записи может быть увеличено по запросу — более высокие ограничения возможны с API, которые имеют более короткие тайм-ауты и меньшую полезную нагрузку. Чтобы запросить увеличение ограничений регулирования на уровне аккаунта для каждого региона, обратитесь в Центр поддержки AWS. Дополнительные сведения см. в разделе [Квоты Amazon API Gateway и важные примечания](https://docs.aws.amazon.com/apigateway/latest/developerguide/limits.html).\r\n\r\n* Ограничения регулирования для каждого API и этапа применяются на уровне метода API для этапа. Вы можете настроить одни и те же параметры для всех методов или настроить разные параметры дроссельной заслонки для каждого метода. Обратите внимание, что эти ограничения не могут превышать ограничения регулирования AWS.\r\n\r\n* Ограничения регулирования для каждого клиента применяются к клиентам, которые используют ключи API, связанные с вашим планом использования, в качестве идентификатора клиента. Обратите внимание, что эти ограничения не могут быть выше, чем ограничения для каждой учетной записи.\r\n\r\nПараметры, связанные с регулированием шлюза API, применяются в следующем порядке:\r\n\r\n* [Ограничения регулирования для каждого клиента или метода](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-request-throttling.html#apigateway-method-level-throttling-in-usage-plan), которые вы устанавливаете для этапа API в [плане использования](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-create-usage-plans-with-console.html#api-gateway-usage-plan-create). \r\n* Ограничения регулирования для каждого метода, которые вы устанавливаете для этапа API. \r\n* [Регулирование на уровне аккаунта по регионам ](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-request-throttling.html#apig-request-throttling-account-level-limits)\r\n* Региональное регулирование AWS\r\n\r\n\r\n### Регулирование на уровне аккаунта по регионам\r\n---\r\n\r\nПо умолчанию API Gateway ограничивает число устойчивых запросов в секунду (RPS) для всех API в учетной записи AWS для каждого региона. Он также ограничивает всплеск (то есть максимальный размер корзины) для всех API в учетной записи AWS для каждого региона. В API Gateway предельное количество пакетов представляет собой целевое максимальное количество одновременных отправок запросов, которые API Gateway будет выполнять, прежде чем возвратить ответы об ошибке `429 Too Many Requests`. Дополнительные сведения о регулировании квот см. в разделе [Квоты Amazon API Gateway и важные примечания](https://docs.aws.amazon.com/apigateway/latest/developerguide/limits.html).\r\n\r\n### Настройка целей регулирования на уровне API и на уровне этапа в плане использования\r\n---\r\n\r\nВ плане использования вы можете установить цель регулирования для каждого метода для всех методов на уровне API или этапа в разделе «Создать план использования».\r\n\r\n### Настройка целей регулирования на уровне метода в плане использования\r\n---\r\n\r\nВы можете установить дополнительные цели регулирования на уровне метода в планах использования, как показано в разделе Создание плана использования. В консоли API Gateway они устанавливаются путем указания `Resource=<resource>`, `Method=<method>` в параметре `Configure Method Throttling`. Например, для [примера PetStore](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-create-api-step-by-step.html) можно указать `Resource=/pets`, `Method=GET`.",
      "body": "<p style=\"font-size: 16px;\">Вы можете настроить регулирование и квоты для своих API, чтобы защитить их от перегрузки слишком большим количеством запросов. Как ограничения, так и квоты применяются на основе максимальных усилий, и их следует рассматривать как целевые показатели, а не как гарантированные потолки запросов.</p>\n<p style=\"font-size: 16px;\">Шлюз API регулирует запросы к вашему API, используя алгоритм корзины токенов, где токен учитывается в запросе. В частности, API Gateway проверяет скорость и количество отправленных запросов для всех API в вашей учетной записи по регионам. В алгоритме корзины токенов всплеск может позволить заранее заданное превышение этих пределов, но другие факторы также могут привести к превышению пределов в некоторых случаях.</p>\n<p style=\"font-size: 16px;\">Когда отправленные запросы превышают стабильную скорость запросов и лимиты пакетов, API Gateway начинает блокировать запросы. В этот момент клиенты могут получить ответ об ошибке <code>429 Too Many Requests</code>. После перехвата таких исключений клиент может повторно отправить неудавшиеся запросы способом, ограничивающим скорость.</p>\n<p style=\"font-size: 16px;\">Как разработчик API, вы можете установить целевые ограничения для отдельных этапов или методов API, чтобы повысить общую производительность всех API в вашей учетной записи. Кроме того, вы можете включить планы использования, чтобы установить ограничения на отправку клиентских запросов на основе указанных частот запросов и квот.</p>\n<h3>Как применяются настройки ограничения регулирования в API Gateway</h3>\n<hr />\n<p style=\"font-size: 16px;\">Прежде чем настраивать параметры ограничения и квоты для своего API, полезно понять, как они применяются Amazon API Gateway.</p>\n<p style=\"font-size: 16px;\">Amazon API Gateway предоставляет четыре основных типа настроек, связанных с регулированием:</p>\n<ul>\n<li>\n<p style=\"font-size: 16px;\">Ограничения регулирования AWS применяются ко всем аккаунтам и клиентам в регионе. Эти ограничения существуют для того, чтобы ваш API и ваша учетная запись не перегружались слишком большим количеством запросов. Эти ограничения устанавливаются AWS и не могут быть изменены клиентом.</p>\n</li>\n<li>\n<p style=\"font-size: 16px;\">Ограничения на учетную запись применяются ко всем API в учетной записи в указанном регионе. Ограничение скорости на уровне учетной записи может быть увеличено по запросу — более высокие ограничения возможны с API, которые имеют более короткие тайм-ауты и меньшую полезную нагрузку. Чтобы запросить увеличение ограничений регулирования на уровне аккаунта для каждого региона, обратитесь в Центр поддержки AWS. Дополнительные сведения см. в разделе <a href=\"https://docs.aws.amazon.com/apigateway/latest/developerguide/limits.html\">Квоты Amazon API Gateway и важные примечания</a>.</p>\n</li>\n<li>\n<p style=\"font-size: 16px;\">Ограничения регулирования для каждого API и этапа применяются на уровне метода API для этапа. Вы можете настроить одни и те же параметры для всех методов или настроить разные параметры дроссельной заслонки для каждого метода. Обратите внимание, что эти ограничения не могут превышать ограничения регулирования AWS.</p>\n</li>\n<li>\n<p style=\"font-size: 16px;\">Ограничения регулирования для каждого клиента применяются к клиентам, которые используют ключи API, связанные с вашим планом использования, в качестве идентификатора клиента. Обратите внимание, что эти ограничения не могут быть выше, чем ограничения для каждой учетной записи.</p>\n</li>\n</ul>\n<p style=\"font-size: 16px;\">Параметры, связанные с регулированием шлюза API, применяются в следующем порядке:</p>\n<ul>\n<li><a href=\"https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-request-throttling.html#apigateway-method-level-throttling-in-usage-plan\">Ограничения регулирования для каждого клиента или метода</a>, которые вы устанавливаете для этапа API в <a href=\"https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-create-usage-plans-with-console.html#api-gateway-usage-plan-create\">плане использования</a>.</li>\n<li>Ограничения регулирования для каждого метода, которые вы устанавливаете для этапа API.</li>\n<li><a href=\"https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-request-throttling.html#apig-request-throttling-account-level-limits\">Регулирование на уровне аккаунта по регионам </a></li>\n<li>Региональное регулирование AWS</li>\n</ul>\n<h3>Регулирование на уровне аккаунта по регионам</h3>\n<hr />\n<p style=\"font-size: 16px;\">По умолчанию API Gateway ограничивает число устойчивых запросов в секунду (RPS) для всех API в учетной записи AWS для каждого региона. Он также ограничивает всплеск (то есть максимальный размер корзины) для всех API в учетной записи AWS для каждого региона. В API Gateway предельное количество пакетов представляет собой целевое максимальное количество одновременных отправок запросов, которые API Gateway будет выполнять, прежде чем возвратить ответы об ошибке <code>429 Too Many Requests</code>. Дополнительные сведения о регулировании квот см. в разделе <a href=\"https://docs.aws.amazon.com/apigateway/latest/developerguide/limits.html\">Квоты Amazon API Gateway и важные примечания</a>.</p>\n<h3>Настройка целей регулирования на уровне API и на уровне этапа в плане использования</h3>\n<hr />\n<p style=\"font-size: 16px;\">В плане использования вы можете установить цель регулирования для каждого метода для всех методов на уровне API или этапа в разделе «Создать план использования».</p>\n<h3>Настройка целей регулирования на уровне метода в плане использования</h3>\n<hr />\n<p style=\"font-size: 16px;\">Вы можете установить дополнительные цели регулирования на уровне метода в планах использования, как показано в разделе Создание плана использования. В консоли API Gateway они устанавливаются путем указания <code>Resource=&lt;resource&gt;</code>, <code>Method=&lt;method&gt;</code> в параметре <code>Configure Method Throttling</code>. Например, для <a href=\"https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-create-api-step-by-step.html\">примера PetStore</a> можно указать <code>Resource=/pets</code>, <code>Method=GET</code>.</p>\n",
      "category": 2,
      "author": "Amazon API Gateway",
      "author_contact": "https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-request-throttling.html",
      "is_comments_available": false,
      "is_already_formatted": true,
      "tags": [
        2,
        4,
        5,
        6
      ]
    }
  }
]